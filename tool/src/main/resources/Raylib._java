// do not edit - generated by generate.py
package com.raylib;

import java.lang.foreign.MemorySegment;
import java.lang.foreign.Arena;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;
import java.nio.IntBuffer;

import static com.raylib.jextract.raylib_h.*;
import static java.lang.foreign.ValueLayout.JAVA_FLOAT;
import static java.lang.foreign.ValueLayout.JAVA_INT;

public class Raylib{

    /**
     * Any IntBuffers you create *MUST* be direct allocation and native order.  Use this method to ensure that.
     * @param size
     * @return
     */
    public static IntBuffer createIntBuffer(int size){
        return ByteBuffer.allocateDirect((int)JAVA_INT.byteSize()*size).order(ByteOrder.nativeOrder()).asIntBuffer();
    }

    /**
     * Any FloatBuffers you create *MUST* be direct allocation and native order.  Use this method to ensure that.
     * @param size
     * @return
     */
    public static FloatBuffer createFloatBuffer(int size){
        return ByteBuffer.allocateDirect((int)JAVA_FLOAT.byteSize()*size).order(ByteOrder.nativeOrder()).asFloatBuffer();
    }

    /**
     * Any ByteBuffers you create *MUST* be direct allocation and native order.  Use this method to ensure that.
     * @param size
     * @return
     */
    public static ByteBuffer createByteBuffer(int size){
        return ByteBuffer.allocateDirect(size).order(ByteOrder.nativeOrder());
    }


    
    /**
     * Initialize window and OpenGL context
     */
    public static void initWindow(
            int width,  
            int height,  
            String title 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            com.raylib.jextract.raylib_h.InitWindow(
            width, height, localArena.allocateFrom(title)
        );
            
            }
    }
    
    
    /**
     * Close window and unload OpenGL context
     */
    public static void closeWindow(
        ){
            
            com.raylib.jextract.raylib_h.CloseWindow(
            
        );
            
            
    }
    
    
    /**
     * Check if application should close (KEY_ESCAPE pressed or windows close icon clicked)
     */
    public static boolean windowShouldClose(
        ){
            
            return com.raylib.jextract.raylib_h.WindowShouldClose(
            
        );
            
    }
    
    
    /**
     * Check if window has been initialized successfully
     */
    public static boolean isWindowReady(
        ){
            
            return com.raylib.jextract.raylib_h.IsWindowReady(
            
        );
            
    }
    
    
    /**
     * Check if window is currently fullscreen
     */
    public static boolean isWindowFullscreen(
        ){
            
            return com.raylib.jextract.raylib_h.IsWindowFullscreen(
            
        );
            
    }
    
    
    /**
     * Check if window is currently hidden
     */
    public static boolean isWindowHidden(
        ){
            
            return com.raylib.jextract.raylib_h.IsWindowHidden(
            
        );
            
    }
    
    
    /**
     * Check if window is currently minimized
     */
    public static boolean isWindowMinimized(
        ){
            
            return com.raylib.jextract.raylib_h.IsWindowMinimized(
            
        );
            
    }
    
    
    /**
     * Check if window is currently maximized
     */
    public static boolean isWindowMaximized(
        ){
            
            return com.raylib.jextract.raylib_h.IsWindowMaximized(
            
        );
            
    }
    
    
    /**
     * Check if window is currently focused
     */
    public static boolean isWindowFocused(
        ){
            
            return com.raylib.jextract.raylib_h.IsWindowFocused(
            
        );
            
    }
    
    
    /**
     * Check if window has been resized last frame
     */
    public static boolean isWindowResized(
        ){
            
            return com.raylib.jextract.raylib_h.IsWindowResized(
            
        );
            
    }
    
    
    /**
     * Check if one specific window flag is enabled
     */
    public static boolean isWindowState(
            int flag 
        ){
            
            return com.raylib.jextract.raylib_h.IsWindowState(
            flag
        );
            
    }
    
    
    /**
     * Set window configuration state using flags
     */
    public static void setWindowState(
            int flags 
        ){
            
            com.raylib.jextract.raylib_h.SetWindowState(
            flags
        );
            
            
    }
    
    
    /**
     * Clear window configuration state flags
     */
    public static void clearWindowState(
            int flags 
        ){
            
            com.raylib.jextract.raylib_h.ClearWindowState(
            flags
        );
            
            
    }
    
    
    /**
     * Toggle window state: fullscreen/windowed, resizes monitor to match window resolution
     */
    public static void toggleFullscreen(
        ){
            
            com.raylib.jextract.raylib_h.ToggleFullscreen(
            
        );
            
            
    }
    
    
    /**
     * Toggle window state: borderless windowed, resizes window to match monitor resolution
     */
    public static void toggleBorderlessWindowed(
        ){
            
            com.raylib.jextract.raylib_h.ToggleBorderlessWindowed(
            
        );
            
            
    }
    
    
    /**
     * Set window state: maximized, if resizable
     */
    public static void maximizeWindow(
        ){
            
            com.raylib.jextract.raylib_h.MaximizeWindow(
            
        );
            
            
    }
    
    
    /**
     * Set window state: minimized, if resizable
     */
    public static void minimizeWindow(
        ){
            
            com.raylib.jextract.raylib_h.MinimizeWindow(
            
        );
            
            
    }
    
    
    /**
     * Set window state: not minimized/maximized
     */
    public static void restoreWindow(
        ){
            
            com.raylib.jextract.raylib_h.RestoreWindow(
            
        );
            
            
    }
    
    
    /**
     * Set icon for window (single image, RGBA 32bit)
     */
    public static void setWindowIcon(
            Image image 
        ){
            
            com.raylib.jextract.raylib_h.SetWindowIcon(
            image.memorySegment
        );
            
            
    }
    
    
    /**
     * Set icon for window (multiple images, RGBA 32bit)
     */
    public static void setWindowIcons(
            Image images,  
            int count 
        ){
            
            com.raylib.jextract.raylib_h.SetWindowIcons(
            images.memorySegment, count
        );
            
            
    }
    
    
    /**
     * Set title for window
     */
    public static void setWindowTitle(
            String title 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            com.raylib.jextract.raylib_h.SetWindowTitle(
            localArena.allocateFrom(title)
        );
            
            }
    }
    
    
    /**
     * Set window position on screen
     */
    public static void setWindowPosition(
            int x,  
            int y 
        ){
            
            com.raylib.jextract.raylib_h.SetWindowPosition(
            x, y
        );
            
            
    }
    
    
    /**
     * Set monitor for the current window
     */
    public static void setWindowMonitor(
            int monitor 
        ){
            
            com.raylib.jextract.raylib_h.SetWindowMonitor(
            monitor
        );
            
            
    }
    
    
    /**
     * Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)
     */
    public static void setWindowMinSize(
            int width,  
            int height 
        ){
            
            com.raylib.jextract.raylib_h.SetWindowMinSize(
            width, height
        );
            
            
    }
    
    
    /**
     * Set window maximum dimensions (for FLAG_WINDOW_RESIZABLE)
     */
    public static void setWindowMaxSize(
            int width,  
            int height 
        ){
            
            com.raylib.jextract.raylib_h.SetWindowMaxSize(
            width, height
        );
            
            
    }
    
    
    /**
     * Set window dimensions
     */
    public static void setWindowSize(
            int width,  
            int height 
        ){
            
            com.raylib.jextract.raylib_h.SetWindowSize(
            width, height
        );
            
            
    }
    
    
    /**
     * Set window opacity [0.0f..1.0f]
     */
    public static void setWindowOpacity(
            float opacity 
        ){
            
            com.raylib.jextract.raylib_h.SetWindowOpacity(
            opacity
        );
            
            
    }
    
    
    /**
     * Set window focused
     */
    public static void setWindowFocused(
        ){
            
            com.raylib.jextract.raylib_h.SetWindowFocused(
            
        );
            
            
    }
    
    
    /**
     * Get native window handle
     */
    public static MemorySegment getWindowHandle(
        ){
            
            return com.raylib.jextract.raylib_h.GetWindowHandle(
            
        );
            
    }
    
    
    /**
     * Get current screen width
     */
    public static int getScreenWidth(
        ){
            
            return com.raylib.jextract.raylib_h.GetScreenWidth(
            
        );
            
    }
    
    
    /**
     * Get current screen height
     */
    public static int getScreenHeight(
        ){
            
            return com.raylib.jextract.raylib_h.GetScreenHeight(
            
        );
            
    }
    
    
    /**
     * Get current render width (it considers HiDPI)
     */
    public static int getRenderWidth(
        ){
            
            return com.raylib.jextract.raylib_h.GetRenderWidth(
            
        );
            
    }
    
    
    /**
     * Get current render height (it considers HiDPI)
     */
    public static int getRenderHeight(
        ){
            
            return com.raylib.jextract.raylib_h.GetRenderHeight(
            
        );
            
    }
    
    
    /**
     * Get number of connected monitors
     */
    public static int getMonitorCount(
        ){
            
            return com.raylib.jextract.raylib_h.GetMonitorCount(
            
        );
            
    }
    
    
    /**
     * Get current monitor where window is placed
     */
    public static int getCurrentMonitor(
        ){
            
            return com.raylib.jextract.raylib_h.GetCurrentMonitor(
            
        );
            
    }
    
    
    /**
     * Get specified monitor position
     */
    public static Vector2 getMonitorPosition(
            int monitor 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetMonitorPosition(Arena.ofAuto(), 
            monitor
        ));
            
            
    }
    
    /**
     * Get specified monitor position
     */
    public static Vector2 getMonitorPosition(Arena arena,  
            int monitor 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetMonitorPosition(arena, 
            monitor
        ));
            
            
    }
    
    
    /**
     * Get specified monitor width (current video mode used by monitor)
     */
    public static int getMonitorWidth(
            int monitor 
        ){
            
            return com.raylib.jextract.raylib_h.GetMonitorWidth(
            monitor
        );
            
    }
    
    
    /**
     * Get specified monitor height (current video mode used by monitor)
     */
    public static int getMonitorHeight(
            int monitor 
        ){
            
            return com.raylib.jextract.raylib_h.GetMonitorHeight(
            monitor
        );
            
    }
    
    
    /**
     * Get specified monitor physical width in millimetres
     */
    public static int getMonitorPhysicalWidth(
            int monitor 
        ){
            
            return com.raylib.jextract.raylib_h.GetMonitorPhysicalWidth(
            monitor
        );
            
    }
    
    
    /**
     * Get specified monitor physical height in millimetres
     */
    public static int getMonitorPhysicalHeight(
            int monitor 
        ){
            
            return com.raylib.jextract.raylib_h.GetMonitorPhysicalHeight(
            monitor
        );
            
    }
    
    
    /**
     * Get specified monitor refresh rate
     */
    public static int getMonitorRefreshRate(
            int monitor 
        ){
            
            return com.raylib.jextract.raylib_h.GetMonitorRefreshRate(
            monitor
        );
            
    }
    
    
    /**
     * Get window position XY on monitor
     */
    public static Vector2 getWindowPosition(
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetWindowPosition(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * Get window position XY on monitor
     */
    public static Vector2 getWindowPosition(Arena arena 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetWindowPosition(arena
            
        ));
            
            
    }
    
    
    /**
     * Get window scale DPI factor
     */
    public static Vector2 getWindowScaleDPI(
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetWindowScaleDPI(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * Get window scale DPI factor
     */
    public static Vector2 getWindowScaleDPI(Arena arena 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetWindowScaleDPI(arena
            
        ));
            
            
    }
    
    
    /**
     * Get the human-readable, UTF-8 encoded name of the specified monitor
     */
    public static String getMonitorName(
            int monitor 
        ){
            
            return com.raylib.jextract.raylib_h.GetMonitorName(
            monitor
        ).getString(0);
            
    }
    
    
    /**
     * Set clipboard text content
     */
    public static void setClipboardText(
            String text 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            com.raylib.jextract.raylib_h.SetClipboardText(
            localArena.allocateFrom(text)
        );
            
            }
    }
    
    
    /**
     * Get clipboard text content
     */
    public static String getClipboardText(
        ){
            
            return com.raylib.jextract.raylib_h.GetClipboardText(
            
        ).getString(0);
            
    }
    
    
    /**
     * Get clipboard image content
     */
    public static Image getClipboardImage(
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GetClipboardImage(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * Get clipboard image content
     */
    public static Image getClipboardImage(Arena arena 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GetClipboardImage(arena
            
        ));
            
            
    }
    
    
    /**
     * Enable waiting for events on EndDrawing(), no automatic event polling
     */
    public static void enableEventWaiting(
        ){
            
            com.raylib.jextract.raylib_h.EnableEventWaiting(
            
        );
            
            
    }
    
    
    /**
     * Disable waiting for events on EndDrawing(), automatic events polling
     */
    public static void disableEventWaiting(
        ){
            
            com.raylib.jextract.raylib_h.DisableEventWaiting(
            
        );
            
            
    }
    
    
    /**
     * Shows cursor
     */
    public static void showCursor(
        ){
            
            com.raylib.jextract.raylib_h.ShowCursor(
            
        );
            
            
    }
    
    
    /**
     * Hides cursor
     */
    public static void hideCursor(
        ){
            
            com.raylib.jextract.raylib_h.HideCursor(
            
        );
            
            
    }
    
    
    /**
     * Check if cursor is not visible
     */
    public static boolean isCursorHidden(
        ){
            
            return com.raylib.jextract.raylib_h.IsCursorHidden(
            
        );
            
    }
    
    
    /**
     * Enables cursor (unlock cursor)
     */
    public static void enableCursor(
        ){
            
            com.raylib.jextract.raylib_h.EnableCursor(
            
        );
            
            
    }
    
    
    /**
     * Disables cursor (lock cursor)
     */
    public static void disableCursor(
        ){
            
            com.raylib.jextract.raylib_h.DisableCursor(
            
        );
            
            
    }
    
    
    /**
     * Check if cursor is on the screen
     */
    public static boolean isCursorOnScreen(
        ){
            
            return com.raylib.jextract.raylib_h.IsCursorOnScreen(
            
        );
            
    }
    
    
    /**
     * Set background color (framebuffer clear color)
     */
    public static void clearBackground(
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ClearBackground(
            color.memorySegment
        );
            
            
    }
    
    
    /**
     * Setup canvas (framebuffer) to start drawing
     */
    public static void beginDrawing(
        ){
            
            com.raylib.jextract.raylib_h.BeginDrawing(
            
        );
            
            
    }
    
    
    /**
     * End canvas drawing and swap buffers (double buffering)
     */
    public static void endDrawing(
        ){
            
            com.raylib.jextract.raylib_h.EndDrawing(
            
        );
            
            
    }
    
    
    /**
     * Begin 2D mode with custom camera (2D)
     */
    public static void beginMode2D(
            Camera2D camera 
        ){
            
            com.raylib.jextract.raylib_h.BeginMode2D(
            camera.memorySegment
        );
            
            
    }
    
    
    /**
     * Ends 2D mode with custom camera
     */
    public static void endMode2D(
        ){
            
            com.raylib.jextract.raylib_h.EndMode2D(
            
        );
            
            
    }
    
    
    /**
     * Begin 3D mode with custom camera (3D)
     */
    public static void beginMode3D(
            Camera3D camera 
        ){
            
            com.raylib.jextract.raylib_h.BeginMode3D(
            camera.memorySegment
        );
            
            
    }
    
    
    /**
     * Ends 3D mode and returns to default 2D orthographic mode
     */
    public static void endMode3D(
        ){
            
            com.raylib.jextract.raylib_h.EndMode3D(
            
        );
            
            
    }
    
    
    /**
     * Begin drawing to render texture
     */
    public static void beginTextureMode(
            RenderTexture target 
        ){
            
            com.raylib.jextract.raylib_h.BeginTextureMode(
            target.memorySegment
        );
            
            
    }
    
    
    /**
     * Ends drawing to render texture
     */
    public static void endTextureMode(
        ){
            
            com.raylib.jextract.raylib_h.EndTextureMode(
            
        );
            
            
    }
    
    
    /**
     * Begin custom shader drawing
     */
    public static void beginShaderMode(
            Shader shader 
        ){
            
            com.raylib.jextract.raylib_h.BeginShaderMode(
            shader.memorySegment
        );
            
            
    }
    
    
    /**
     * End custom shader drawing (use default shader)
     */
    public static void endShaderMode(
        ){
            
            com.raylib.jextract.raylib_h.EndShaderMode(
            
        );
            
            
    }
    
    
    /**
     * Begin blending mode (alpha, additive, multiplied, subtract, custom)
     */
    public static void beginBlendMode(
            int mode 
        ){
            
            com.raylib.jextract.raylib_h.BeginBlendMode(
            mode
        );
            
            
    }
    
    
    /**
     * End blending mode (reset to default: alpha blending)
     */
    public static void endBlendMode(
        ){
            
            com.raylib.jextract.raylib_h.EndBlendMode(
            
        );
            
            
    }
    
    
    /**
     * Begin scissor mode (define screen area for following drawing)
     */
    public static void beginScissorMode(
            int x,  
            int y,  
            int width,  
            int height 
        ){
            
            com.raylib.jextract.raylib_h.BeginScissorMode(
            x, y, width, height
        );
            
            
    }
    
    
    /**
     * End scissor mode
     */
    public static void endScissorMode(
        ){
            
            com.raylib.jextract.raylib_h.EndScissorMode(
            
        );
            
            
    }
    
    
    /**
     * Begin stereo rendering (requires VR simulator)
     */
    public static void beginVrStereoMode(
            VrStereoConfig config 
        ){
            
            com.raylib.jextract.raylib_h.BeginVrStereoMode(
            config.memorySegment
        );
            
            
    }
    
    
    /**
     * End stereo rendering (requires VR simulator)
     */
    public static void endVrStereoMode(
        ){
            
            com.raylib.jextract.raylib_h.EndVrStereoMode(
            
        );
            
            
    }
    
    
    /**
     * Load VR stereo config for VR simulator device parameters
     */
    public static VrStereoConfig loadVrStereoConfig(
            VrDeviceInfo device 
        ){
            
             return new VrStereoConfig(com.raylib.jextract.raylib_h.LoadVrStereoConfig(Arena.ofAuto(), 
            device.memorySegment
        ));
            
            
    }
    
    /**
     * Load VR stereo config for VR simulator device parameters
     */
    public static VrStereoConfig loadVrStereoConfig(Arena arena,  
            VrDeviceInfo device 
        ){
            
             return new VrStereoConfig(com.raylib.jextract.raylib_h.LoadVrStereoConfig(arena, 
            device.memorySegment
        ));
            
            
    }
    
    
    /**
     * Unload VR stereo config
     */
    public static void unloadVrStereoConfig(
            VrStereoConfig config 
        ){
            
            com.raylib.jextract.raylib_h.UnloadVrStereoConfig(
            config.memorySegment
        );
            
            
    }
    
    
    /**
     * Load shader from files and bind default locations
     */
    public static Shader loadShader(
            String vsFileName,  
            String fsFileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Shader(com.raylib.jextract.raylib_h.LoadShader(Arena.ofAuto(), 
            localArena.allocateFrom(vsFileName), localArena.allocateFrom(fsFileName)
        ));
            
            }
    }
    
    /**
     * Load shader from files and bind default locations
     */
    public static Shader loadShader(Arena arena,  
            String vsFileName,  
            String fsFileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Shader(com.raylib.jextract.raylib_h.LoadShader(arena, 
            localArena.allocateFrom(vsFileName), localArena.allocateFrom(fsFileName)
        ));
            
            }
    }
    
    
    /**
     * Load shader from code strings and bind default locations
     */
    public static Shader loadShaderFromMemory(
            String vsCode,  
            String fsCode 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Shader(com.raylib.jextract.raylib_h.LoadShaderFromMemory(Arena.ofAuto(), 
            localArena.allocateFrom(vsCode), localArena.allocateFrom(fsCode)
        ));
            
            }
    }
    
    /**
     * Load shader from code strings and bind default locations
     */
    public static Shader loadShaderFromMemory(Arena arena,  
            String vsCode,  
            String fsCode 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Shader(com.raylib.jextract.raylib_h.LoadShaderFromMemory(arena, 
            localArena.allocateFrom(vsCode), localArena.allocateFrom(fsCode)
        ));
            
            }
    }
    
    
    /**
     * Check if a shader is valid (loaded on GPU)
     */
    public static boolean isShaderValid(
            Shader shader 
        ){
            
            return com.raylib.jextract.raylib_h.IsShaderValid(
            shader.memorySegment
        );
            
    }
    
    
    /**
     * Get shader uniform location
     */
    public static int getShaderLocation(
            Shader shader,  
            String uniformName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.GetShaderLocation(
            shader.memorySegment, localArena.allocateFrom(uniformName)
        );
            }
    }
    
    
    /**
     * Get shader attribute location
     */
    public static int getShaderLocationAttrib(
            Shader shader,  
            String attribName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.GetShaderLocationAttrib(
            shader.memorySegment, localArena.allocateFrom(attribName)
        );
            }
    }
    
    
    /**
     * Set shader uniform value
     */
    public static void setShaderValue(
            Shader shader,  
            int locIndex,  
            MemorySegment value,  
            int uniformType 
        ){
            
            com.raylib.jextract.raylib_h.SetShaderValue(
            shader.memorySegment, locIndex, value, uniformType
        );
            
            
    }
    
    
    /**
     * Set shader uniform value vector
     */
    public static void setShaderValueV(
            Shader shader,  
            int locIndex,  
            MemorySegment value,  
            int uniformType,  
            int count 
        ){
            
            com.raylib.jextract.raylib_h.SetShaderValueV(
            shader.memorySegment, locIndex, value, uniformType, count
        );
            
            
    }
    
    
    /**
     * Set shader uniform value (matrix 4x4)
     */
    public static void setShaderValueMatrix(
            Shader shader,  
            int locIndex,  
            Matrix mat 
        ){
            
            com.raylib.jextract.raylib_h.SetShaderValueMatrix(
            shader.memorySegment, locIndex, mat.memorySegment
        );
            
            
    }
    
    
    /**
     * Set shader uniform value for texture (sampler2d)
     */
    public static void setShaderValueTexture(
            Shader shader,  
            int locIndex,  
            Texture texture 
        ){
            
            com.raylib.jextract.raylib_h.SetShaderValueTexture(
            shader.memorySegment, locIndex, texture.memorySegment
        );
            
            
    }
    
    
    /**
     * Unload shader from GPU memory (VRAM)
     */
    public static void unloadShader(
            Shader shader 
        ){
            
            com.raylib.jextract.raylib_h.UnloadShader(
            shader.memorySegment
        );
            
            
    }
    
    
    /**
     * Get a ray trace from screen position (i.e mouse)
     */
    public static Ray getScreenToWorldRay(
            Vector2 position,  
            Camera3D camera 
        ){
            
             return new Ray(com.raylib.jextract.raylib_h.GetScreenToWorldRay(Arena.ofAuto(), 
            position.memorySegment, camera.memorySegment
        ));
            
            
    }
    
    /**
     * Get a ray trace from screen position (i.e mouse)
     */
    public static Ray getScreenToWorldRay(Arena arena,  
            Vector2 position,  
            Camera3D camera 
        ){
            
             return new Ray(com.raylib.jextract.raylib_h.GetScreenToWorldRay(arena, 
            position.memorySegment, camera.memorySegment
        ));
            
            
    }
    
    
    /**
     * Get a ray trace from screen position (i.e mouse) in a viewport
     */
    public static Ray getScreenToWorldRayEx(
            Vector2 position,  
            Camera3D camera,  
            int width,  
            int height 
        ){
            
             return new Ray(com.raylib.jextract.raylib_h.GetScreenToWorldRayEx(Arena.ofAuto(), 
            position.memorySegment, camera.memorySegment, width, height
        ));
            
            
    }
    
    /**
     * Get a ray trace from screen position (i.e mouse) in a viewport
     */
    public static Ray getScreenToWorldRayEx(Arena arena,  
            Vector2 position,  
            Camera3D camera,  
            int width,  
            int height 
        ){
            
             return new Ray(com.raylib.jextract.raylib_h.GetScreenToWorldRayEx(arena, 
            position.memorySegment, camera.memorySegment, width, height
        ));
            
            
    }
    
    
    /**
     * Get the screen space position for a 3d world space position
     */
    public static Vector2 getWorldToScreen(
            Vector3 position,  
            Camera3D camera 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetWorldToScreen(Arena.ofAuto(), 
            position.memorySegment, camera.memorySegment
        ));
            
            
    }
    
    /**
     * Get the screen space position for a 3d world space position
     */
    public static Vector2 getWorldToScreen(Arena arena,  
            Vector3 position,  
            Camera3D camera 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetWorldToScreen(arena, 
            position.memorySegment, camera.memorySegment
        ));
            
            
    }
    
    
    /**
     * Get size position for a 3d world space position
     */
    public static Vector2 getWorldToScreenEx(
            Vector3 position,  
            Camera3D camera,  
            int width,  
            int height 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetWorldToScreenEx(Arena.ofAuto(), 
            position.memorySegment, camera.memorySegment, width, height
        ));
            
            
    }
    
    /**
     * Get size position for a 3d world space position
     */
    public static Vector2 getWorldToScreenEx(Arena arena,  
            Vector3 position,  
            Camera3D camera,  
            int width,  
            int height 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetWorldToScreenEx(arena, 
            position.memorySegment, camera.memorySegment, width, height
        ));
            
            
    }
    
    
    /**
     * Get the screen space position for a 2d camera world space position
     */
    public static Vector2 getWorldToScreen2D(
            Vector2 position,  
            Camera2D camera 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetWorldToScreen2D(Arena.ofAuto(), 
            position.memorySegment, camera.memorySegment
        ));
            
            
    }
    
    /**
     * Get the screen space position for a 2d camera world space position
     */
    public static Vector2 getWorldToScreen2D(Arena arena,  
            Vector2 position,  
            Camera2D camera 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetWorldToScreen2D(arena, 
            position.memorySegment, camera.memorySegment
        ));
            
            
    }
    
    
    /**
     * Get the world space position for a 2d camera screen space position
     */
    public static Vector2 getScreenToWorld2D(
            Vector2 position,  
            Camera2D camera 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetScreenToWorld2D(Arena.ofAuto(), 
            position.memorySegment, camera.memorySegment
        ));
            
            
    }
    
    /**
     * Get the world space position for a 2d camera screen space position
     */
    public static Vector2 getScreenToWorld2D(Arena arena,  
            Vector2 position,  
            Camera2D camera 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetScreenToWorld2D(arena, 
            position.memorySegment, camera.memorySegment
        ));
            
            
    }
    
    
    /**
     * Get camera transform matrix (view matrix)
     */
    public static Matrix getCameraMatrix(
            Camera3D camera 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.GetCameraMatrix(Arena.ofAuto(), 
            camera.memorySegment
        ));
            
            
    }
    
    /**
     * Get camera transform matrix (view matrix)
     */
    public static Matrix getCameraMatrix(Arena arena,  
            Camera3D camera 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.GetCameraMatrix(arena, 
            camera.memorySegment
        ));
            
            
    }
    
    
    /**
     * Get camera 2d transform matrix
     */
    public static Matrix getCameraMatrix2D(
            Camera2D camera 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.GetCameraMatrix2D(Arena.ofAuto(), 
            camera.memorySegment
        ));
            
            
    }
    
    /**
     * Get camera 2d transform matrix
     */
    public static Matrix getCameraMatrix2D(Arena arena,  
            Camera2D camera 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.GetCameraMatrix2D(arena, 
            camera.memorySegment
        ));
            
            
    }
    
    
    /**
     * Set target FPS (maximum)
     */
    public static void setTargetFPS(
            int fps 
        ){
            
            com.raylib.jextract.raylib_h.SetTargetFPS(
            fps
        );
            
            
    }
    
    
    /**
     * Get time in seconds for last frame drawn (delta time)
     */
    public static float getFrameTime(
        ){
            
            return com.raylib.jextract.raylib_h.GetFrameTime(
            
        );
            
    }
    
    
    /**
     * Get elapsed time in seconds since InitWindow()
     */
    public static double getTime(
        ){
            
            return com.raylib.jextract.raylib_h.GetTime(
            
        );
            
    }
    
    
    /**
     * Get current FPS
     */
    public static int getFPS(
        ){
            
            return com.raylib.jextract.raylib_h.GetFPS(
            
        );
            
    }
    
    
    /**
     * Swap back buffer with front buffer (screen drawing)
     */
    public static void swapScreenBuffer(
        ){
            
            com.raylib.jextract.raylib_h.SwapScreenBuffer(
            
        );
            
            
    }
    
    
    /**
     * Register all input events
     */
    public static void pollInputEvents(
        ){
            
            com.raylib.jextract.raylib_h.PollInputEvents(
            
        );
            
            
    }
    
    
    /**
     * Wait for some time (halt program execution)
     */
    public static void waitTime(
            double seconds 
        ){
            
            com.raylib.jextract.raylib_h.WaitTime(
            seconds
        );
            
            
    }
    
    
    /**
     * Set the seed for the random number generator
     */
    public static void setRandomSeed(
            int seed 
        ){
            
            com.raylib.jextract.raylib_h.SetRandomSeed(
            seed
        );
            
            
    }
    
    
    /**
     * Get a random value between min and max (both included)
     */
    public static int getRandomValue(
            int min,  
            int max 
        ){
            
            return com.raylib.jextract.raylib_h.GetRandomValue(
            min, max
        );
            
    }
    
    
    /**
     * Load random values sequence, no values repeated
     */
    public static java.nio.IntBuffer loadRandomSequence(
            int count,  
            int min,  
            int max 
        ){
            
            return com.raylib.jextract.raylib_h.LoadRandomSequence(
            count, min, max
        ).reinterpret(Integer.MAX_VALUE/2).asByteBuffer().order(ByteOrder.nativeOrder()).asIntBuffer();
            
    }
    
    
    /**
     * Unload random values sequence
     */
    public static void unloadRandomSequence(
            java.nio.IntBuffer sequence 
        ){
            
            com.raylib.jextract.raylib_h.UnloadRandomSequence(
            sequence == null ? MemorySegment.NULL : MemorySegment.ofBuffer(sequence)
        );
            
            
    }
    
    
    /**
     * Takes a screenshot of current screen (filename extension defines format)
     */
    public static void takeScreenshot(
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            com.raylib.jextract.raylib_h.TakeScreenshot(
            localArena.allocateFrom(fileName)
        );
            
            }
    }
    
    
    /**
     * Setup init configuration flags (view FLAGS)
     */
    public static void setConfigFlags(
            int flags 
        ){
            
            com.raylib.jextract.raylib_h.SetConfigFlags(
            flags
        );
            
            
    }
    
    
    /**
     * Open URL with default system browser (if available)
     */
    public static void openURL(
            String url 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            com.raylib.jextract.raylib_h.OpenURL(
            localArena.allocateFrom(url)
        );
            
            }
    }
    
    
    /**
     * Set the current threshold (minimum) log level
     */
    public static void setTraceLogLevel(
            int logLevel 
        ){
            
            com.raylib.jextract.raylib_h.SetTraceLogLevel(
            logLevel
        );
            
            
    }
    
    
    /**
     * Internal memory allocator
     */
    public static MemorySegment memAlloc(
            int size 
        ){
            
            return com.raylib.jextract.raylib_h.MemAlloc(
            size
        );
            
    }
    
    
    /**
     * Internal memory reallocator
     */
    public static MemorySegment memRealloc(
            MemorySegment ptr,  
            int size 
        ){
            
            return com.raylib.jextract.raylib_h.MemRealloc(
            ptr, size
        );
            
    }
    
    
    /**
     * Internal memory free
     */
    public static void memFree(
            MemorySegment ptr 
        ){
            
            com.raylib.jextract.raylib_h.MemFree(
            ptr
        );
            
            
    }
    
    
    /**
     * Set custom trace log
     */
    public static void setTraceLogCallback(
            MemorySegment callback 
        ){
            
            com.raylib.jextract.raylib_h.SetTraceLogCallback(
            callback
        );
            
            
    }
    
    
    /**
     * Set custom file binary data loader
     */
    public static void setLoadFileDataCallback(
            MemorySegment callback 
        ){
            
            com.raylib.jextract.raylib_h.SetLoadFileDataCallback(
            callback
        );
            
            
    }
    
    
    /**
     * Set custom file binary data saver
     */
    public static void setSaveFileDataCallback(
            MemorySegment callback 
        ){
            
            com.raylib.jextract.raylib_h.SetSaveFileDataCallback(
            callback
        );
            
            
    }
    
    
    /**
     * Set custom file text data loader
     */
    public static void setLoadFileTextCallback(
            MemorySegment callback 
        ){
            
            com.raylib.jextract.raylib_h.SetLoadFileTextCallback(
            callback
        );
            
            
    }
    
    
    /**
     * Set custom file text data saver
     */
    public static void setSaveFileTextCallback(
            MemorySegment callback 
        ){
            
            com.raylib.jextract.raylib_h.SetSaveFileTextCallback(
            callback
        );
            
            
    }
    
    
    /**
     * Load file data as byte array (read)
     */
    public static java.nio.ByteBuffer loadFileData(
            String fileName,  
            java.nio.IntBuffer dataSize 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.LoadFileData(
            localArena.allocateFrom(fileName), dataSize == null ? MemorySegment.NULL : MemorySegment.ofBuffer(dataSize)
        ).reinterpret(Integer.MAX_VALUE/2).asByteBuffer().order(ByteOrder.nativeOrder());
            }
    }
    
    
    /**
     * Unload file data allocated by LoadFileData()
     */
    public static void unloadFileData(
            java.nio.ByteBuffer data 
        ){
            
            com.raylib.jextract.raylib_h.UnloadFileData(
            MemorySegment.ofBuffer(data)
        );
            
            
    }
    
    
    /**
     * Save data to file from byte array (write), returns true on success
     */
    public static boolean saveFileData(
            String fileName,  
            MemorySegment data,  
            int dataSize 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.SaveFileData(
            localArena.allocateFrom(fileName), data, dataSize
        );
            }
    }
    
    
    /**
     * Export data to code (.h), returns true on success
     */
    public static boolean exportDataAsCode(
            java.nio.ByteBuffer data,  
            int dataSize,  
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.ExportDataAsCode(
            MemorySegment.ofBuffer(data), dataSize, localArena.allocateFrom(fileName)
        );
            }
    }
    
    
    /**
     * Load text data from file (read), returns a '\0' terminated string
     */
    public static java.nio.ByteBuffer loadFileText(
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.LoadFileText(
            localArena.allocateFrom(fileName)
        ).reinterpret(Integer.MAX_VALUE/2).asByteBuffer().order(ByteOrder.nativeOrder());
            }
    }
    
    
    /**
     * Unload file text data allocated by LoadFileText()
     */
    public static void unloadFileText(
            java.nio.ByteBuffer text 
        ){
            
            com.raylib.jextract.raylib_h.UnloadFileText(
            MemorySegment.ofBuffer(text)
        );
            
            
    }
    
    
    /**
     * Save text data to file (write), string must be '\0' terminated, returns true on success
     */
    public static boolean saveFileText(
            String fileName,  
            java.nio.ByteBuffer text 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.SaveFileText(
            localArena.allocateFrom(fileName), MemorySegment.ofBuffer(text)
        );
            }
    }
    
    
    /**
     * Check if file exists
     */
    public static boolean fileExists(
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.FileExists(
            localArena.allocateFrom(fileName)
        );
            }
    }
    
    
    /**
     * Check if a directory path exists
     */
    public static boolean directoryExists(
            String dirPath 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.DirectoryExists(
            localArena.allocateFrom(dirPath)
        );
            }
    }
    
    
    /**
     * Check file extension (including point: .png, .wav)
     */
    public static boolean isFileExtension(
            String fileName,  
            String ext 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.IsFileExtension(
            localArena.allocateFrom(fileName), localArena.allocateFrom(ext)
        );
            }
    }
    
    
    /**
     * Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)
     */
    public static int getFileLength(
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.GetFileLength(
            localArena.allocateFrom(fileName)
        );
            }
    }
    
    
    /**
     * Get pointer to extension for a filename string (includes dot: '.png')
     */
    public static String getFileExtension(
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.GetFileExtension(
            localArena.allocateFrom(fileName)
        ).getString(0);
            }
    }
    
    
    /**
     * Get pointer to filename for a path string
     */
    public static String getFileName(
            String filePath 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.GetFileName(
            localArena.allocateFrom(filePath)
        ).getString(0);
            }
    }
    
    
    /**
     * Get filename string without extension (uses static string)
     */
    public static String getFileNameWithoutExt(
            String filePath 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.GetFileNameWithoutExt(
            localArena.allocateFrom(filePath)
        ).getString(0);
            }
    }
    
    
    /**
     * Get full path for a given fileName with path (uses static string)
     */
    public static String getDirectoryPath(
            String filePath 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.GetDirectoryPath(
            localArena.allocateFrom(filePath)
        ).getString(0);
            }
    }
    
    
    /**
     * Get previous directory path for a given path (uses static string)
     */
    public static String getPrevDirectoryPath(
            String dirPath 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.GetPrevDirectoryPath(
            localArena.allocateFrom(dirPath)
        ).getString(0);
            }
    }
    
    
    /**
     * Get current working directory (uses static string)
     */
    public static String getWorkingDirectory(
        ){
            
            return com.raylib.jextract.raylib_h.GetWorkingDirectory(
            
        ).getString(0);
            
    }
    
    
    /**
     * Get the directory of the running application (uses static string)
     */
    public static String getApplicationDirectory(
        ){
            
            return com.raylib.jextract.raylib_h.GetApplicationDirectory(
            
        ).getString(0);
            
    }
    
    
    /**
     * Create directories (including full path requested), returns 0 on success
     */
    public static int makeDirectory(
            String dirPath 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.MakeDirectory(
            localArena.allocateFrom(dirPath)
        );
            }
    }
    
    
    /**
     * Change working directory, return true on success
     */
    public static boolean changeDirectory(
            String dir 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.ChangeDirectory(
            localArena.allocateFrom(dir)
        );
            }
    }
    
    
    /**
     * Check if a given path is a file or a directory
     */
    public static boolean isPathFile(
            String path 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.IsPathFile(
            localArena.allocateFrom(path)
        );
            }
    }
    
    
    /**
     * Check if fileName is valid for the platform/OS
     */
    public static boolean isFileNameValid(
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.IsFileNameValid(
            localArena.allocateFrom(fileName)
        );
            }
    }
    
    
    /**
     * Load directory filepaths
     */
    public static FilePathList loadDirectoryFiles(
            String dirPath 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new FilePathList(com.raylib.jextract.raylib_h.LoadDirectoryFiles(Arena.ofAuto(), 
            localArena.allocateFrom(dirPath)
        ));
            
            }
    }
    
    /**
     * Load directory filepaths
     */
    public static FilePathList loadDirectoryFiles(Arena arena,  
            String dirPath 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new FilePathList(com.raylib.jextract.raylib_h.LoadDirectoryFiles(arena, 
            localArena.allocateFrom(dirPath)
        ));
            
            }
    }
    
    
    /**
     * Load directory filepaths with extension filtering and recursive directory scan. Use 'DIR' in the filter string to include directories in the result
     */
    public static FilePathList loadDirectoryFilesEx(
            String basePath,  
            String filter,  
            boolean scanSubdirs 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new FilePathList(com.raylib.jextract.raylib_h.LoadDirectoryFilesEx(Arena.ofAuto(), 
            localArena.allocateFrom(basePath), localArena.allocateFrom(filter), scanSubdirs
        ));
            
            }
    }
    
    /**
     * Load directory filepaths with extension filtering and recursive directory scan. Use 'DIR' in the filter string to include directories in the result
     */
    public static FilePathList loadDirectoryFilesEx(Arena arena,  
            String basePath,  
            String filter,  
            boolean scanSubdirs 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new FilePathList(com.raylib.jextract.raylib_h.LoadDirectoryFilesEx(arena, 
            localArena.allocateFrom(basePath), localArena.allocateFrom(filter), scanSubdirs
        ));
            
            }
    }
    
    
    /**
     * Unload filepaths
     */
    public static void unloadDirectoryFiles(
            FilePathList files 
        ){
            
            com.raylib.jextract.raylib_h.UnloadDirectoryFiles(
            files.memorySegment
        );
            
            
    }
    
    
    /**
     * Check if a file has been dropped into window
     */
    public static boolean isFileDropped(
        ){
            
            return com.raylib.jextract.raylib_h.IsFileDropped(
            
        );
            
    }
    
    
    /**
     * Load dropped filepaths
     */
    public static FilePathList loadDroppedFiles(
        ){
            
             return new FilePathList(com.raylib.jextract.raylib_h.LoadDroppedFiles(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * Load dropped filepaths
     */
    public static FilePathList loadDroppedFiles(Arena arena 
        ){
            
             return new FilePathList(com.raylib.jextract.raylib_h.LoadDroppedFiles(arena
            
        ));
            
            
    }
    
    
    /**
     * Unload dropped filepaths
     */
    public static void unloadDroppedFiles(
            FilePathList files 
        ){
            
            com.raylib.jextract.raylib_h.UnloadDroppedFiles(
            files.memorySegment
        );
            
            
    }
    
    
    /**
     * Get file modification time (last write time)
     */
    public static long getFileModTime(
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.GetFileModTime(
            localArena.allocateFrom(fileName)
        );
            }
    }
    
    
    /**
     * Compress data (DEFLATE algorithm), memory must be MemFree()
     */
    public static java.nio.ByteBuffer compressData(
            java.nio.ByteBuffer data,  
            int dataSize,  
            java.nio.IntBuffer compDataSize 
        ){
            
            return com.raylib.jextract.raylib_h.CompressData(
            MemorySegment.ofBuffer(data), dataSize, compDataSize == null ? MemorySegment.NULL : MemorySegment.ofBuffer(compDataSize)
        ).reinterpret(Integer.MAX_VALUE/2).asByteBuffer().order(ByteOrder.nativeOrder());
            
    }
    
    
    /**
     * Decompress data (DEFLATE algorithm), memory must be MemFree()
     */
    public static java.nio.ByteBuffer decompressData(
            java.nio.ByteBuffer compData,  
            int compDataSize,  
            java.nio.IntBuffer dataSize 
        ){
            
            return com.raylib.jextract.raylib_h.DecompressData(
            MemorySegment.ofBuffer(compData), compDataSize, dataSize == null ? MemorySegment.NULL : MemorySegment.ofBuffer(dataSize)
        ).reinterpret(Integer.MAX_VALUE/2).asByteBuffer().order(ByteOrder.nativeOrder());
            
    }
    
    
    /**
     * Encode data to Base64 string, memory must be MemFree()
     */
    public static java.nio.ByteBuffer encodeDataBase64(
            java.nio.ByteBuffer data,  
            int dataSize,  
            java.nio.IntBuffer outputSize 
        ){
            
            return com.raylib.jextract.raylib_h.EncodeDataBase64(
            MemorySegment.ofBuffer(data), dataSize, outputSize == null ? MemorySegment.NULL : MemorySegment.ofBuffer(outputSize)
        ).reinterpret(Integer.MAX_VALUE/2).asByteBuffer().order(ByteOrder.nativeOrder());
            
    }
    
    
    /**
     * Decode Base64 string data, memory must be MemFree()
     */
    public static java.nio.ByteBuffer decodeDataBase64(
            java.nio.ByteBuffer data,  
            java.nio.IntBuffer outputSize 
        ){
            
            return com.raylib.jextract.raylib_h.DecodeDataBase64(
            MemorySegment.ofBuffer(data), outputSize == null ? MemorySegment.NULL : MemorySegment.ofBuffer(outputSize)
        ).reinterpret(Integer.MAX_VALUE/2).asByteBuffer().order(ByteOrder.nativeOrder());
            
    }
    
    
    /**
     * Compute CRC32 hash code
     */
    public static int computeCRC32(
            java.nio.ByteBuffer data,  
            int dataSize 
        ){
            
            return com.raylib.jextract.raylib_h.ComputeCRC32(
            MemorySegment.ofBuffer(data), dataSize
        );
            
    }
    
    
    /**
     * Compute MD5 hash code, returns static int[4] (16 bytes)
     */
    public static MemorySegment computeMD5(
            java.nio.ByteBuffer data,  
            int dataSize 
        ){
            
            return com.raylib.jextract.raylib_h.ComputeMD5(
            MemorySegment.ofBuffer(data), dataSize
        );
            
    }
    
    
    /**
     * Compute SHA1 hash code, returns static int[5] (20 bytes)
     */
    public static MemorySegment computeSHA1(
            java.nio.ByteBuffer data,  
            int dataSize 
        ){
            
            return com.raylib.jextract.raylib_h.ComputeSHA1(
            MemorySegment.ofBuffer(data), dataSize
        );
            
    }
    
    
    /**
     * Load automation events list from file, NULL for empty list, capacity = MAX_AUTOMATION_EVENTS
     */
    public static AutomationEventList loadAutomationEventList(
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new AutomationEventList(com.raylib.jextract.raylib_h.LoadAutomationEventList(Arena.ofAuto(), 
            localArena.allocateFrom(fileName)
        ));
            
            }
    }
    
    /**
     * Load automation events list from file, NULL for empty list, capacity = MAX_AUTOMATION_EVENTS
     */
    public static AutomationEventList loadAutomationEventList(Arena arena,  
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new AutomationEventList(com.raylib.jextract.raylib_h.LoadAutomationEventList(arena, 
            localArena.allocateFrom(fileName)
        ));
            
            }
    }
    
    
    /**
     * Unload automation events list from file
     */
    public static void unloadAutomationEventList(
            AutomationEventList list 
        ){
            
            com.raylib.jextract.raylib_h.UnloadAutomationEventList(
            list.memorySegment
        );
            
            
    }
    
    
    /**
     * Export automation events list as text file
     */
    public static boolean exportAutomationEventList(
            AutomationEventList list,  
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.ExportAutomationEventList(
            list.memorySegment, localArena.allocateFrom(fileName)
        );
            }
    }
    
    
    /**
     * Set automation event list to record to
     */
    public static void setAutomationEventList(
            AutomationEventList list 
        ){
            
            com.raylib.jextract.raylib_h.SetAutomationEventList(
            list.memorySegment
        );
            
            
    }
    
    
    /**
     * Set automation event internal base frame to start recording
     */
    public static void setAutomationEventBaseFrame(
            int frame 
        ){
            
            com.raylib.jextract.raylib_h.SetAutomationEventBaseFrame(
            frame
        );
            
            
    }
    
    
    /**
     * Start recording automation events (AutomationEventList must be set)
     */
    public static void startAutomationEventRecording(
        ){
            
            com.raylib.jextract.raylib_h.StartAutomationEventRecording(
            
        );
            
            
    }
    
    
    /**
     * Stop recording automation events
     */
    public static void stopAutomationEventRecording(
        ){
            
            com.raylib.jextract.raylib_h.StopAutomationEventRecording(
            
        );
            
            
    }
    
    
    /**
     * Play a recorded automation event
     */
    public static void playAutomationEvent(
            AutomationEvent event 
        ){
            
            com.raylib.jextract.raylib_h.PlayAutomationEvent(
            event.memorySegment
        );
            
            
    }
    
    
    /**
     * Check if a key has been pressed once
     */
    public static boolean isKeyPressed(
            int key 
        ){
            
            return com.raylib.jextract.raylib_h.IsKeyPressed(
            key
        );
            
    }
    
    
    /**
     * Check if a key has been pressed again
     */
    public static boolean isKeyPressedRepeat(
            int key 
        ){
            
            return com.raylib.jextract.raylib_h.IsKeyPressedRepeat(
            key
        );
            
    }
    
    
    /**
     * Check if a key is being pressed
     */
    public static boolean isKeyDown(
            int key 
        ){
            
            return com.raylib.jextract.raylib_h.IsKeyDown(
            key
        );
            
    }
    
    
    /**
     * Check if a key has been released once
     */
    public static boolean isKeyReleased(
            int key 
        ){
            
            return com.raylib.jextract.raylib_h.IsKeyReleased(
            key
        );
            
    }
    
    
    /**
     * Check if a key is NOT being pressed
     */
    public static boolean isKeyUp(
            int key 
        ){
            
            return com.raylib.jextract.raylib_h.IsKeyUp(
            key
        );
            
    }
    
    
    /**
     * Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty
     */
    public static int getKeyPressed(
        ){
            
            return com.raylib.jextract.raylib_h.GetKeyPressed(
            
        );
            
    }
    
    
    /**
     * Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty
     */
    public static int getCharPressed(
        ){
            
            return com.raylib.jextract.raylib_h.GetCharPressed(
            
        );
            
    }
    
    
    /**
     * Set a custom key to exit program (default is ESC)
     */
    public static void setExitKey(
            int key 
        ){
            
            com.raylib.jextract.raylib_h.SetExitKey(
            key
        );
            
            
    }
    
    
    /**
     * Check if a gamepad is available
     */
    public static boolean isGamepadAvailable(
            int gamepad 
        ){
            
            return com.raylib.jextract.raylib_h.IsGamepadAvailable(
            gamepad
        );
            
    }
    
    
    /**
     * Get gamepad internal name id
     */
    public static String getGamepadName(
            int gamepad 
        ){
            
            return com.raylib.jextract.raylib_h.GetGamepadName(
            gamepad
        ).getString(0);
            
    }
    
    
    /**
     * Check if a gamepad button has been pressed once
     */
    public static boolean isGamepadButtonPressed(
            int gamepad,  
            int button 
        ){
            
            return com.raylib.jextract.raylib_h.IsGamepadButtonPressed(
            gamepad, button
        );
            
    }
    
    
    /**
     * Check if a gamepad button is being pressed
     */
    public static boolean isGamepadButtonDown(
            int gamepad,  
            int button 
        ){
            
            return com.raylib.jextract.raylib_h.IsGamepadButtonDown(
            gamepad, button
        );
            
    }
    
    
    /**
     * Check if a gamepad button has been released once
     */
    public static boolean isGamepadButtonReleased(
            int gamepad,  
            int button 
        ){
            
            return com.raylib.jextract.raylib_h.IsGamepadButtonReleased(
            gamepad, button
        );
            
    }
    
    
    /**
     * Check if a gamepad button is NOT being pressed
     */
    public static boolean isGamepadButtonUp(
            int gamepad,  
            int button 
        ){
            
            return com.raylib.jextract.raylib_h.IsGamepadButtonUp(
            gamepad, button
        );
            
    }
    
    
    /**
     * Get the last gamepad button pressed
     */
    public static int getGamepadButtonPressed(
        ){
            
            return com.raylib.jextract.raylib_h.GetGamepadButtonPressed(
            
        );
            
    }
    
    
    /**
     * Get gamepad axis count for a gamepad
     */
    public static int getGamepadAxisCount(
            int gamepad 
        ){
            
            return com.raylib.jextract.raylib_h.GetGamepadAxisCount(
            gamepad
        );
            
    }
    
    
    /**
     * Get axis movement value for a gamepad axis
     */
    public static float getGamepadAxisMovement(
            int gamepad,  
            int axis 
        ){
            
            return com.raylib.jextract.raylib_h.GetGamepadAxisMovement(
            gamepad, axis
        );
            
    }
    
    
    /**
     * Set internal gamepad mappings (SDL_GameControllerDB)
     */
    public static int setGamepadMappings(
            String mappings 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.SetGamepadMappings(
            localArena.allocateFrom(mappings)
        );
            }
    }
    
    
    /**
     * Set gamepad vibration for both motors (duration in seconds)
     */
    public static void setGamepadVibration(
            int gamepad,  
            float leftMotor,  
            float rightMotor,  
            float duration 
        ){
            
            com.raylib.jextract.raylib_h.SetGamepadVibration(
            gamepad, leftMotor, rightMotor, duration
        );
            
            
    }
    
    
    /**
     * Check if a mouse button has been pressed once
     */
    public static boolean isMouseButtonPressed(
            int button 
        ){
            
            return com.raylib.jextract.raylib_h.IsMouseButtonPressed(
            button
        );
            
    }
    
    
    /**
     * Check if a mouse button is being pressed
     */
    public static boolean isMouseButtonDown(
            int button 
        ){
            
            return com.raylib.jextract.raylib_h.IsMouseButtonDown(
            button
        );
            
    }
    
    
    /**
     * Check if a mouse button has been released once
     */
    public static boolean isMouseButtonReleased(
            int button 
        ){
            
            return com.raylib.jextract.raylib_h.IsMouseButtonReleased(
            button
        );
            
    }
    
    
    /**
     * Check if a mouse button is NOT being pressed
     */
    public static boolean isMouseButtonUp(
            int button 
        ){
            
            return com.raylib.jextract.raylib_h.IsMouseButtonUp(
            button
        );
            
    }
    
    
    /**
     * Get mouse position X
     */
    public static int getMouseX(
        ){
            
            return com.raylib.jextract.raylib_h.GetMouseX(
            
        );
            
    }
    
    
    /**
     * Get mouse position Y
     */
    public static int getMouseY(
        ){
            
            return com.raylib.jextract.raylib_h.GetMouseY(
            
        );
            
    }
    
    
    /**
     * Get mouse position XY
     */
    public static Vector2 getMousePosition(
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetMousePosition(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * Get mouse position XY
     */
    public static Vector2 getMousePosition(Arena arena 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetMousePosition(arena
            
        ));
            
            
    }
    
    
    /**
     * Get mouse delta between frames
     */
    public static Vector2 getMouseDelta(
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetMouseDelta(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * Get mouse delta between frames
     */
    public static Vector2 getMouseDelta(Arena arena 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetMouseDelta(arena
            
        ));
            
            
    }
    
    
    /**
     * Set mouse position XY
     */
    public static void setMousePosition(
            int x,  
            int y 
        ){
            
            com.raylib.jextract.raylib_h.SetMousePosition(
            x, y
        );
            
            
    }
    
    
    /**
     * Set mouse offset
     */
    public static void setMouseOffset(
            int offsetX,  
            int offsetY 
        ){
            
            com.raylib.jextract.raylib_h.SetMouseOffset(
            offsetX, offsetY
        );
            
            
    }
    
    
    /**
     * Set mouse scaling
     */
    public static void setMouseScale(
            float scaleX,  
            float scaleY 
        ){
            
            com.raylib.jextract.raylib_h.SetMouseScale(
            scaleX, scaleY
        );
            
            
    }
    
    
    /**
     * Get mouse wheel movement for X or Y, whichever is larger
     */
    public static float getMouseWheelMove(
        ){
            
            return com.raylib.jextract.raylib_h.GetMouseWheelMove(
            
        );
            
    }
    
    
    /**
     * Get mouse wheel movement for both X and Y
     */
    public static Vector2 getMouseWheelMoveV(
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetMouseWheelMoveV(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * Get mouse wheel movement for both X and Y
     */
    public static Vector2 getMouseWheelMoveV(Arena arena 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetMouseWheelMoveV(arena
            
        ));
            
            
    }
    
    
    /**
     * Set mouse cursor
     */
    public static void setMouseCursor(
            int cursor 
        ){
            
            com.raylib.jextract.raylib_h.SetMouseCursor(
            cursor
        );
            
            
    }
    
    
    /**
     * Get touch position X for touch point 0 (relative to screen size)
     */
    public static int getTouchX(
        ){
            
            return com.raylib.jextract.raylib_h.GetTouchX(
            
        );
            
    }
    
    
    /**
     * Get touch position Y for touch point 0 (relative to screen size)
     */
    public static int getTouchY(
        ){
            
            return com.raylib.jextract.raylib_h.GetTouchY(
            
        );
            
    }
    
    
    /**
     * Get touch position XY for a touch point index (relative to screen size)
     */
    public static Vector2 getTouchPosition(
            int index 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetTouchPosition(Arena.ofAuto(), 
            index
        ));
            
            
    }
    
    /**
     * Get touch position XY for a touch point index (relative to screen size)
     */
    public static Vector2 getTouchPosition(Arena arena,  
            int index 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetTouchPosition(arena, 
            index
        ));
            
            
    }
    
    
    /**
     * Get touch point identifier for given index
     */
    public static int getTouchPointId(
            int index 
        ){
            
            return com.raylib.jextract.raylib_h.GetTouchPointId(
            index
        );
            
    }
    
    
    /**
     * Get number of touch points
     */
    public static int getTouchPointCount(
        ){
            
            return com.raylib.jextract.raylib_h.GetTouchPointCount(
            
        );
            
    }
    
    
    /**
     * Enable a set of gestures using flags
     */
    public static void setGesturesEnabled(
            int flags 
        ){
            
            com.raylib.jextract.raylib_h.SetGesturesEnabled(
            flags
        );
            
            
    }
    
    
    /**
     * Check if a gesture have been detected
     */
    public static boolean isGestureDetected(
            int gesture 
        ){
            
            return com.raylib.jextract.raylib_h.IsGestureDetected(
            gesture
        );
            
    }
    
    
    /**
     * Get latest detected gesture
     */
    public static int getGestureDetected(
        ){
            
            return com.raylib.jextract.raylib_h.GetGestureDetected(
            
        );
            
    }
    
    
    /**
     * Get gesture hold time in seconds
     */
    public static float getGestureHoldDuration(
        ){
            
            return com.raylib.jextract.raylib_h.GetGestureHoldDuration(
            
        );
            
    }
    
    
    /**
     * Get gesture drag vector
     */
    public static Vector2 getGestureDragVector(
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetGestureDragVector(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * Get gesture drag vector
     */
    public static Vector2 getGestureDragVector(Arena arena 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetGestureDragVector(arena
            
        ));
            
            
    }
    
    
    /**
     * Get gesture drag angle
     */
    public static float getGestureDragAngle(
        ){
            
            return com.raylib.jextract.raylib_h.GetGestureDragAngle(
            
        );
            
    }
    
    
    /**
     * Get gesture pinch delta
     */
    public static Vector2 getGesturePinchVector(
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetGesturePinchVector(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * Get gesture pinch delta
     */
    public static Vector2 getGesturePinchVector(Arena arena 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetGesturePinchVector(arena
            
        ));
            
            
    }
    
    
    /**
     * Get gesture pinch angle
     */
    public static float getGesturePinchAngle(
        ){
            
            return com.raylib.jextract.raylib_h.GetGesturePinchAngle(
            
        );
            
    }
    
    
    /**
     * Update camera position for selected mode
     */
    public static void updateCamera(
            Camera3D camera,  
            int mode 
        ){
            
            com.raylib.jextract.raylib_h.UpdateCamera(
            camera.memorySegment, mode
        );
            
            
    }
    
    
    /**
     * Update camera movement/rotation
     */
    public static void updateCameraPro(
            Camera3D camera,  
            Vector3 movement,  
            Vector3 rotation,  
            float zoom 
        ){
            
            com.raylib.jextract.raylib_h.UpdateCameraPro(
            camera.memorySegment, movement.memorySegment, rotation.memorySegment, zoom
        );
            
            
    }
    
    
    /**
     * Set texture and rectangle to be used on shapes drawing
     */
    public static void setShapesTexture(
            Texture texture,  
            Rectangle source 
        ){
            
            com.raylib.jextract.raylib_h.SetShapesTexture(
            texture.memorySegment, source.memorySegment
        );
            
            
    }
    
    
    /**
     * Get texture that is used for shapes drawing
     */
    public static Texture getShapesTexture(
        ){
            
             return new Texture(com.raylib.jextract.raylib_h.GetShapesTexture(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * Get texture that is used for shapes drawing
     */
    public static Texture getShapesTexture(Arena arena 
        ){
            
             return new Texture(com.raylib.jextract.raylib_h.GetShapesTexture(arena
            
        ));
            
            
    }
    
    
    /**
     * Get texture source rectangle that is used for shapes drawing
     */
    public static Rectangle getShapesTextureRectangle(
        ){
            
             return new Rectangle(com.raylib.jextract.raylib_h.GetShapesTextureRectangle(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * Get texture source rectangle that is used for shapes drawing
     */
    public static Rectangle getShapesTextureRectangle(Arena arena 
        ){
            
             return new Rectangle(com.raylib.jextract.raylib_h.GetShapesTextureRectangle(arena
            
        ));
            
            
    }
    
    
    /**
     * Draw a pixel using geometry [Can be slow, use with care]
     */
    public static void drawPixel(
            int posX,  
            int posY,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawPixel(
            posX, posY, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a pixel using geometry (Vector version) [Can be slow, use with care]
     */
    public static void drawPixelV(
            Vector2 position,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawPixelV(
            position.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a line
     */
    public static void drawLine(
            int startPosX,  
            int startPosY,  
            int endPosX,  
            int endPosY,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawLine(
            startPosX, startPosY, endPosX, endPosY, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a line (using gl lines)
     */
    public static void drawLineV(
            Vector2 startPos,  
            Vector2 endPos,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawLineV(
            startPos.memorySegment, endPos.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a line (using triangles/quads)
     */
    public static void drawLineEx(
            Vector2 startPos,  
            Vector2 endPos,  
            float thick,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawLineEx(
            startPos.memorySegment, endPos.memorySegment, thick, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw lines sequence (using gl lines)
     */
    public static void drawLineStrip(
            MemorySegment points,  
            int pointCount,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawLineStrip(
            points, pointCount, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw line segment cubic-bezier in-out interpolation
     */
    public static void drawLineBezier(
            Vector2 startPos,  
            Vector2 endPos,  
            float thick,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawLineBezier(
            startPos.memorySegment, endPos.memorySegment, thick, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a color-filled circle
     */
    public static void drawCircle(
            int centerX,  
            int centerY,  
            float radius,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawCircle(
            centerX, centerY, radius, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a piece of a circle
     */
    public static void drawCircleSector(
            Vector2 center,  
            float radius,  
            float startAngle,  
            float endAngle,  
            int segments,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawCircleSector(
            center.memorySegment, radius, startAngle, endAngle, segments, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw circle sector outline
     */
    public static void drawCircleSectorLines(
            Vector2 center,  
            float radius,  
            float startAngle,  
            float endAngle,  
            int segments,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawCircleSectorLines(
            center.memorySegment, radius, startAngle, endAngle, segments, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a gradient-filled circle
     */
    public static void drawCircleGradient(
            int centerX,  
            int centerY,  
            float radius,  
            Color inner,  
            Color outer 
        ){
            
            com.raylib.jextract.raylib_h.DrawCircleGradient(
            centerX, centerY, radius, inner.memorySegment, outer.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a color-filled circle (Vector version)
     */
    public static void drawCircleV(
            Vector2 center,  
            float radius,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawCircleV(
            center.memorySegment, radius, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw circle outline
     */
    public static void drawCircleLines(
            int centerX,  
            int centerY,  
            float radius,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawCircleLines(
            centerX, centerY, radius, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw circle outline (Vector version)
     */
    public static void drawCircleLinesV(
            Vector2 center,  
            float radius,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawCircleLinesV(
            center.memorySegment, radius, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw ellipse
     */
    public static void drawEllipse(
            int centerX,  
            int centerY,  
            float radiusH,  
            float radiusV,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawEllipse(
            centerX, centerY, radiusH, radiusV, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw ellipse outline
     */
    public static void drawEllipseLines(
            int centerX,  
            int centerY,  
            float radiusH,  
            float radiusV,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawEllipseLines(
            centerX, centerY, radiusH, radiusV, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw ring
     */
    public static void drawRing(
            Vector2 center,  
            float innerRadius,  
            float outerRadius,  
            float startAngle,  
            float endAngle,  
            int segments,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawRing(
            center.memorySegment, innerRadius, outerRadius, startAngle, endAngle, segments, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw ring outline
     */
    public static void drawRingLines(
            Vector2 center,  
            float innerRadius,  
            float outerRadius,  
            float startAngle,  
            float endAngle,  
            int segments,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawRingLines(
            center.memorySegment, innerRadius, outerRadius, startAngle, endAngle, segments, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a color-filled rectangle
     */
    public static void drawRectangle(
            int posX,  
            int posY,  
            int width,  
            int height,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawRectangle(
            posX, posY, width, height, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a color-filled rectangle (Vector version)
     */
    public static void drawRectangleV(
            Vector2 position,  
            Vector2 size,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawRectangleV(
            position.memorySegment, size.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a color-filled rectangle
     */
    public static void drawRectangleRec(
            Rectangle rec,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawRectangleRec(
            rec.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a color-filled rectangle with pro parameters
     */
    public static void drawRectanglePro(
            Rectangle rec,  
            Vector2 origin,  
            float rotation,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawRectanglePro(
            rec.memorySegment, origin.memorySegment, rotation, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a vertical-gradient-filled rectangle
     */
    public static void drawRectangleGradientV(
            int posX,  
            int posY,  
            int width,  
            int height,  
            Color top,  
            Color bottom 
        ){
            
            com.raylib.jextract.raylib_h.DrawRectangleGradientV(
            posX, posY, width, height, top.memorySegment, bottom.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a horizontal-gradient-filled rectangle
     */
    public static void drawRectangleGradientH(
            int posX,  
            int posY,  
            int width,  
            int height,  
            Color left,  
            Color right 
        ){
            
            com.raylib.jextract.raylib_h.DrawRectangleGradientH(
            posX, posY, width, height, left.memorySegment, right.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a gradient-filled rectangle with custom vertex colors
     */
    public static void drawRectangleGradientEx(
            Rectangle rec,  
            Color topLeft,  
            Color bottomLeft,  
            Color topRight,  
            Color bottomRight 
        ){
            
            com.raylib.jextract.raylib_h.DrawRectangleGradientEx(
            rec.memorySegment, topLeft.memorySegment, bottomLeft.memorySegment, topRight.memorySegment, bottomRight.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw rectangle outline
     */
    public static void drawRectangleLines(
            int posX,  
            int posY,  
            int width,  
            int height,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawRectangleLines(
            posX, posY, width, height, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw rectangle outline with extended parameters
     */
    public static void drawRectangleLinesEx(
            Rectangle rec,  
            float lineThick,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawRectangleLinesEx(
            rec.memorySegment, lineThick, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw rectangle with rounded edges
     */
    public static void drawRectangleRounded(
            Rectangle rec,  
            float roundness,  
            int segments,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawRectangleRounded(
            rec.memorySegment, roundness, segments, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw rectangle lines with rounded edges
     */
    public static void drawRectangleRoundedLines(
            Rectangle rec,  
            float roundness,  
            int segments,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawRectangleRoundedLines(
            rec.memorySegment, roundness, segments, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw rectangle with rounded edges outline
     */
    public static void drawRectangleRoundedLinesEx(
            Rectangle rec,  
            float roundness,  
            int segments,  
            float lineThick,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawRectangleRoundedLinesEx(
            rec.memorySegment, roundness, segments, lineThick, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a color-filled triangle (vertex in counter-clockwise order!)
     */
    public static void drawTriangle(
            Vector2 v1,  
            Vector2 v2,  
            Vector2 v3,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawTriangle(
            v1.memorySegment, v2.memorySegment, v3.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw triangle outline (vertex in counter-clockwise order!)
     */
    public static void drawTriangleLines(
            Vector2 v1,  
            Vector2 v2,  
            Vector2 v3,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawTriangleLines(
            v1.memorySegment, v2.memorySegment, v3.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a triangle fan defined by points (first vertex is the center)
     */
    public static void drawTriangleFan(
            MemorySegment points,  
            int pointCount,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawTriangleFan(
            points, pointCount, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a triangle strip defined by points
     */
    public static void drawTriangleStrip(
            MemorySegment points,  
            int pointCount,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawTriangleStrip(
            points, pointCount, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a regular polygon (Vector version)
     */
    public static void drawPoly(
            Vector2 center,  
            int sides,  
            float radius,  
            float rotation,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawPoly(
            center.memorySegment, sides, radius, rotation, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a polygon outline of n sides
     */
    public static void drawPolyLines(
            Vector2 center,  
            int sides,  
            float radius,  
            float rotation,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawPolyLines(
            center.memorySegment, sides, radius, rotation, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a polygon outline of n sides with extended parameters
     */
    public static void drawPolyLinesEx(
            Vector2 center,  
            int sides,  
            float radius,  
            float rotation,  
            float lineThick,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawPolyLinesEx(
            center.memorySegment, sides, radius, rotation, lineThick, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw spline: Linear, minimum 2 points
     */
    public static void drawSplineLinear(
            MemorySegment points,  
            int pointCount,  
            float thick,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawSplineLinear(
            points, pointCount, thick, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw spline: B-Spline, minimum 4 points
     */
    public static void drawSplineBasis(
            MemorySegment points,  
            int pointCount,  
            float thick,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawSplineBasis(
            points, pointCount, thick, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw spline: Catmull-Rom, minimum 4 points
     */
    public static void drawSplineCatmullRom(
            MemorySegment points,  
            int pointCount,  
            float thick,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawSplineCatmullRom(
            points, pointCount, thick, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw spline: Quadratic Bezier, minimum 3 points (1 control point): [p1, c2, p3, c4...]
     */
    public static void drawSplineBezierQuadratic(
            MemorySegment points,  
            int pointCount,  
            float thick,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawSplineBezierQuadratic(
            points, pointCount, thick, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw spline: Cubic Bezier, minimum 4 points (2 control points): [p1, c2, c3, p4, c5, c6...]
     */
    public static void drawSplineBezierCubic(
            MemorySegment points,  
            int pointCount,  
            float thick,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawSplineBezierCubic(
            points, pointCount, thick, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw spline segment: Linear, 2 points
     */
    public static void drawSplineSegmentLinear(
            Vector2 p1,  
            Vector2 p2,  
            float thick,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawSplineSegmentLinear(
            p1.memorySegment, p2.memorySegment, thick, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw spline segment: B-Spline, 4 points
     */
    public static void drawSplineSegmentBasis(
            Vector2 p1,  
            Vector2 p2,  
            Vector2 p3,  
            Vector2 p4,  
            float thick,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawSplineSegmentBasis(
            p1.memorySegment, p2.memorySegment, p3.memorySegment, p4.memorySegment, thick, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw spline segment: Catmull-Rom, 4 points
     */
    public static void drawSplineSegmentCatmullRom(
            Vector2 p1,  
            Vector2 p2,  
            Vector2 p3,  
            Vector2 p4,  
            float thick,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawSplineSegmentCatmullRom(
            p1.memorySegment, p2.memorySegment, p3.memorySegment, p4.memorySegment, thick, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw spline segment: Quadratic Bezier, 2 points, 1 control point
     */
    public static void drawSplineSegmentBezierQuadratic(
            Vector2 p1,  
            Vector2 c2,  
            Vector2 p3,  
            float thick,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawSplineSegmentBezierQuadratic(
            p1.memorySegment, c2.memorySegment, p3.memorySegment, thick, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw spline segment: Cubic Bezier, 2 points, 2 control points
     */
    public static void drawSplineSegmentBezierCubic(
            Vector2 p1,  
            Vector2 c2,  
            Vector2 c3,  
            Vector2 p4,  
            float thick,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawSplineSegmentBezierCubic(
            p1.memorySegment, c2.memorySegment, c3.memorySegment, p4.memorySegment, thick, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Get (evaluate) spline point: Linear
     */
    public static Vector2 getSplinePointLinear(
            Vector2 startPos,  
            Vector2 endPos,  
            float t 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetSplinePointLinear(Arena.ofAuto(), 
            startPos.memorySegment, endPos.memorySegment, t
        ));
            
            
    }
    
    /**
     * Get (evaluate) spline point: Linear
     */
    public static Vector2 getSplinePointLinear(Arena arena,  
            Vector2 startPos,  
            Vector2 endPos,  
            float t 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetSplinePointLinear(arena, 
            startPos.memorySegment, endPos.memorySegment, t
        ));
            
            
    }
    
    
    /**
     * Get (evaluate) spline point: B-Spline
     */
    public static Vector2 getSplinePointBasis(
            Vector2 p1,  
            Vector2 p2,  
            Vector2 p3,  
            Vector2 p4,  
            float t 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetSplinePointBasis(Arena.ofAuto(), 
            p1.memorySegment, p2.memorySegment, p3.memorySegment, p4.memorySegment, t
        ));
            
            
    }
    
    /**
     * Get (evaluate) spline point: B-Spline
     */
    public static Vector2 getSplinePointBasis(Arena arena,  
            Vector2 p1,  
            Vector2 p2,  
            Vector2 p3,  
            Vector2 p4,  
            float t 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetSplinePointBasis(arena, 
            p1.memorySegment, p2.memorySegment, p3.memorySegment, p4.memorySegment, t
        ));
            
            
    }
    
    
    /**
     * Get (evaluate) spline point: Catmull-Rom
     */
    public static Vector2 getSplinePointCatmullRom(
            Vector2 p1,  
            Vector2 p2,  
            Vector2 p3,  
            Vector2 p4,  
            float t 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetSplinePointCatmullRom(Arena.ofAuto(), 
            p1.memorySegment, p2.memorySegment, p3.memorySegment, p4.memorySegment, t
        ));
            
            
    }
    
    /**
     * Get (evaluate) spline point: Catmull-Rom
     */
    public static Vector2 getSplinePointCatmullRom(Arena arena,  
            Vector2 p1,  
            Vector2 p2,  
            Vector2 p3,  
            Vector2 p4,  
            float t 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetSplinePointCatmullRom(arena, 
            p1.memorySegment, p2.memorySegment, p3.memorySegment, p4.memorySegment, t
        ));
            
            
    }
    
    
    /**
     * Get (evaluate) spline point: Quadratic Bezier
     */
    public static Vector2 getSplinePointBezierQuad(
            Vector2 p1,  
            Vector2 c2,  
            Vector2 p3,  
            float t 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetSplinePointBezierQuad(Arena.ofAuto(), 
            p1.memorySegment, c2.memorySegment, p3.memorySegment, t
        ));
            
            
    }
    
    /**
     * Get (evaluate) spline point: Quadratic Bezier
     */
    public static Vector2 getSplinePointBezierQuad(Arena arena,  
            Vector2 p1,  
            Vector2 c2,  
            Vector2 p3,  
            float t 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetSplinePointBezierQuad(arena, 
            p1.memorySegment, c2.memorySegment, p3.memorySegment, t
        ));
            
            
    }
    
    
    /**
     * Get (evaluate) spline point: Cubic Bezier
     */
    public static Vector2 getSplinePointBezierCubic(
            Vector2 p1,  
            Vector2 c2,  
            Vector2 c3,  
            Vector2 p4,  
            float t 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetSplinePointBezierCubic(Arena.ofAuto(), 
            p1.memorySegment, c2.memorySegment, c3.memorySegment, p4.memorySegment, t
        ));
            
            
    }
    
    /**
     * Get (evaluate) spline point: Cubic Bezier
     */
    public static Vector2 getSplinePointBezierCubic(Arena arena,  
            Vector2 p1,  
            Vector2 c2,  
            Vector2 c3,  
            Vector2 p4,  
            float t 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.GetSplinePointBezierCubic(arena, 
            p1.memorySegment, c2.memorySegment, c3.memorySegment, p4.memorySegment, t
        ));
            
            
    }
    
    
    /**
     * Check collision between two rectangles
     */
    public static boolean checkCollisionRecs(
            Rectangle rec1,  
            Rectangle rec2 
        ){
            
            return com.raylib.jextract.raylib_h.CheckCollisionRecs(
            rec1.memorySegment, rec2.memorySegment
        );
            
    }
    
    
    /**
     * Check collision between two circles
     */
    public static boolean checkCollisionCircles(
            Vector2 center1,  
            float radius1,  
            Vector2 center2,  
            float radius2 
        ){
            
            return com.raylib.jextract.raylib_h.CheckCollisionCircles(
            center1.memorySegment, radius1, center2.memorySegment, radius2
        );
            
    }
    
    
    /**
     * Check collision between circle and rectangle
     */
    public static boolean checkCollisionCircleRec(
            Vector2 center,  
            float radius,  
            Rectangle rec 
        ){
            
            return com.raylib.jextract.raylib_h.CheckCollisionCircleRec(
            center.memorySegment, radius, rec.memorySegment
        );
            
    }
    
    
    /**
     * Check if circle collides with a line created betweeen two points [p1] and [p2]
     */
    public static boolean checkCollisionCircleLine(
            Vector2 center,  
            float radius,  
            Vector2 p1,  
            Vector2 p2 
        ){
            
            return com.raylib.jextract.raylib_h.CheckCollisionCircleLine(
            center.memorySegment, radius, p1.memorySegment, p2.memorySegment
        );
            
    }
    
    
    /**
     * Check if point is inside rectangle
     */
    public static boolean checkCollisionPointRec(
            Vector2 point,  
            Rectangle rec 
        ){
            
            return com.raylib.jextract.raylib_h.CheckCollisionPointRec(
            point.memorySegment, rec.memorySegment
        );
            
    }
    
    
    /**
     * Check if point is inside circle
     */
    public static boolean checkCollisionPointCircle(
            Vector2 point,  
            Vector2 center,  
            float radius 
        ){
            
            return com.raylib.jextract.raylib_h.CheckCollisionPointCircle(
            point.memorySegment, center.memorySegment, radius
        );
            
    }
    
    
    /**
     * Check if point is inside a triangle
     */
    public static boolean checkCollisionPointTriangle(
            Vector2 point,  
            Vector2 p1,  
            Vector2 p2,  
            Vector2 p3 
        ){
            
            return com.raylib.jextract.raylib_h.CheckCollisionPointTriangle(
            point.memorySegment, p1.memorySegment, p2.memorySegment, p3.memorySegment
        );
            
    }
    
    
    /**
     * Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]
     */
    public static boolean checkCollisionPointLine(
            Vector2 point,  
            Vector2 p1,  
            Vector2 p2,  
            int threshold 
        ){
            
            return com.raylib.jextract.raylib_h.CheckCollisionPointLine(
            point.memorySegment, p1.memorySegment, p2.memorySegment, threshold
        );
            
    }
    
    
    /**
     * Check if point is within a polygon described by array of vertices
     */
    public static boolean checkCollisionPointPoly(
            Vector2 point,  
            MemorySegment points,  
            int pointCount 
        ){
            
            return com.raylib.jextract.raylib_h.CheckCollisionPointPoly(
            point.memorySegment, points, pointCount
        );
            
    }
    
    
    /**
     * Check the collision between two lines defined by two points each, returns collision point by reference
     */
    public static boolean checkCollisionLines(
            Vector2 startPos1,  
            Vector2 endPos1,  
            Vector2 startPos2,  
            Vector2 endPos2,  
            Vector2 collisionPoint 
        ){
            
            return com.raylib.jextract.raylib_h.CheckCollisionLines(
            startPos1.memorySegment, endPos1.memorySegment, startPos2.memorySegment, endPos2.memorySegment, collisionPoint.memorySegment
        );
            
    }
    
    
    /**
     * Get collision rectangle for two rectangles collision
     */
    public static Rectangle getCollisionRec(
            Rectangle rec1,  
            Rectangle rec2 
        ){
            
             return new Rectangle(com.raylib.jextract.raylib_h.GetCollisionRec(Arena.ofAuto(), 
            rec1.memorySegment, rec2.memorySegment
        ));
            
            
    }
    
    /**
     * Get collision rectangle for two rectangles collision
     */
    public static Rectangle getCollisionRec(Arena arena,  
            Rectangle rec1,  
            Rectangle rec2 
        ){
            
             return new Rectangle(com.raylib.jextract.raylib_h.GetCollisionRec(arena, 
            rec1.memorySegment, rec2.memorySegment
        ));
            
            
    }
    
    
    /**
     * Load image from file into CPU memory (RAM)
     */
    public static Image loadImage(
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Image(com.raylib.jextract.raylib_h.LoadImage(Arena.ofAuto(), 
            localArena.allocateFrom(fileName)
        ));
            
            }
    }
    
    /**
     * Load image from file into CPU memory (RAM)
     */
    public static Image loadImage(Arena arena,  
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Image(com.raylib.jextract.raylib_h.LoadImage(arena, 
            localArena.allocateFrom(fileName)
        ));
            
            }
    }
    
    
    /**
     * Load image from RAW file data
     */
    public static Image loadImageRaw(
            String fileName,  
            int width,  
            int height,  
            int format,  
            int headerSize 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Image(com.raylib.jextract.raylib_h.LoadImageRaw(Arena.ofAuto(), 
            localArena.allocateFrom(fileName), width, height, format, headerSize
        ));
            
            }
    }
    
    /**
     * Load image from RAW file data
     */
    public static Image loadImageRaw(Arena arena,  
            String fileName,  
            int width,  
            int height,  
            int format,  
            int headerSize 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Image(com.raylib.jextract.raylib_h.LoadImageRaw(arena, 
            localArena.allocateFrom(fileName), width, height, format, headerSize
        ));
            
            }
    }
    
    
    /**
     * Load image sequence from file (frames appended to image.data)
     */
    public static Image loadImageAnim(
            String fileName,  
            java.nio.IntBuffer frames 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Image(com.raylib.jextract.raylib_h.LoadImageAnim(Arena.ofAuto(), 
            localArena.allocateFrom(fileName), frames == null ? MemorySegment.NULL : MemorySegment.ofBuffer(frames)
        ));
            
            }
    }
    
    /**
     * Load image sequence from file (frames appended to image.data)
     */
    public static Image loadImageAnim(Arena arena,  
            String fileName,  
            java.nio.IntBuffer frames 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Image(com.raylib.jextract.raylib_h.LoadImageAnim(arena, 
            localArena.allocateFrom(fileName), frames == null ? MemorySegment.NULL : MemorySegment.ofBuffer(frames)
        ));
            
            }
    }
    
    
    /**
     * Load image sequence from memory buffer
     */
    public static Image loadImageAnimFromMemory(
            String fileType,  
            java.nio.ByteBuffer fileData,  
            int dataSize,  
            java.nio.IntBuffer frames 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Image(com.raylib.jextract.raylib_h.LoadImageAnimFromMemory(Arena.ofAuto(), 
            localArena.allocateFrom(fileType), MemorySegment.ofBuffer(fileData), dataSize, frames == null ? MemorySegment.NULL : MemorySegment.ofBuffer(frames)
        ));
            
            }
    }
    
    /**
     * Load image sequence from memory buffer
     */
    public static Image loadImageAnimFromMemory(Arena arena,  
            String fileType,  
            java.nio.ByteBuffer fileData,  
            int dataSize,  
            java.nio.IntBuffer frames 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Image(com.raylib.jextract.raylib_h.LoadImageAnimFromMemory(arena, 
            localArena.allocateFrom(fileType), MemorySegment.ofBuffer(fileData), dataSize, frames == null ? MemorySegment.NULL : MemorySegment.ofBuffer(frames)
        ));
            
            }
    }
    
    
    /**
     * Load image from memory buffer, fileType refers to extension: i.e. '.png'
     */
    public static Image loadImageFromMemory(
            String fileType,  
            java.nio.ByteBuffer fileData,  
            int dataSize 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Image(com.raylib.jextract.raylib_h.LoadImageFromMemory(Arena.ofAuto(), 
            localArena.allocateFrom(fileType), MemorySegment.ofBuffer(fileData), dataSize
        ));
            
            }
    }
    
    /**
     * Load image from memory buffer, fileType refers to extension: i.e. '.png'
     */
    public static Image loadImageFromMemory(Arena arena,  
            String fileType,  
            java.nio.ByteBuffer fileData,  
            int dataSize 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Image(com.raylib.jextract.raylib_h.LoadImageFromMemory(arena, 
            localArena.allocateFrom(fileType), MemorySegment.ofBuffer(fileData), dataSize
        ));
            
            }
    }
    
    
    /**
     * Load image from GPU texture data
     */
    public static Image loadImageFromTexture(
            Texture texture 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.LoadImageFromTexture(Arena.ofAuto(), 
            texture.memorySegment
        ));
            
            
    }
    
    /**
     * Load image from GPU texture data
     */
    public static Image loadImageFromTexture(Arena arena,  
            Texture texture 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.LoadImageFromTexture(arena, 
            texture.memorySegment
        ));
            
            
    }
    
    
    /**
     * Load image from screen buffer and (screenshot)
     */
    public static Image loadImageFromScreen(
        ){
            
             return new Image(com.raylib.jextract.raylib_h.LoadImageFromScreen(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * Load image from screen buffer and (screenshot)
     */
    public static Image loadImageFromScreen(Arena arena 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.LoadImageFromScreen(arena
            
        ));
            
            
    }
    
    
    /**
     * Check if an image is valid (data and parameters)
     */
    public static boolean isImageValid(
            Image image 
        ){
            
            return com.raylib.jextract.raylib_h.IsImageValid(
            image.memorySegment
        );
            
    }
    
    
    /**
     * Unload image from CPU memory (RAM)
     */
    public static void unloadImage(
            Image image 
        ){
            
            com.raylib.jextract.raylib_h.UnloadImage(
            image.memorySegment
        );
            
            
    }
    
    
    /**
     * Export image data to file, returns true on success
     */
    public static boolean exportImage(
            Image image,  
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.ExportImage(
            image.memorySegment, localArena.allocateFrom(fileName)
        );
            }
    }
    
    
    /**
     * Export image to memory buffer
     */
    public static java.nio.ByteBuffer exportImageToMemory(
            Image image,  
            String fileType,  
            java.nio.IntBuffer fileSize 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.ExportImageToMemory(
            image.memorySegment, localArena.allocateFrom(fileType), fileSize == null ? MemorySegment.NULL : MemorySegment.ofBuffer(fileSize)
        ).reinterpret(Integer.MAX_VALUE/2).asByteBuffer().order(ByteOrder.nativeOrder());
            }
    }
    
    
    /**
     * Export image as code file defining an array of bytes, returns true on success
     */
    public static boolean exportImageAsCode(
            Image image,  
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.ExportImageAsCode(
            image.memorySegment, localArena.allocateFrom(fileName)
        );
            }
    }
    
    
    /**
     * Generate image: plain color
     */
    public static Image genImageColor(
            int width,  
            int height,  
            Color color 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImageColor(Arena.ofAuto(), 
            width, height, color.memorySegment
        ));
            
            
    }
    
    /**
     * Generate image: plain color
     */
    public static Image genImageColor(Arena arena,  
            int width,  
            int height,  
            Color color 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImageColor(arena, 
            width, height, color.memorySegment
        ));
            
            
    }
    
    
    /**
     * Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient
     */
    public static Image genImageGradientLinear(
            int width,  
            int height,  
            int direction,  
            Color start,  
            Color end 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImageGradientLinear(Arena.ofAuto(), 
            width, height, direction, start.memorySegment, end.memorySegment
        ));
            
            
    }
    
    /**
     * Generate image: linear gradient, direction in degrees [0..360], 0=Vertical gradient
     */
    public static Image genImageGradientLinear(Arena arena,  
            int width,  
            int height,  
            int direction,  
            Color start,  
            Color end 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImageGradientLinear(arena, 
            width, height, direction, start.memorySegment, end.memorySegment
        ));
            
            
    }
    
    
    /**
     * Generate image: radial gradient
     */
    public static Image genImageGradientRadial(
            int width,  
            int height,  
            float density,  
            Color inner,  
            Color outer 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImageGradientRadial(Arena.ofAuto(), 
            width, height, density, inner.memorySegment, outer.memorySegment
        ));
            
            
    }
    
    /**
     * Generate image: radial gradient
     */
    public static Image genImageGradientRadial(Arena arena,  
            int width,  
            int height,  
            float density,  
            Color inner,  
            Color outer 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImageGradientRadial(arena, 
            width, height, density, inner.memorySegment, outer.memorySegment
        ));
            
            
    }
    
    
    /**
     * Generate image: square gradient
     */
    public static Image genImageGradientSquare(
            int width,  
            int height,  
            float density,  
            Color inner,  
            Color outer 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImageGradientSquare(Arena.ofAuto(), 
            width, height, density, inner.memorySegment, outer.memorySegment
        ));
            
            
    }
    
    /**
     * Generate image: square gradient
     */
    public static Image genImageGradientSquare(Arena arena,  
            int width,  
            int height,  
            float density,  
            Color inner,  
            Color outer 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImageGradientSquare(arena, 
            width, height, density, inner.memorySegment, outer.memorySegment
        ));
            
            
    }
    
    
    /**
     * Generate image: checked
     */
    public static Image genImageChecked(
            int width,  
            int height,  
            int checksX,  
            int checksY,  
            Color col1,  
            Color col2 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImageChecked(Arena.ofAuto(), 
            width, height, checksX, checksY, col1.memorySegment, col2.memorySegment
        ));
            
            
    }
    
    /**
     * Generate image: checked
     */
    public static Image genImageChecked(Arena arena,  
            int width,  
            int height,  
            int checksX,  
            int checksY,  
            Color col1,  
            Color col2 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImageChecked(arena, 
            width, height, checksX, checksY, col1.memorySegment, col2.memorySegment
        ));
            
            
    }
    
    
    /**
     * Generate image: white noise
     */
    public static Image genImageWhiteNoise(
            int width,  
            int height,  
            float factor 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImageWhiteNoise(Arena.ofAuto(), 
            width, height, factor
        ));
            
            
    }
    
    /**
     * Generate image: white noise
     */
    public static Image genImageWhiteNoise(Arena arena,  
            int width,  
            int height,  
            float factor 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImageWhiteNoise(arena, 
            width, height, factor
        ));
            
            
    }
    
    
    /**
     * Generate image: perlin noise
     */
    public static Image genImagePerlinNoise(
            int width,  
            int height,  
            int offsetX,  
            int offsetY,  
            float scale 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImagePerlinNoise(Arena.ofAuto(), 
            width, height, offsetX, offsetY, scale
        ));
            
            
    }
    
    /**
     * Generate image: perlin noise
     */
    public static Image genImagePerlinNoise(Arena arena,  
            int width,  
            int height,  
            int offsetX,  
            int offsetY,  
            float scale 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImagePerlinNoise(arena, 
            width, height, offsetX, offsetY, scale
        ));
            
            
    }
    
    
    /**
     * Generate image: cellular algorithm, bigger tileSize means bigger cells
     */
    public static Image genImageCellular(
            int width,  
            int height,  
            int tileSize 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImageCellular(Arena.ofAuto(), 
            width, height, tileSize
        ));
            
            
    }
    
    /**
     * Generate image: cellular algorithm, bigger tileSize means bigger cells
     */
    public static Image genImageCellular(Arena arena,  
            int width,  
            int height,  
            int tileSize 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImageCellular(arena, 
            width, height, tileSize
        ));
            
            
    }
    
    
    /**
     * Generate image: grayscale image from text data
     */
    public static Image genImageText(
            int width,  
            int height,  
            String text 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Image(com.raylib.jextract.raylib_h.GenImageText(Arena.ofAuto(), 
            width, height, localArena.allocateFrom(text)
        ));
            
            }
    }
    
    /**
     * Generate image: grayscale image from text data
     */
    public static Image genImageText(Arena arena,  
            int width,  
            int height,  
            String text 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Image(com.raylib.jextract.raylib_h.GenImageText(arena, 
            width, height, localArena.allocateFrom(text)
        ));
            
            }
    }
    
    
    /**
     * Create an image duplicate (useful for transformations)
     */
    public static Image imageCopy(
            Image image 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.ImageCopy(Arena.ofAuto(), 
            image.memorySegment
        ));
            
            
    }
    
    /**
     * Create an image duplicate (useful for transformations)
     */
    public static Image imageCopy(Arena arena,  
            Image image 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.ImageCopy(arena, 
            image.memorySegment
        ));
            
            
    }
    
    
    /**
     * Create an image from another image piece
     */
    public static Image imageFromImage(
            Image image,  
            Rectangle rec 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.ImageFromImage(Arena.ofAuto(), 
            image.memorySegment, rec.memorySegment
        ));
            
            
    }
    
    /**
     * Create an image from another image piece
     */
    public static Image imageFromImage(Arena arena,  
            Image image,  
            Rectangle rec 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.ImageFromImage(arena, 
            image.memorySegment, rec.memorySegment
        ));
            
            
    }
    
    
    /**
     * Create an image from a selected channel of another image (GRAYSCALE)
     */
    public static Image imageFromChannel(
            Image image,  
            int selectedChannel 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.ImageFromChannel(Arena.ofAuto(), 
            image.memorySegment, selectedChannel
        ));
            
            
    }
    
    /**
     * Create an image from a selected channel of another image (GRAYSCALE)
     */
    public static Image imageFromChannel(Arena arena,  
            Image image,  
            int selectedChannel 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.ImageFromChannel(arena, 
            image.memorySegment, selectedChannel
        ));
            
            
    }
    
    
    /**
     * Create an image from text (default font)
     */
    public static Image imageText(
            String text,  
            int fontSize,  
            Color color 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Image(com.raylib.jextract.raylib_h.ImageText(Arena.ofAuto(), 
            localArena.allocateFrom(text), fontSize, color.memorySegment
        ));
            
            }
    }
    
    /**
     * Create an image from text (default font)
     */
    public static Image imageText(Arena arena,  
            String text,  
            int fontSize,  
            Color color 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Image(com.raylib.jextract.raylib_h.ImageText(arena, 
            localArena.allocateFrom(text), fontSize, color.memorySegment
        ));
            
            }
    }
    
    
    /**
     * Create an image from text (custom sprite font)
     */
    public static Image imageTextEx(
            Font font,  
            String text,  
            float fontSize,  
            float spacing,  
            Color tint 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Image(com.raylib.jextract.raylib_h.ImageTextEx(Arena.ofAuto(), 
            font.memorySegment, localArena.allocateFrom(text), fontSize, spacing, tint.memorySegment
        ));
            
            }
    }
    
    /**
     * Create an image from text (custom sprite font)
     */
    public static Image imageTextEx(Arena arena,  
            Font font,  
            String text,  
            float fontSize,  
            float spacing,  
            Color tint 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Image(com.raylib.jextract.raylib_h.ImageTextEx(arena, 
            font.memorySegment, localArena.allocateFrom(text), fontSize, spacing, tint.memorySegment
        ));
            
            }
    }
    
    
    /**
     * Convert image data to desired format
     */
    public static void imageFormat(
            Image image,  
            int newFormat 
        ){
            
            com.raylib.jextract.raylib_h.ImageFormat(
            image.memorySegment, newFormat
        );
            
            
    }
    
    
    /**
     * Convert image to POT (power-of-two)
     */
    public static void imageToPOT(
            Image image,  
            Color fill 
        ){
            
            com.raylib.jextract.raylib_h.ImageToPOT(
            image.memorySegment, fill.memorySegment
        );
            
            
    }
    
    
    /**
     * Crop an image to a defined rectangle
     */
    public static void imageCrop(
            Image image,  
            Rectangle crop 
        ){
            
            com.raylib.jextract.raylib_h.ImageCrop(
            image.memorySegment, crop.memorySegment
        );
            
            
    }
    
    
    /**
     * Crop image depending on alpha value
     */
    public static void imageAlphaCrop(
            Image image,  
            float threshold 
        ){
            
            com.raylib.jextract.raylib_h.ImageAlphaCrop(
            image.memorySegment, threshold
        );
            
            
    }
    
    
    /**
     * Clear alpha channel to desired color
     */
    public static void imageAlphaClear(
            Image image,  
            Color color,  
            float threshold 
        ){
            
            com.raylib.jextract.raylib_h.ImageAlphaClear(
            image.memorySegment, color.memorySegment, threshold
        );
            
            
    }
    
    
    /**
     * Apply alpha mask to image
     */
    public static void imageAlphaMask(
            Image image,  
            Image alphaMask 
        ){
            
            com.raylib.jextract.raylib_h.ImageAlphaMask(
            image.memorySegment, alphaMask.memorySegment
        );
            
            
    }
    
    
    /**
     * Premultiply alpha channel
     */
    public static void imageAlphaPremultiply(
            Image image 
        ){
            
            com.raylib.jextract.raylib_h.ImageAlphaPremultiply(
            image.memorySegment
        );
            
            
    }
    
    
    /**
     * Apply Gaussian blur using a box blur approximation
     */
    public static void imageBlurGaussian(
            Image image,  
            int blurSize 
        ){
            
            com.raylib.jextract.raylib_h.ImageBlurGaussian(
            image.memorySegment, blurSize
        );
            
            
    }
    
    
    /**
     * Apply custom square convolution kernel to image
     */
    public static void imageKernelConvolution(
            Image image,  
            MemorySegment kernel,  
            int kernelSize 
        ){
            
            com.raylib.jextract.raylib_h.ImageKernelConvolution(
            image.memorySegment, kernel, kernelSize
        );
            
            
    }
    
    
    /**
     * Resize image (Bicubic scaling algorithm)
     */
    public static void imageResize(
            Image image,  
            int newWidth,  
            int newHeight 
        ){
            
            com.raylib.jextract.raylib_h.ImageResize(
            image.memorySegment, newWidth, newHeight
        );
            
            
    }
    
    
    /**
     * Resize image (Nearest-Neighbor scaling algorithm)
     */
    public static void imageResizeNN(
            Image image,  
            int newWidth,  
            int newHeight 
        ){
            
            com.raylib.jextract.raylib_h.ImageResizeNN(
            image.memorySegment, newWidth, newHeight
        );
            
            
    }
    
    
    /**
     * Resize canvas and fill with color
     */
    public static void imageResizeCanvas(
            Image image,  
            int newWidth,  
            int newHeight,  
            int offsetX,  
            int offsetY,  
            Color fill 
        ){
            
            com.raylib.jextract.raylib_h.ImageResizeCanvas(
            image.memorySegment, newWidth, newHeight, offsetX, offsetY, fill.memorySegment
        );
            
            
    }
    
    
    /**
     * Compute all mipmap levels for a provided image
     */
    public static void imageMipmaps(
            Image image 
        ){
            
            com.raylib.jextract.raylib_h.ImageMipmaps(
            image.memorySegment
        );
            
            
    }
    
    
    /**
     * Dither image data to 16bpp or lower (Floyd-Steinberg dithering)
     */
    public static void imageDither(
            Image image,  
            int rBpp,  
            int gBpp,  
            int bBpp,  
            int aBpp 
        ){
            
            com.raylib.jextract.raylib_h.ImageDither(
            image.memorySegment, rBpp, gBpp, bBpp, aBpp
        );
            
            
    }
    
    
    /**
     * Flip image vertically
     */
    public static void imageFlipVertical(
            Image image 
        ){
            
            com.raylib.jextract.raylib_h.ImageFlipVertical(
            image.memorySegment
        );
            
            
    }
    
    
    /**
     * Flip image horizontally
     */
    public static void imageFlipHorizontal(
            Image image 
        ){
            
            com.raylib.jextract.raylib_h.ImageFlipHorizontal(
            image.memorySegment
        );
            
            
    }
    
    
    /**
     * Rotate image by input angle in degrees (-359 to 359)
     */
    public static void imageRotate(
            Image image,  
            int degrees 
        ){
            
            com.raylib.jextract.raylib_h.ImageRotate(
            image.memorySegment, degrees
        );
            
            
    }
    
    
    /**
     * Rotate image clockwise 90deg
     */
    public static void imageRotateCW(
            Image image 
        ){
            
            com.raylib.jextract.raylib_h.ImageRotateCW(
            image.memorySegment
        );
            
            
    }
    
    
    /**
     * Rotate image counter-clockwise 90deg
     */
    public static void imageRotateCCW(
            Image image 
        ){
            
            com.raylib.jextract.raylib_h.ImageRotateCCW(
            image.memorySegment
        );
            
            
    }
    
    
    /**
     * Modify image color: tint
     */
    public static void imageColorTint(
            Image image,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageColorTint(
            image.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Modify image color: invert
     */
    public static void imageColorInvert(
            Image image 
        ){
            
            com.raylib.jextract.raylib_h.ImageColorInvert(
            image.memorySegment
        );
            
            
    }
    
    
    /**
     * Modify image color: grayscale
     */
    public static void imageColorGrayscale(
            Image image 
        ){
            
            com.raylib.jextract.raylib_h.ImageColorGrayscale(
            image.memorySegment
        );
            
            
    }
    
    
    /**
     * Modify image color: contrast (-100 to 100)
     */
    public static void imageColorContrast(
            Image image,  
            float contrast 
        ){
            
            com.raylib.jextract.raylib_h.ImageColorContrast(
            image.memorySegment, contrast
        );
            
            
    }
    
    
    /**
     * Modify image color: brightness (-255 to 255)
     */
    public static void imageColorBrightness(
            Image image,  
            int brightness 
        ){
            
            com.raylib.jextract.raylib_h.ImageColorBrightness(
            image.memorySegment, brightness
        );
            
            
    }
    
    
    /**
     * Modify image color: replace color
     */
    public static void imageColorReplace(
            Image image,  
            Color color,  
            Color replace 
        ){
            
            com.raylib.jextract.raylib_h.ImageColorReplace(
            image.memorySegment, color.memorySegment, replace.memorySegment
        );
            
            
    }
    
    
    /**
     * Load color data from image as a Color array (RGBA - 32bit)
     */
    public static Color loadImageColors(
            Image image 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.LoadImageColors(
            image.memorySegment
        ));
            
            
    }
    
    
    /**
     * Load colors palette from image as a Color array (RGBA - 32bit)
     */
    public static Color loadImagePalette(
            Image image,  
            int maxPaletteSize,  
            java.nio.IntBuffer colorCount 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.LoadImagePalette(
            image.memorySegment, maxPaletteSize, colorCount == null ? MemorySegment.NULL : MemorySegment.ofBuffer(colorCount)
        ));
            
            
    }
    
    
    /**
     * Unload color data loaded with LoadImageColors()
     */
    public static void unloadImageColors(
            Color colors 
        ){
            
            com.raylib.jextract.raylib_h.UnloadImageColors(
            colors.memorySegment
        );
            
            
    }
    
    
    /**
     * Unload colors palette loaded with LoadImagePalette()
     */
    public static void unloadImagePalette(
            Color colors 
        ){
            
            com.raylib.jextract.raylib_h.UnloadImagePalette(
            colors.memorySegment
        );
            
            
    }
    
    
    /**
     * Get image alpha border rectangle
     */
    public static Rectangle getImageAlphaBorder(
            Image image,  
            float threshold 
        ){
            
             return new Rectangle(com.raylib.jextract.raylib_h.GetImageAlphaBorder(Arena.ofAuto(), 
            image.memorySegment, threshold
        ));
            
            
    }
    
    /**
     * Get image alpha border rectangle
     */
    public static Rectangle getImageAlphaBorder(Arena arena,  
            Image image,  
            float threshold 
        ){
            
             return new Rectangle(com.raylib.jextract.raylib_h.GetImageAlphaBorder(arena, 
            image.memorySegment, threshold
        ));
            
            
    }
    
    
    /**
     * Get image pixel color at (x, y) position
     */
    public static Color getImageColor(
            Image image,  
            int x,  
            int y 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.GetImageColor(Arena.ofAuto(), 
            image.memorySegment, x, y
        ));
            
            
    }
    
    /**
     * Get image pixel color at (x, y) position
     */
    public static Color getImageColor(Arena arena,  
            Image image,  
            int x,  
            int y 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.GetImageColor(arena, 
            image.memorySegment, x, y
        ));
            
            
    }
    
    
    /**
     * Clear image background with given color
     */
    public static void imageClearBackground(
            Image dst,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageClearBackground(
            dst.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw pixel within an image
     */
    public static void imageDrawPixel(
            Image dst,  
            int posX,  
            int posY,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawPixel(
            dst.memorySegment, posX, posY, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw pixel within an image (Vector version)
     */
    public static void imageDrawPixelV(
            Image dst,  
            Vector2 position,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawPixelV(
            dst.memorySegment, position.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw line within an image
     */
    public static void imageDrawLine(
            Image dst,  
            int startPosX,  
            int startPosY,  
            int endPosX,  
            int endPosY,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawLine(
            dst.memorySegment, startPosX, startPosY, endPosX, endPosY, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw line within an image (Vector version)
     */
    public static void imageDrawLineV(
            Image dst,  
            Vector2 start,  
            Vector2 end,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawLineV(
            dst.memorySegment, start.memorySegment, end.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a line defining thickness within an image
     */
    public static void imageDrawLineEx(
            Image dst,  
            Vector2 start,  
            Vector2 end,  
            int thick,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawLineEx(
            dst.memorySegment, start.memorySegment, end.memorySegment, thick, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a filled circle within an image
     */
    public static void imageDrawCircle(
            Image dst,  
            int centerX,  
            int centerY,  
            int radius,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawCircle(
            dst.memorySegment, centerX, centerY, radius, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a filled circle within an image (Vector version)
     */
    public static void imageDrawCircleV(
            Image dst,  
            Vector2 center,  
            int radius,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawCircleV(
            dst.memorySegment, center.memorySegment, radius, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw circle outline within an image
     */
    public static void imageDrawCircleLines(
            Image dst,  
            int centerX,  
            int centerY,  
            int radius,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawCircleLines(
            dst.memorySegment, centerX, centerY, radius, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw circle outline within an image (Vector version)
     */
    public static void imageDrawCircleLinesV(
            Image dst,  
            Vector2 center,  
            int radius,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawCircleLinesV(
            dst.memorySegment, center.memorySegment, radius, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw rectangle within an image
     */
    public static void imageDrawRectangle(
            Image dst,  
            int posX,  
            int posY,  
            int width,  
            int height,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawRectangle(
            dst.memorySegment, posX, posY, width, height, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw rectangle within an image (Vector version)
     */
    public static void imageDrawRectangleV(
            Image dst,  
            Vector2 position,  
            Vector2 size,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawRectangleV(
            dst.memorySegment, position.memorySegment, size.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw rectangle within an image
     */
    public static void imageDrawRectangleRec(
            Image dst,  
            Rectangle rec,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawRectangleRec(
            dst.memorySegment, rec.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw rectangle lines within an image
     */
    public static void imageDrawRectangleLines(
            Image dst,  
            Rectangle rec,  
            int thick,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawRectangleLines(
            dst.memorySegment, rec.memorySegment, thick, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw triangle within an image
     */
    public static void imageDrawTriangle(
            Image dst,  
            Vector2 v1,  
            Vector2 v2,  
            Vector2 v3,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawTriangle(
            dst.memorySegment, v1.memorySegment, v2.memorySegment, v3.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw triangle with interpolated colors within an image
     */
    public static void imageDrawTriangleEx(
            Image dst,  
            Vector2 v1,  
            Vector2 v2,  
            Vector2 v3,  
            Color c1,  
            Color c2,  
            Color c3 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawTriangleEx(
            dst.memorySegment, v1.memorySegment, v2.memorySegment, v3.memorySegment, c1.memorySegment, c2.memorySegment, c3.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw triangle outline within an image
     */
    public static void imageDrawTriangleLines(
            Image dst,  
            Vector2 v1,  
            Vector2 v2,  
            Vector2 v3,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawTriangleLines(
            dst.memorySegment, v1.memorySegment, v2.memorySegment, v3.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a triangle fan defined by points within an image (first vertex is the center)
     */
    public static void imageDrawTriangleFan(
            Image dst,  
            Vector2 points,  
            int pointCount,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawTriangleFan(
            dst.memorySegment, points.memorySegment, pointCount, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a triangle strip defined by points within an image
     */
    public static void imageDrawTriangleStrip(
            Image dst,  
            Vector2 points,  
            int pointCount,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.ImageDrawTriangleStrip(
            dst.memorySegment, points.memorySegment, pointCount, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a source image within a destination image (tint applied to source)
     */
    public static void imageDraw(
            Image dst,  
            Image src,  
            Rectangle srcRec,  
            Rectangle dstRec,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.ImageDraw(
            dst.memorySegment, src.memorySegment, srcRec.memorySegment, dstRec.memorySegment, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw text (using default font) within an image (destination)
     */
    public static void imageDrawText(
            Image dst,  
            String text,  
            int posX,  
            int posY,  
            int fontSize,  
            Color color 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            com.raylib.jextract.raylib_h.ImageDrawText(
            dst.memorySegment, localArena.allocateFrom(text), posX, posY, fontSize, color.memorySegment
        );
            
            }
    }
    
    
    /**
     * Draw text (custom sprite font) within an image (destination)
     */
    public static void imageDrawTextEx(
            Image dst,  
            Font font,  
            String text,  
            Vector2 position,  
            float fontSize,  
            float spacing,  
            Color tint 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            com.raylib.jextract.raylib_h.ImageDrawTextEx(
            dst.memorySegment, font.memorySegment, localArena.allocateFrom(text), position.memorySegment, fontSize, spacing, tint.memorySegment
        );
            
            }
    }
    
    
    /**
     * Load texture from file into GPU memory (VRAM)
     */
    public static Texture loadTexture(
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Texture(com.raylib.jextract.raylib_h.LoadTexture(Arena.ofAuto(), 
            localArena.allocateFrom(fileName)
        ));
            
            }
    }
    
    /**
     * Load texture from file into GPU memory (VRAM)
     */
    public static Texture loadTexture(Arena arena,  
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Texture(com.raylib.jextract.raylib_h.LoadTexture(arena, 
            localArena.allocateFrom(fileName)
        ));
            
            }
    }
    
    
    /**
     * Load texture from image data
     */
    public static Texture loadTextureFromImage(
            Image image 
        ){
            
             return new Texture(com.raylib.jextract.raylib_h.LoadTextureFromImage(Arena.ofAuto(), 
            image.memorySegment
        ));
            
            
    }
    
    /**
     * Load texture from image data
     */
    public static Texture loadTextureFromImage(Arena arena,  
            Image image 
        ){
            
             return new Texture(com.raylib.jextract.raylib_h.LoadTextureFromImage(arena, 
            image.memorySegment
        ));
            
            
    }
    
    
    /**
     * Load cubemap from image, multiple image cubemap layouts supported
     */
    public static Texture loadTextureCubemap(
            Image image,  
            int layout 
        ){
            
             return new Texture(com.raylib.jextract.raylib_h.LoadTextureCubemap(Arena.ofAuto(), 
            image.memorySegment, layout
        ));
            
            
    }
    
    /**
     * Load cubemap from image, multiple image cubemap layouts supported
     */
    public static Texture loadTextureCubemap(Arena arena,  
            Image image,  
            int layout 
        ){
            
             return new Texture(com.raylib.jextract.raylib_h.LoadTextureCubemap(arena, 
            image.memorySegment, layout
        ));
            
            
    }
    
    
    /**
     * Load texture for rendering (framebuffer)
     */
    public static RenderTexture loadRenderTexture(
            int width,  
            int height 
        ){
            
             return new RenderTexture(com.raylib.jextract.raylib_h.LoadRenderTexture(Arena.ofAuto(), 
            width, height
        ));
            
            
    }
    
    /**
     * Load texture for rendering (framebuffer)
     */
    public static RenderTexture loadRenderTexture(Arena arena,  
            int width,  
            int height 
        ){
            
             return new RenderTexture(com.raylib.jextract.raylib_h.LoadRenderTexture(arena, 
            width, height
        ));
            
            
    }
    
    
    /**
     * Check if a texture is valid (loaded in GPU)
     */
    public static boolean isTextureValid(
            Texture texture 
        ){
            
            return com.raylib.jextract.raylib_h.IsTextureValid(
            texture.memorySegment
        );
            
    }
    
    
    /**
     * Unload texture from GPU memory (VRAM)
     */
    public static void unloadTexture(
            Texture texture 
        ){
            
            com.raylib.jextract.raylib_h.UnloadTexture(
            texture.memorySegment
        );
            
            
    }
    
    
    /**
     * Check if a render texture is valid (loaded in GPU)
     */
    public static boolean isRenderTextureValid(
            RenderTexture target 
        ){
            
            return com.raylib.jextract.raylib_h.IsRenderTextureValid(
            target.memorySegment
        );
            
    }
    
    
    /**
     * Unload render texture from GPU memory (VRAM)
     */
    public static void unloadRenderTexture(
            RenderTexture target 
        ){
            
            com.raylib.jextract.raylib_h.UnloadRenderTexture(
            target.memorySegment
        );
            
            
    }
    
    
    /**
     * Update GPU texture with new data
     */
    public static void updateTexture(
            Texture texture,  
            MemorySegment pixels 
        ){
            
            com.raylib.jextract.raylib_h.UpdateTexture(
            texture.memorySegment, pixels
        );
            
            
    }
    
    
    /**
     * Update GPU texture rectangle with new data
     */
    public static void updateTextureRec(
            Texture texture,  
            Rectangle rec,  
            MemorySegment pixels 
        ){
            
            com.raylib.jextract.raylib_h.UpdateTextureRec(
            texture.memorySegment, rec.memorySegment, pixels
        );
            
            
    }
    
    
    /**
     * Generate GPU mipmaps for a texture
     */
    public static void genTextureMipmaps(
            Texture texture 
        ){
            
            com.raylib.jextract.raylib_h.GenTextureMipmaps(
            texture.memorySegment
        );
            
            
    }
    
    
    /**
     * Set texture scaling filter mode
     */
    public static void setTextureFilter(
            Texture texture,  
            int filter 
        ){
            
            com.raylib.jextract.raylib_h.SetTextureFilter(
            texture.memorySegment, filter
        );
            
            
    }
    
    
    /**
     * Set texture wrapping mode
     */
    public static void setTextureWrap(
            Texture texture,  
            int wrap 
        ){
            
            com.raylib.jextract.raylib_h.SetTextureWrap(
            texture.memorySegment, wrap
        );
            
            
    }
    
    
    /**
     * Draw a Texture2D
     */
    public static void drawTexture(
            Texture texture,  
            int posX,  
            int posY,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.DrawTexture(
            texture.memorySegment, posX, posY, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a Texture2D with position defined as Vector2
     */
    public static void drawTextureV(
            Texture texture,  
            Vector2 position,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.DrawTextureV(
            texture.memorySegment, position.memorySegment, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a Texture2D with extended parameters
     */
    public static void drawTextureEx(
            Texture texture,  
            Vector2 position,  
            float rotation,  
            float scale,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.DrawTextureEx(
            texture.memorySegment, position.memorySegment, rotation, scale, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a part of a texture defined by a rectangle
     */
    public static void drawTextureRec(
            Texture texture,  
            Rectangle source,  
            Vector2 position,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.DrawTextureRec(
            texture.memorySegment, source.memorySegment, position.memorySegment, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a part of a texture defined by a rectangle with 'pro' parameters
     */
    public static void drawTexturePro(
            Texture texture,  
            Rectangle source,  
            Rectangle dest,  
            Vector2 origin,  
            float rotation,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.DrawTexturePro(
            texture.memorySegment, source.memorySegment, dest.memorySegment, origin.memorySegment, rotation, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Draws a texture (or part of it) that stretches or shrinks nicely
     */
    public static void drawTextureNPatch(
            Texture texture,  
            NPatchInfo nPatchInfo,  
            Rectangle dest,  
            Vector2 origin,  
            float rotation,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.DrawTextureNPatch(
            texture.memorySegment, nPatchInfo.memorySegment, dest.memorySegment, origin.memorySegment, rotation, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Check if two colors are equal
     */
    public static boolean colorIsEqual(
            Color col1,  
            Color col2 
        ){
            
            return com.raylib.jextract.raylib_h.ColorIsEqual(
            col1.memorySegment, col2.memorySegment
        );
            
    }
    
    
    /**
     * Get color with alpha applied, alpha goes from 0.0f to 1.0f
     */
    public static Color fade(
            Color color,  
            float alpha 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.Fade(Arena.ofAuto(), 
            color.memorySegment, alpha
        ));
            
            
    }
    
    /**
     * Get color with alpha applied, alpha goes from 0.0f to 1.0f
     */
    public static Color fade(Arena arena,  
            Color color,  
            float alpha 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.Fade(arena, 
            color.memorySegment, alpha
        ));
            
            
    }
    
    
    /**
     * Get hexadecimal value for a Color (0xRRGGBBAA)
     */
    public static int colorToInt(
            Color color 
        ){
            
            return com.raylib.jextract.raylib_h.ColorToInt(
            color.memorySegment
        );
            
    }
    
    
    /**
     * Get Color normalized as float [0..1]
     */
    public static Vector4 colorNormalize(
            Color color 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.ColorNormalize(Arena.ofAuto(), 
            color.memorySegment
        ));
            
            
    }
    
    /**
     * Get Color normalized as float [0..1]
     */
    public static Vector4 colorNormalize(Arena arena,  
            Color color 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.ColorNormalize(arena, 
            color.memorySegment
        ));
            
            
    }
    
    
    /**
     * Get Color from normalized values [0..1]
     */
    public static Color colorFromNormalized(
            Vector4 normalized 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.ColorFromNormalized(Arena.ofAuto(), 
            normalized.memorySegment
        ));
            
            
    }
    
    /**
     * Get Color from normalized values [0..1]
     */
    public static Color colorFromNormalized(Arena arena,  
            Vector4 normalized 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.ColorFromNormalized(arena, 
            normalized.memorySegment
        ));
            
            
    }
    
    
    /**
     * Get HSV values for a Color, hue [0..360], saturation/value [0..1]
     */
    public static Vector3 colorToHSV(
            Color color 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.ColorToHSV(Arena.ofAuto(), 
            color.memorySegment
        ));
            
            
    }
    
    /**
     * Get HSV values for a Color, hue [0..360], saturation/value [0..1]
     */
    public static Vector3 colorToHSV(Arena arena,  
            Color color 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.ColorToHSV(arena, 
            color.memorySegment
        ));
            
            
    }
    
    
    /**
     * Get a Color from HSV values, hue [0..360], saturation/value [0..1]
     */
    public static Color colorFromHSV(
            float hue,  
            float saturation,  
            float value 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.ColorFromHSV(Arena.ofAuto(), 
            hue, saturation, value
        ));
            
            
    }
    
    /**
     * Get a Color from HSV values, hue [0..360], saturation/value [0..1]
     */
    public static Color colorFromHSV(Arena arena,  
            float hue,  
            float saturation,  
            float value 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.ColorFromHSV(arena, 
            hue, saturation, value
        ));
            
            
    }
    
    
    /**
     * Get color multiplied with another color
     */
    public static Color colorTint(
            Color color,  
            Color tint 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.ColorTint(Arena.ofAuto(), 
            color.memorySegment, tint.memorySegment
        ));
            
            
    }
    
    /**
     * Get color multiplied with another color
     */
    public static Color colorTint(Arena arena,  
            Color color,  
            Color tint 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.ColorTint(arena, 
            color.memorySegment, tint.memorySegment
        ));
            
            
    }
    
    
    /**
     * Get color with brightness correction, brightness factor goes from -1.0f to 1.0f
     */
    public static Color colorBrightness(
            Color color,  
            float factor 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.ColorBrightness(Arena.ofAuto(), 
            color.memorySegment, factor
        ));
            
            
    }
    
    /**
     * Get color with brightness correction, brightness factor goes from -1.0f to 1.0f
     */
    public static Color colorBrightness(Arena arena,  
            Color color,  
            float factor 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.ColorBrightness(arena, 
            color.memorySegment, factor
        ));
            
            
    }
    
    
    /**
     * Get color with contrast correction, contrast values between -1.0f and 1.0f
     */
    public static Color colorContrast(
            Color color,  
            float contrast 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.ColorContrast(Arena.ofAuto(), 
            color.memorySegment, contrast
        ));
            
            
    }
    
    /**
     * Get color with contrast correction, contrast values between -1.0f and 1.0f
     */
    public static Color colorContrast(Arena arena,  
            Color color,  
            float contrast 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.ColorContrast(arena, 
            color.memorySegment, contrast
        ));
            
            
    }
    
    
    /**
     * Get color with alpha applied, alpha goes from 0.0f to 1.0f
     */
    public static Color colorAlpha(
            Color color,  
            float alpha 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.ColorAlpha(Arena.ofAuto(), 
            color.memorySegment, alpha
        ));
            
            
    }
    
    /**
     * Get color with alpha applied, alpha goes from 0.0f to 1.0f
     */
    public static Color colorAlpha(Arena arena,  
            Color color,  
            float alpha 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.ColorAlpha(arena, 
            color.memorySegment, alpha
        ));
            
            
    }
    
    
    /**
     * Get src alpha-blended into dst color with tint
     */
    public static Color colorAlphaBlend(
            Color dst,  
            Color src,  
            Color tint 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.ColorAlphaBlend(Arena.ofAuto(), 
            dst.memorySegment, src.memorySegment, tint.memorySegment
        ));
            
            
    }
    
    /**
     * Get src alpha-blended into dst color with tint
     */
    public static Color colorAlphaBlend(Arena arena,  
            Color dst,  
            Color src,  
            Color tint 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.ColorAlphaBlend(arena, 
            dst.memorySegment, src.memorySegment, tint.memorySegment
        ));
            
            
    }
    
    
    /**
     * Get color lerp interpolation between two colors, factor [0.0f..1.0f]
     */
    public static Color colorLerp(
            Color color1,  
            Color color2,  
            float factor 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.ColorLerp(Arena.ofAuto(), 
            color1.memorySegment, color2.memorySegment, factor
        ));
            
            
    }
    
    /**
     * Get color lerp interpolation between two colors, factor [0.0f..1.0f]
     */
    public static Color colorLerp(Arena arena,  
            Color color1,  
            Color color2,  
            float factor 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.ColorLerp(arena, 
            color1.memorySegment, color2.memorySegment, factor
        ));
            
            
    }
    
    
    /**
     * Get Color structure from hexadecimal value
     */
    public static Color getColor(
            int hexValue 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.GetColor(Arena.ofAuto(), 
            hexValue
        ));
            
            
    }
    
    /**
     * Get Color structure from hexadecimal value
     */
    public static Color getColor(Arena arena,  
            int hexValue 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.GetColor(arena, 
            hexValue
        ));
            
            
    }
    
    
    /**
     * Get Color from a source pixel pointer of certain format
     */
    public static Color getPixelColor(
            MemorySegment srcPtr,  
            int format 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.GetPixelColor(Arena.ofAuto(), 
            srcPtr, format
        ));
            
            
    }
    
    /**
     * Get Color from a source pixel pointer of certain format
     */
    public static Color getPixelColor(Arena arena,  
            MemorySegment srcPtr,  
            int format 
        ){
            
             return new Color(com.raylib.jextract.raylib_h.GetPixelColor(arena, 
            srcPtr, format
        ));
            
            
    }
    
    
    /**
     * Set color formatted into destination pixel pointer
     */
    public static void setPixelColor(
            MemorySegment dstPtr,  
            Color color,  
            int format 
        ){
            
            com.raylib.jextract.raylib_h.SetPixelColor(
            dstPtr, color.memorySegment, format
        );
            
            
    }
    
    
    /**
     * Get pixel data size in bytes for certain format
     */
    public static int getPixelDataSize(
            int width,  
            int height,  
            int format 
        ){
            
            return com.raylib.jextract.raylib_h.GetPixelDataSize(
            width, height, format
        );
            
    }
    
    
    /**
     * Get the default Font
     */
    public static Font getFontDefault(
        ){
            
             return new Font(com.raylib.jextract.raylib_h.GetFontDefault(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * Get the default Font
     */
    public static Font getFontDefault(Arena arena 
        ){
            
             return new Font(com.raylib.jextract.raylib_h.GetFontDefault(arena
            
        ));
            
            
    }
    
    
    /**
     * Load font from file into GPU memory (VRAM)
     */
    public static Font loadFont(
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Font(com.raylib.jextract.raylib_h.LoadFont(Arena.ofAuto(), 
            localArena.allocateFrom(fileName)
        ));
            
            }
    }
    
    /**
     * Load font from file into GPU memory (VRAM)
     */
    public static Font loadFont(Arena arena,  
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Font(com.raylib.jextract.raylib_h.LoadFont(arena, 
            localArena.allocateFrom(fileName)
        ));
            
            }
    }
    
    
    /**
     * Load font from file with extended parameters, use NULL for codepoints and 0 for codepointCount to load the default character set, font size is provided in pixels height
     */
    public static Font loadFontEx(
            String fileName,  
            int fontSize,  
            java.nio.IntBuffer codepoints,  
            int codepointCount 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Font(com.raylib.jextract.raylib_h.LoadFontEx(Arena.ofAuto(), 
            localArena.allocateFrom(fileName), fontSize, codepoints == null ? MemorySegment.NULL : MemorySegment.ofBuffer(codepoints), codepointCount
        ));
            
            }
    }
    
    /**
     * Load font from file with extended parameters, use NULL for codepoints and 0 for codepointCount to load the default character set, font size is provided in pixels height
     */
    public static Font loadFontEx(Arena arena,  
            String fileName,  
            int fontSize,  
            java.nio.IntBuffer codepoints,  
            int codepointCount 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Font(com.raylib.jextract.raylib_h.LoadFontEx(arena, 
            localArena.allocateFrom(fileName), fontSize, codepoints == null ? MemorySegment.NULL : MemorySegment.ofBuffer(codepoints), codepointCount
        ));
            
            }
    }
    
    
    /**
     * Load font from Image (XNA style)
     */
    public static Font loadFontFromImage(
            Image image,  
            Color key,  
            int firstChar 
        ){
            
             return new Font(com.raylib.jextract.raylib_h.LoadFontFromImage(Arena.ofAuto(), 
            image.memorySegment, key.memorySegment, firstChar
        ));
            
            
    }
    
    /**
     * Load font from Image (XNA style)
     */
    public static Font loadFontFromImage(Arena arena,  
            Image image,  
            Color key,  
            int firstChar 
        ){
            
             return new Font(com.raylib.jextract.raylib_h.LoadFontFromImage(arena, 
            image.memorySegment, key.memorySegment, firstChar
        ));
            
            
    }
    
    
    /**
     * Load font from memory buffer, fileType refers to extension: i.e. '.ttf'
     */
    public static Font loadFontFromMemory(
            String fileType,  
            java.nio.ByteBuffer fileData,  
            int dataSize,  
            int fontSize,  
            java.nio.IntBuffer codepoints,  
            int codepointCount 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Font(com.raylib.jextract.raylib_h.LoadFontFromMemory(Arena.ofAuto(), 
            localArena.allocateFrom(fileType), MemorySegment.ofBuffer(fileData), dataSize, fontSize, codepoints == null ? MemorySegment.NULL : MemorySegment.ofBuffer(codepoints), codepointCount
        ));
            
            }
    }
    
    /**
     * Load font from memory buffer, fileType refers to extension: i.e. '.ttf'
     */
    public static Font loadFontFromMemory(Arena arena,  
            String fileType,  
            java.nio.ByteBuffer fileData,  
            int dataSize,  
            int fontSize,  
            java.nio.IntBuffer codepoints,  
            int codepointCount 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Font(com.raylib.jextract.raylib_h.LoadFontFromMemory(arena, 
            localArena.allocateFrom(fileType), MemorySegment.ofBuffer(fileData), dataSize, fontSize, codepoints == null ? MemorySegment.NULL : MemorySegment.ofBuffer(codepoints), codepointCount
        ));
            
            }
    }
    
    
    /**
     * Check if a font is valid (font data loaded, WARNING: GPU texture not checked)
     */
    public static boolean isFontValid(
            Font font 
        ){
            
            return com.raylib.jextract.raylib_h.IsFontValid(
            font.memorySegment
        );
            
    }
    
    
    /**
     * Load font data for further use
     */
    public static GlyphInfo loadFontData(
            java.nio.ByteBuffer fileData,  
            int dataSize,  
            int fontSize,  
            java.nio.IntBuffer codepoints,  
            int codepointCount,  
            int type 
        ){
            
             return new GlyphInfo(com.raylib.jextract.raylib_h.LoadFontData(
            MemorySegment.ofBuffer(fileData), dataSize, fontSize, codepoints == null ? MemorySegment.NULL : MemorySegment.ofBuffer(codepoints), codepointCount, type
        ));
            
            
    }
    
    
    /**
     * Generate image font atlas using chars info
     */
    public static Image genImageFontAtlas(
            MemorySegment glyphs,  
            MemorySegment glyphRecs,  
            int glyphCount,  
            int fontSize,  
            int padding,  
            int packMethod 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImageFontAtlas(Arena.ofAuto(), 
            glyphs, glyphRecs, glyphCount, fontSize, padding, packMethod
        ));
            
            
    }
    
    /**
     * Generate image font atlas using chars info
     */
    public static Image genImageFontAtlas(Arena arena,  
            MemorySegment glyphs,  
            MemorySegment glyphRecs,  
            int glyphCount,  
            int fontSize,  
            int padding,  
            int packMethod 
        ){
            
             return new Image(com.raylib.jextract.raylib_h.GenImageFontAtlas(arena, 
            glyphs, glyphRecs, glyphCount, fontSize, padding, packMethod
        ));
            
            
    }
    
    
    /**
     * Unload font chars info data (RAM)
     */
    public static void unloadFontData(
            GlyphInfo glyphs,  
            int glyphCount 
        ){
            
            com.raylib.jextract.raylib_h.UnloadFontData(
            glyphs.memorySegment, glyphCount
        );
            
            
    }
    
    
    /**
     * Unload font from GPU memory (VRAM)
     */
    public static void unloadFont(
            Font font 
        ){
            
            com.raylib.jextract.raylib_h.UnloadFont(
            font.memorySegment
        );
            
            
    }
    
    
    /**
     * Export font as code file, returns true on success
     */
    public static boolean exportFontAsCode(
            Font font,  
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.ExportFontAsCode(
            font.memorySegment, localArena.allocateFrom(fileName)
        );
            }
    }
    
    
    /**
     * Draw current FPS
     */
    public static void drawFPS(
            int posX,  
            int posY 
        ){
            
            com.raylib.jextract.raylib_h.DrawFPS(
            posX, posY
        );
            
            
    }
    
    
    /**
     * Draw text (using default font)
     */
    public static void drawText(
            String text,  
            int posX,  
            int posY,  
            int fontSize,  
            Color color 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            com.raylib.jextract.raylib_h.DrawText(
            localArena.allocateFrom(text), posX, posY, fontSize, color.memorySegment
        );
            
            }
    }
    
    
    /**
     * Draw text using font and additional parameters
     */
    public static void drawTextEx(
            Font font,  
            String text,  
            Vector2 position,  
            float fontSize,  
            float spacing,  
            Color tint 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            com.raylib.jextract.raylib_h.DrawTextEx(
            font.memorySegment, localArena.allocateFrom(text), position.memorySegment, fontSize, spacing, tint.memorySegment
        );
            
            }
    }
    
    
    /**
     * Draw text using Font and pro parameters (rotation)
     */
    public static void drawTextPro(
            Font font,  
            String text,  
            Vector2 position,  
            Vector2 origin,  
            float rotation,  
            float fontSize,  
            float spacing,  
            Color tint 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            com.raylib.jextract.raylib_h.DrawTextPro(
            font.memorySegment, localArena.allocateFrom(text), position.memorySegment, origin.memorySegment, rotation, fontSize, spacing, tint.memorySegment
        );
            
            }
    }
    
    
    /**
     * Draw one character (codepoint)
     */
    public static void drawTextCodepoint(
            Font font,  
            int codepoint,  
            Vector2 position,  
            float fontSize,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.DrawTextCodepoint(
            font.memorySegment, codepoint, position.memorySegment, fontSize, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw multiple character (codepoint)
     */
    public static void drawTextCodepoints(
            Font font,  
            MemorySegment codepoints,  
            int codepointCount,  
            Vector2 position,  
            float fontSize,  
            float spacing,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.DrawTextCodepoints(
            font.memorySegment, codepoints, codepointCount, position.memorySegment, fontSize, spacing, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Set vertical line spacing when drawing with line-breaks
     */
    public static void setTextLineSpacing(
            int spacing 
        ){
            
            com.raylib.jextract.raylib_h.SetTextLineSpacing(
            spacing
        );
            
            
    }
    
    
    /**
     * Measure string width for default font
     */
    public static int measureText(
            String text,  
            int fontSize 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.MeasureText(
            localArena.allocateFrom(text), fontSize
        );
            }
    }
    
    
    /**
     * Measure string size for Font
     */
    public static Vector2 measureTextEx(
            Font font,  
            String text,  
            float fontSize,  
            float spacing 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Vector2(com.raylib.jextract.raylib_h.MeasureTextEx(Arena.ofAuto(), 
            font.memorySegment, localArena.allocateFrom(text), fontSize, spacing
        ));
            
            }
    }
    
    /**
     * Measure string size for Font
     */
    public static Vector2 measureTextEx(Arena arena,  
            Font font,  
            String text,  
            float fontSize,  
            float spacing 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Vector2(com.raylib.jextract.raylib_h.MeasureTextEx(arena, 
            font.memorySegment, localArena.allocateFrom(text), fontSize, spacing
        ));
            
            }
    }
    
    
    /**
     * Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found
     */
    public static int getGlyphIndex(
            Font font,  
            int codepoint 
        ){
            
            return com.raylib.jextract.raylib_h.GetGlyphIndex(
            font.memorySegment, codepoint
        );
            
    }
    
    
    /**
     * Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found
     */
    public static GlyphInfo getGlyphInfo(
            Font font,  
            int codepoint 
        ){
            
             return new GlyphInfo(com.raylib.jextract.raylib_h.GetGlyphInfo(Arena.ofAuto(), 
            font.memorySegment, codepoint
        ));
            
            
    }
    
    /**
     * Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found
     */
    public static GlyphInfo getGlyphInfo(Arena arena,  
            Font font,  
            int codepoint 
        ){
            
             return new GlyphInfo(com.raylib.jextract.raylib_h.GetGlyphInfo(arena, 
            font.memorySegment, codepoint
        ));
            
            
    }
    
    
    /**
     * Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found
     */
    public static Rectangle getGlyphAtlasRec(
            Font font,  
            int codepoint 
        ){
            
             return new Rectangle(com.raylib.jextract.raylib_h.GetGlyphAtlasRec(Arena.ofAuto(), 
            font.memorySegment, codepoint
        ));
            
            
    }
    
    /**
     * Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found
     */
    public static Rectangle getGlyphAtlasRec(Arena arena,  
            Font font,  
            int codepoint 
        ){
            
             return new Rectangle(com.raylib.jextract.raylib_h.GetGlyphAtlasRec(arena, 
            font.memorySegment, codepoint
        ));
            
            
    }
    
    
    /**
     * Load UTF-8 text encoded from codepoints array
     */
    public static java.nio.ByteBuffer loadUTF8(
            MemorySegment codepoints,  
            int length 
        ){
            
            return com.raylib.jextract.raylib_h.LoadUTF8(
            codepoints, length
        ).reinterpret(Integer.MAX_VALUE/2).asByteBuffer().order(ByteOrder.nativeOrder());
            
    }
    
    
    /**
     * Unload UTF-8 text encoded from codepoints array
     */
    public static void unloadUTF8(
            java.nio.ByteBuffer text 
        ){
            
            com.raylib.jextract.raylib_h.UnloadUTF8(
            MemorySegment.ofBuffer(text)
        );
            
            
    }
    
    
    /**
     * Load all codepoints from a UTF-8 text string, codepoints count returned by parameter
     */
    public static java.nio.IntBuffer loadCodepoints(
            String text,  
            java.nio.IntBuffer count 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.LoadCodepoints(
            localArena.allocateFrom(text), count == null ? MemorySegment.NULL : MemorySegment.ofBuffer(count)
        ).reinterpret(Integer.MAX_VALUE/2).asByteBuffer().order(ByteOrder.nativeOrder()).asIntBuffer();
            }
    }
    
    
    /**
     * Unload codepoints data from memory
     */
    public static void unloadCodepoints(
            java.nio.IntBuffer codepoints 
        ){
            
            com.raylib.jextract.raylib_h.UnloadCodepoints(
            codepoints == null ? MemorySegment.NULL : MemorySegment.ofBuffer(codepoints)
        );
            
            
    }
    
    
    /**
     * Get total number of codepoints in a UTF-8 encoded string
     */
    public static int getCodepointCount(
            String text 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.GetCodepointCount(
            localArena.allocateFrom(text)
        );
            }
    }
    
    
    /**
     * Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
     */
    public static int getCodepoint(
            String text,  
            java.nio.IntBuffer codepointSize 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.GetCodepoint(
            localArena.allocateFrom(text), codepointSize == null ? MemorySegment.NULL : MemorySegment.ofBuffer(codepointSize)
        );
            }
    }
    
    
    /**
     * Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
     */
    public static int getCodepointNext(
            String text,  
            java.nio.IntBuffer codepointSize 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.GetCodepointNext(
            localArena.allocateFrom(text), codepointSize == null ? MemorySegment.NULL : MemorySegment.ofBuffer(codepointSize)
        );
            }
    }
    
    
    /**
     * Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
     */
    public static int getCodepointPrevious(
            String text,  
            java.nio.IntBuffer codepointSize 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.GetCodepointPrevious(
            localArena.allocateFrom(text), codepointSize == null ? MemorySegment.NULL : MemorySegment.ofBuffer(codepointSize)
        );
            }
    }
    
    
    /**
     * Encode one codepoint into UTF-8 byte array (array length returned as parameter)
     */
    public static String codepointToUTF8(
            int codepoint,  
            java.nio.IntBuffer utf8Size 
        ){
            
            return com.raylib.jextract.raylib_h.CodepointToUTF8(
            codepoint, utf8Size == null ? MemorySegment.NULL : MemorySegment.ofBuffer(utf8Size)
        ).getString(0);
            
    }
    
    
    /**
     * Copy one string to another, returns bytes copied
     */
    public static int textCopy(
            java.nio.ByteBuffer dst,  
            String src 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.TextCopy(
            MemorySegment.ofBuffer(dst), localArena.allocateFrom(src)
        );
            }
    }
    
    
    /**
     * Check if two text string are equal
     */
    public static boolean textIsEqual(
            String text1,  
            String text2 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.TextIsEqual(
            localArena.allocateFrom(text1), localArena.allocateFrom(text2)
        );
            }
    }
    
    
    /**
     * Get text length, checks for '\0' ending
     */
    public static int textLength(
            String text 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.TextLength(
            localArena.allocateFrom(text)
        );
            }
    }
    
    
    /**
     * Get a piece of a text string
     */
    public static String textSubtext(
            String text,  
            int position,  
            int length 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.TextSubtext(
            localArena.allocateFrom(text), position, length
        ).getString(0);
            }
    }
    
    
    /**
     * Replace text string (WARNING: memory must be freed!)
     */
    public static java.nio.ByteBuffer textReplace(
            String text,  
            String replace,  
            String by 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.TextReplace(
            localArena.allocateFrom(text), localArena.allocateFrom(replace), localArena.allocateFrom(by)
        ).reinterpret(Integer.MAX_VALUE/2).asByteBuffer().order(ByteOrder.nativeOrder());
            }
    }
    
    
    /**
     * Insert text in a position (WARNING: memory must be freed!)
     */
    public static java.nio.ByteBuffer textInsert(
            String text,  
            String insert,  
            int position 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.TextInsert(
            localArena.allocateFrom(text), localArena.allocateFrom(insert), position
        ).reinterpret(Integer.MAX_VALUE/2).asByteBuffer().order(ByteOrder.nativeOrder());
            }
    }
    
    
    /**
     * Join text strings with delimiter
     */
    public static String textJoin(
            MemorySegment textList,  
            int count,  
            String delimiter 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.TextJoin(
            textList, count, localArena.allocateFrom(delimiter)
        ).getString(0);
            }
    }
    
    
    /**
     * Split text into multiple strings
     */
    public static MemorySegment textSplit(
            String text,  
            byte delimiter,  
            java.nio.IntBuffer count 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.TextSplit(
            localArena.allocateFrom(text), delimiter, count == null ? MemorySegment.NULL : MemorySegment.ofBuffer(count)
        );
            }
    }
    
    
    /**
     * Append text at specific position and move cursor!
     */
    public static void textAppend(
            java.nio.ByteBuffer text,  
            String append,  
            java.nio.IntBuffer position 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            com.raylib.jextract.raylib_h.TextAppend(
            MemorySegment.ofBuffer(text), localArena.allocateFrom(append), position == null ? MemorySegment.NULL : MemorySegment.ofBuffer(position)
        );
            
            }
    }
    
    
    /**
     * Find first text occurrence within a string
     */
    public static int textFindIndex(
            String text,  
            String find 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.TextFindIndex(
            localArena.allocateFrom(text), localArena.allocateFrom(find)
        );
            }
    }
    
    
    /**
     * Get upper case version of provided string
     */
    public static String textToUpper(
            String text 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.TextToUpper(
            localArena.allocateFrom(text)
        ).getString(0);
            }
    }
    
    
    /**
     * Get lower case version of provided string
     */
    public static String textToLower(
            String text 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.TextToLower(
            localArena.allocateFrom(text)
        ).getString(0);
            }
    }
    
    
    /**
     * Get Pascal case notation version of provided string
     */
    public static String textToPascal(
            String text 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.TextToPascal(
            localArena.allocateFrom(text)
        ).getString(0);
            }
    }
    
    
    /**
     * Get Snake case notation version of provided string
     */
    public static String textToSnake(
            String text 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.TextToSnake(
            localArena.allocateFrom(text)
        ).getString(0);
            }
    }
    
    
    /**
     * Get Camel case notation version of provided string
     */
    public static String textToCamel(
            String text 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.TextToCamel(
            localArena.allocateFrom(text)
        ).getString(0);
            }
    }
    
    
    /**
     * Get integer value from text (negative values not supported)
     */
    public static int textToInteger(
            String text 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.TextToInteger(
            localArena.allocateFrom(text)
        );
            }
    }
    
    
    /**
     * Get float value from text (negative values not supported)
     */
    public static float textToFloat(
            String text 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.TextToFloat(
            localArena.allocateFrom(text)
        );
            }
    }
    
    
    /**
     * Draw a line in 3D world space
     */
    public static void drawLine3D(
            Vector3 startPos,  
            Vector3 endPos,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawLine3D(
            startPos.memorySegment, endPos.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a point in 3D space, actually a small line
     */
    public static void drawPoint3D(
            Vector3 position,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawPoint3D(
            position.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a circle in 3D world space
     */
    public static void drawCircle3D(
            Vector3 center,  
            float radius,  
            Vector3 rotationAxis,  
            float rotationAngle,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawCircle3D(
            center.memorySegment, radius, rotationAxis.memorySegment, rotationAngle, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a color-filled triangle (vertex in counter-clockwise order!)
     */
    public static void drawTriangle3D(
            Vector3 v1,  
            Vector3 v2,  
            Vector3 v3,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawTriangle3D(
            v1.memorySegment, v2.memorySegment, v3.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a triangle strip defined by points
     */
    public static void drawTriangleStrip3D(
            MemorySegment points,  
            int pointCount,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawTriangleStrip3D(
            points, pointCount, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw cube
     */
    public static void drawCube(
            Vector3 position,  
            float width,  
            float height,  
            float length,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawCube(
            position.memorySegment, width, height, length, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw cube (Vector version)
     */
    public static void drawCubeV(
            Vector3 position,  
            Vector3 size,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawCubeV(
            position.memorySegment, size.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw cube wires
     */
    public static void drawCubeWires(
            Vector3 position,  
            float width,  
            float height,  
            float length,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawCubeWires(
            position.memorySegment, width, height, length, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw cube wires (Vector version)
     */
    public static void drawCubeWiresV(
            Vector3 position,  
            Vector3 size,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawCubeWiresV(
            position.memorySegment, size.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw sphere
     */
    public static void drawSphere(
            Vector3 centerPos,  
            float radius,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawSphere(
            centerPos.memorySegment, radius, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw sphere with extended parameters
     */
    public static void drawSphereEx(
            Vector3 centerPos,  
            float radius,  
            int rings,  
            int slices,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawSphereEx(
            centerPos.memorySegment, radius, rings, slices, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw sphere wires
     */
    public static void drawSphereWires(
            Vector3 centerPos,  
            float radius,  
            int rings,  
            int slices,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawSphereWires(
            centerPos.memorySegment, radius, rings, slices, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a cylinder/cone
     */
    public static void drawCylinder(
            Vector3 position,  
            float radiusTop,  
            float radiusBottom,  
            float height,  
            int slices,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawCylinder(
            position.memorySegment, radiusTop, radiusBottom, height, slices, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a cylinder with base at startPos and top at endPos
     */
    public static void drawCylinderEx(
            Vector3 startPos,  
            Vector3 endPos,  
            float startRadius,  
            float endRadius,  
            int sides,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawCylinderEx(
            startPos.memorySegment, endPos.memorySegment, startRadius, endRadius, sides, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a cylinder/cone wires
     */
    public static void drawCylinderWires(
            Vector3 position,  
            float radiusTop,  
            float radiusBottom,  
            float height,  
            int slices,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawCylinderWires(
            position.memorySegment, radiusTop, radiusBottom, height, slices, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a cylinder wires with base at startPos and top at endPos
     */
    public static void drawCylinderWiresEx(
            Vector3 startPos,  
            Vector3 endPos,  
            float startRadius,  
            float endRadius,  
            int sides,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawCylinderWiresEx(
            startPos.memorySegment, endPos.memorySegment, startRadius, endRadius, sides, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a capsule with the center of its sphere caps at startPos and endPos
     */
    public static void drawCapsule(
            Vector3 startPos,  
            Vector3 endPos,  
            float radius,  
            int slices,  
            int rings,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawCapsule(
            startPos.memorySegment, endPos.memorySegment, radius, slices, rings, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw capsule wireframe with the center of its sphere caps at startPos and endPos
     */
    public static void drawCapsuleWires(
            Vector3 startPos,  
            Vector3 endPos,  
            float radius,  
            int slices,  
            int rings,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawCapsuleWires(
            startPos.memorySegment, endPos.memorySegment, radius, slices, rings, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a plane XZ
     */
    public static void drawPlane(
            Vector3 centerPos,  
            Vector2 size,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawPlane(
            centerPos.memorySegment, size.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a ray line
     */
    public static void drawRay(
            Ray ray,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawRay(
            ray.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a grid (centered at (0, 0, 0))
     */
    public static void drawGrid(
            int slices,  
            float spacing 
        ){
            
            com.raylib.jextract.raylib_h.DrawGrid(
            slices, spacing
        );
            
            
    }
    
    
    /**
     * Load model from files (meshes and materials)
     */
    public static Model loadModel(
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Model(com.raylib.jextract.raylib_h.LoadModel(Arena.ofAuto(), 
            localArena.allocateFrom(fileName)
        ));
            
            }
    }
    
    /**
     * Load model from files (meshes and materials)
     */
    public static Model loadModel(Arena arena,  
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Model(com.raylib.jextract.raylib_h.LoadModel(arena, 
            localArena.allocateFrom(fileName)
        ));
            
            }
    }
    
    
    /**
     * Load model from generated mesh (default material)
     */
    public static Model loadModelFromMesh(
            Mesh mesh 
        ){
            
             return new Model(com.raylib.jextract.raylib_h.LoadModelFromMesh(Arena.ofAuto(), 
            mesh.memorySegment
        ));
            
            
    }
    
    /**
     * Load model from generated mesh (default material)
     */
    public static Model loadModelFromMesh(Arena arena,  
            Mesh mesh 
        ){
            
             return new Model(com.raylib.jextract.raylib_h.LoadModelFromMesh(arena, 
            mesh.memorySegment
        ));
            
            
    }
    
    
    /**
     * Check if a model is valid (loaded in GPU, VAO/VBOs)
     */
    public static boolean isModelValid(
            Model model 
        ){
            
            return com.raylib.jextract.raylib_h.IsModelValid(
            model.memorySegment
        );
            
    }
    
    
    /**
     * Unload model (including meshes) from memory (RAM and/or VRAM)
     */
    public static void unloadModel(
            Model model 
        ){
            
            com.raylib.jextract.raylib_h.UnloadModel(
            model.memorySegment
        );
            
            
    }
    
    
    /**
     * Compute model bounding box limits (considers all meshes)
     */
    public static BoundingBox getModelBoundingBox(
            Model model 
        ){
            
             return new BoundingBox(com.raylib.jextract.raylib_h.GetModelBoundingBox(Arena.ofAuto(), 
            model.memorySegment
        ));
            
            
    }
    
    /**
     * Compute model bounding box limits (considers all meshes)
     */
    public static BoundingBox getModelBoundingBox(Arena arena,  
            Model model 
        ){
            
             return new BoundingBox(com.raylib.jextract.raylib_h.GetModelBoundingBox(arena, 
            model.memorySegment
        ));
            
            
    }
    
    
    /**
     * Draw a model (with texture if set)
     */
    public static void drawModel(
            Model model,  
            Vector3 position,  
            float scale,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.DrawModel(
            model.memorySegment, position.memorySegment, scale, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a model with extended parameters
     */
    public static void drawModelEx(
            Model model,  
            Vector3 position,  
            Vector3 rotationAxis,  
            float rotationAngle,  
            Vector3 scale,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.DrawModelEx(
            model.memorySegment, position.memorySegment, rotationAxis.memorySegment, rotationAngle, scale.memorySegment, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a model wires (with texture if set)
     */
    public static void drawModelWires(
            Model model,  
            Vector3 position,  
            float scale,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.DrawModelWires(
            model.memorySegment, position.memorySegment, scale, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a model wires (with texture if set) with extended parameters
     */
    public static void drawModelWiresEx(
            Model model,  
            Vector3 position,  
            Vector3 rotationAxis,  
            float rotationAngle,  
            Vector3 scale,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.DrawModelWiresEx(
            model.memorySegment, position.memorySegment, rotationAxis.memorySegment, rotationAngle, scale.memorySegment, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a model as points
     */
    public static void drawModelPoints(
            Model model,  
            Vector3 position,  
            float scale,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.DrawModelPoints(
            model.memorySegment, position.memorySegment, scale, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a model as points with extended parameters
     */
    public static void drawModelPointsEx(
            Model model,  
            Vector3 position,  
            Vector3 rotationAxis,  
            float rotationAngle,  
            Vector3 scale,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.DrawModelPointsEx(
            model.memorySegment, position.memorySegment, rotationAxis.memorySegment, rotationAngle, scale.memorySegment, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw bounding box (wires)
     */
    public static void drawBoundingBox(
            BoundingBox box,  
            Color color 
        ){
            
            com.raylib.jextract.raylib_h.DrawBoundingBox(
            box.memorySegment, color.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a billboard texture
     */
    public static void drawBillboard(
            Camera3D camera,  
            Texture texture,  
            Vector3 position,  
            float scale,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.DrawBillboard(
            camera.memorySegment, texture.memorySegment, position.memorySegment, scale, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a billboard texture defined by source
     */
    public static void drawBillboardRec(
            Camera3D camera,  
            Texture texture,  
            Rectangle source,  
            Vector3 position,  
            Vector2 size,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.DrawBillboardRec(
            camera.memorySegment, texture.memorySegment, source.memorySegment, position.memorySegment, size.memorySegment, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a billboard texture defined by source and rotation
     */
    public static void drawBillboardPro(
            Camera3D camera,  
            Texture texture,  
            Rectangle source,  
            Vector3 position,  
            Vector3 up,  
            Vector2 size,  
            Vector2 origin,  
            float rotation,  
            Color tint 
        ){
            
            com.raylib.jextract.raylib_h.DrawBillboardPro(
            camera.memorySegment, texture.memorySegment, source.memorySegment, position.memorySegment, up.memorySegment, size.memorySegment, origin.memorySegment, rotation, tint.memorySegment
        );
            
            
    }
    
    
    /**
     * Upload mesh vertex data in GPU and provide VAO/VBO ids
     */
    public static void uploadMesh(
            Mesh mesh,  
            boolean dynamic 
        ){
            
            com.raylib.jextract.raylib_h.UploadMesh(
            mesh.memorySegment, dynamic
        );
            
            
    }
    
    
    /**
     * Update mesh vertex data in GPU for a specific buffer index
     */
    public static void updateMeshBuffer(
            Mesh mesh,  
            int index,  
            MemorySegment data,  
            int dataSize,  
            int offset 
        ){
            
            com.raylib.jextract.raylib_h.UpdateMeshBuffer(
            mesh.memorySegment, index, data, dataSize, offset
        );
            
            
    }
    
    
    /**
     * Unload mesh data from CPU and GPU
     */
    public static void unloadMesh(
            Mesh mesh 
        ){
            
            com.raylib.jextract.raylib_h.UnloadMesh(
            mesh.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw a 3d mesh with material and transform
     */
    public static void drawMesh(
            Mesh mesh,  
            Material material,  
            Matrix transform 
        ){
            
            com.raylib.jextract.raylib_h.DrawMesh(
            mesh.memorySegment, material.memorySegment, transform.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw multiple mesh instances with material and different transforms
     */
    public static void drawMeshInstanced(
            Mesh mesh,  
            Material material,  
            MemorySegment transforms,  
            int instances 
        ){
            
            com.raylib.jextract.raylib_h.DrawMeshInstanced(
            mesh.memorySegment, material.memorySegment, transforms, instances
        );
            
            
    }
    
    
    /**
     * Compute mesh bounding box limits
     */
    public static BoundingBox getMeshBoundingBox(
            Mesh mesh 
        ){
            
             return new BoundingBox(com.raylib.jextract.raylib_h.GetMeshBoundingBox(Arena.ofAuto(), 
            mesh.memorySegment
        ));
            
            
    }
    
    /**
     * Compute mesh bounding box limits
     */
    public static BoundingBox getMeshBoundingBox(Arena arena,  
            Mesh mesh 
        ){
            
             return new BoundingBox(com.raylib.jextract.raylib_h.GetMeshBoundingBox(arena, 
            mesh.memorySegment
        ));
            
            
    }
    
    
    /**
     * Compute mesh tangents
     */
    public static void genMeshTangents(
            Mesh mesh 
        ){
            
            com.raylib.jextract.raylib_h.GenMeshTangents(
            mesh.memorySegment
        );
            
            
    }
    
    
    /**
     * Export mesh data to file, returns true on success
     */
    public static boolean exportMesh(
            Mesh mesh,  
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.ExportMesh(
            mesh.memorySegment, localArena.allocateFrom(fileName)
        );
            }
    }
    
    
    /**
     * Export mesh as code file (.h) defining multiple arrays of vertex attributes
     */
    public static boolean exportMeshAsCode(
            Mesh mesh,  
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.ExportMeshAsCode(
            mesh.memorySegment, localArena.allocateFrom(fileName)
        );
            }
    }
    
    
    /**
     * Generate polygonal mesh
     */
    public static Mesh genMeshPoly(
            int sides,  
            float radius 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshPoly(Arena.ofAuto(), 
            sides, radius
        ));
            
            
    }
    
    /**
     * Generate polygonal mesh
     */
    public static Mesh genMeshPoly(Arena arena,  
            int sides,  
            float radius 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshPoly(arena, 
            sides, radius
        ));
            
            
    }
    
    
    /**
     * Generate plane mesh (with subdivisions)
     */
    public static Mesh genMeshPlane(
            float width,  
            float length,  
            int resX,  
            int resZ 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshPlane(Arena.ofAuto(), 
            width, length, resX, resZ
        ));
            
            
    }
    
    /**
     * Generate plane mesh (with subdivisions)
     */
    public static Mesh genMeshPlane(Arena arena,  
            float width,  
            float length,  
            int resX,  
            int resZ 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshPlane(arena, 
            width, length, resX, resZ
        ));
            
            
    }
    
    
    /**
     * Generate cuboid mesh
     */
    public static Mesh genMeshCube(
            float width,  
            float height,  
            float length 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshCube(Arena.ofAuto(), 
            width, height, length
        ));
            
            
    }
    
    /**
     * Generate cuboid mesh
     */
    public static Mesh genMeshCube(Arena arena,  
            float width,  
            float height,  
            float length 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshCube(arena, 
            width, height, length
        ));
            
            
    }
    
    
    /**
     * Generate sphere mesh (standard sphere)
     */
    public static Mesh genMeshSphere(
            float radius,  
            int rings,  
            int slices 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshSphere(Arena.ofAuto(), 
            radius, rings, slices
        ));
            
            
    }
    
    /**
     * Generate sphere mesh (standard sphere)
     */
    public static Mesh genMeshSphere(Arena arena,  
            float radius,  
            int rings,  
            int slices 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshSphere(arena, 
            radius, rings, slices
        ));
            
            
    }
    
    
    /**
     * Generate half-sphere mesh (no bottom cap)
     */
    public static Mesh genMeshHemiSphere(
            float radius,  
            int rings,  
            int slices 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshHemiSphere(Arena.ofAuto(), 
            radius, rings, slices
        ));
            
            
    }
    
    /**
     * Generate half-sphere mesh (no bottom cap)
     */
    public static Mesh genMeshHemiSphere(Arena arena,  
            float radius,  
            int rings,  
            int slices 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshHemiSphere(arena, 
            radius, rings, slices
        ));
            
            
    }
    
    
    /**
     * Generate cylinder mesh
     */
    public static Mesh genMeshCylinder(
            float radius,  
            float height,  
            int slices 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshCylinder(Arena.ofAuto(), 
            radius, height, slices
        ));
            
            
    }
    
    /**
     * Generate cylinder mesh
     */
    public static Mesh genMeshCylinder(Arena arena,  
            float radius,  
            float height,  
            int slices 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshCylinder(arena, 
            radius, height, slices
        ));
            
            
    }
    
    
    /**
     * Generate cone/pyramid mesh
     */
    public static Mesh genMeshCone(
            float radius,  
            float height,  
            int slices 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshCone(Arena.ofAuto(), 
            radius, height, slices
        ));
            
            
    }
    
    /**
     * Generate cone/pyramid mesh
     */
    public static Mesh genMeshCone(Arena arena,  
            float radius,  
            float height,  
            int slices 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshCone(arena, 
            radius, height, slices
        ));
            
            
    }
    
    
    /**
     * Generate torus mesh
     */
    public static Mesh genMeshTorus(
            float radius,  
            float size,  
            int radSeg,  
            int sides 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshTorus(Arena.ofAuto(), 
            radius, size, radSeg, sides
        ));
            
            
    }
    
    /**
     * Generate torus mesh
     */
    public static Mesh genMeshTorus(Arena arena,  
            float radius,  
            float size,  
            int radSeg,  
            int sides 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshTorus(arena, 
            radius, size, radSeg, sides
        ));
            
            
    }
    
    
    /**
     * Generate trefoil knot mesh
     */
    public static Mesh genMeshKnot(
            float radius,  
            float size,  
            int radSeg,  
            int sides 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshKnot(Arena.ofAuto(), 
            radius, size, radSeg, sides
        ));
            
            
    }
    
    /**
     * Generate trefoil knot mesh
     */
    public static Mesh genMeshKnot(Arena arena,  
            float radius,  
            float size,  
            int radSeg,  
            int sides 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshKnot(arena, 
            radius, size, radSeg, sides
        ));
            
            
    }
    
    
    /**
     * Generate heightmap mesh from image data
     */
    public static Mesh genMeshHeightmap(
            Image heightmap,  
            Vector3 size 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshHeightmap(Arena.ofAuto(), 
            heightmap.memorySegment, size.memorySegment
        ));
            
            
    }
    
    /**
     * Generate heightmap mesh from image data
     */
    public static Mesh genMeshHeightmap(Arena arena,  
            Image heightmap,  
            Vector3 size 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshHeightmap(arena, 
            heightmap.memorySegment, size.memorySegment
        ));
            
            
    }
    
    
    /**
     * Generate cubes-based map mesh from image data
     */
    public static Mesh genMeshCubicmap(
            Image cubicmap,  
            Vector3 cubeSize 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshCubicmap(Arena.ofAuto(), 
            cubicmap.memorySegment, cubeSize.memorySegment
        ));
            
            
    }
    
    /**
     * Generate cubes-based map mesh from image data
     */
    public static Mesh genMeshCubicmap(Arena arena,  
            Image cubicmap,  
            Vector3 cubeSize 
        ){
            
             return new Mesh(com.raylib.jextract.raylib_h.GenMeshCubicmap(arena, 
            cubicmap.memorySegment, cubeSize.memorySegment
        ));
            
            
    }
    
    
    /**
     * Load materials from model file
     */
    public static Material loadMaterials(
            String fileName,  
            java.nio.IntBuffer materialCount 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Material(com.raylib.jextract.raylib_h.LoadMaterials(
            localArena.allocateFrom(fileName), materialCount == null ? MemorySegment.NULL : MemorySegment.ofBuffer(materialCount)
        ));
            
            }
    }
    
    
    /**
     * Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)
     */
    public static Material loadMaterialDefault(
        ){
            
             return new Material(com.raylib.jextract.raylib_h.LoadMaterialDefault(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)
     */
    public static Material loadMaterialDefault(Arena arena 
        ){
            
             return new Material(com.raylib.jextract.raylib_h.LoadMaterialDefault(arena
            
        ));
            
            
    }
    
    
    /**
     * Check if a material is valid (shader assigned, map textures loaded in GPU)
     */
    public static boolean isMaterialValid(
            Material material 
        ){
            
            return com.raylib.jextract.raylib_h.IsMaterialValid(
            material.memorySegment
        );
            
    }
    
    
    /**
     * Unload material from GPU memory (VRAM)
     */
    public static void unloadMaterial(
            Material material 
        ){
            
            com.raylib.jextract.raylib_h.UnloadMaterial(
            material.memorySegment
        );
            
            
    }
    
    
    /**
     * Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)
     */
    public static void setMaterialTexture(
            Material material,  
            int mapType,  
            Texture texture 
        ){
            
            com.raylib.jextract.raylib_h.SetMaterialTexture(
            material.memorySegment, mapType, texture.memorySegment
        );
            
            
    }
    
    
    /**
     * Set material for a mesh
     */
    public static void setModelMeshMaterial(
            Model model,  
            int meshId,  
            int materialId 
        ){
            
            com.raylib.jextract.raylib_h.SetModelMeshMaterial(
            model.memorySegment, meshId, materialId
        );
            
            
    }
    
    
    /**
     * Load model animations from file
     */
    public static ModelAnimation loadModelAnimations(
            String fileName,  
            java.nio.IntBuffer animCount 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new ModelAnimation(com.raylib.jextract.raylib_h.LoadModelAnimations(
            localArena.allocateFrom(fileName), animCount == null ? MemorySegment.NULL : MemorySegment.ofBuffer(animCount)
        ));
            
            }
    }
    
    
    /**
     * Update model animation pose (CPU)
     */
    public static void updateModelAnimation(
            Model model,  
            ModelAnimation anim,  
            int frame 
        ){
            
            com.raylib.jextract.raylib_h.UpdateModelAnimation(
            model.memorySegment, anim.memorySegment, frame
        );
            
            
    }
    
    
    /**
     * Update model animation mesh bone matrices (GPU skinning)
     */
    public static void updateModelAnimationBones(
            Model model,  
            ModelAnimation anim,  
            int frame 
        ){
            
            com.raylib.jextract.raylib_h.UpdateModelAnimationBones(
            model.memorySegment, anim.memorySegment, frame
        );
            
            
    }
    
    
    /**
     * Unload animation data
     */
    public static void unloadModelAnimation(
            ModelAnimation anim 
        ){
            
            com.raylib.jextract.raylib_h.UnloadModelAnimation(
            anim.memorySegment
        );
            
            
    }
    
    
    /**
     * Unload animation array data
     */
    public static void unloadModelAnimations(
            ModelAnimation animations,  
            int animCount 
        ){
            
            com.raylib.jextract.raylib_h.UnloadModelAnimations(
            animations.memorySegment, animCount
        );
            
            
    }
    
    
    /**
     * Check model animation skeleton match
     */
    public static boolean isModelAnimationValid(
            Model model,  
            ModelAnimation anim 
        ){
            
            return com.raylib.jextract.raylib_h.IsModelAnimationValid(
            model.memorySegment, anim.memorySegment
        );
            
    }
    
    
    /**
     * Check collision between two spheres
     */
    public static boolean checkCollisionSpheres(
            Vector3 center1,  
            float radius1,  
            Vector3 center2,  
            float radius2 
        ){
            
            return com.raylib.jextract.raylib_h.CheckCollisionSpheres(
            center1.memorySegment, radius1, center2.memorySegment, radius2
        );
            
    }
    
    
    /**
     * Check collision between two bounding boxes
     */
    public static boolean checkCollisionBoxes(
            BoundingBox box1,  
            BoundingBox box2 
        ){
            
            return com.raylib.jextract.raylib_h.CheckCollisionBoxes(
            box1.memorySegment, box2.memorySegment
        );
            
    }
    
    
    /**
     * Check collision between box and sphere
     */
    public static boolean checkCollisionBoxSphere(
            BoundingBox box,  
            Vector3 center,  
            float radius 
        ){
            
            return com.raylib.jextract.raylib_h.CheckCollisionBoxSphere(
            box.memorySegment, center.memorySegment, radius
        );
            
    }
    
    
    /**
     * Get collision info between ray and sphere
     */
    public static RayCollision getRayCollisionSphere(
            Ray ray,  
            Vector3 center,  
            float radius 
        ){
            
             return new RayCollision(com.raylib.jextract.raylib_h.GetRayCollisionSphere(Arena.ofAuto(), 
            ray.memorySegment, center.memorySegment, radius
        ));
            
            
    }
    
    /**
     * Get collision info between ray and sphere
     */
    public static RayCollision getRayCollisionSphere(Arena arena,  
            Ray ray,  
            Vector3 center,  
            float radius 
        ){
            
             return new RayCollision(com.raylib.jextract.raylib_h.GetRayCollisionSphere(arena, 
            ray.memorySegment, center.memorySegment, radius
        ));
            
            
    }
    
    
    /**
     * Get collision info between ray and box
     */
    public static RayCollision getRayCollisionBox(
            Ray ray,  
            BoundingBox box 
        ){
            
             return new RayCollision(com.raylib.jextract.raylib_h.GetRayCollisionBox(Arena.ofAuto(), 
            ray.memorySegment, box.memorySegment
        ));
            
            
    }
    
    /**
     * Get collision info between ray and box
     */
    public static RayCollision getRayCollisionBox(Arena arena,  
            Ray ray,  
            BoundingBox box 
        ){
            
             return new RayCollision(com.raylib.jextract.raylib_h.GetRayCollisionBox(arena, 
            ray.memorySegment, box.memorySegment
        ));
            
            
    }
    
    
    /**
     * Get collision info between ray and mesh
     */
    public static RayCollision getRayCollisionMesh(
            Ray ray,  
            Mesh mesh,  
            Matrix transform 
        ){
            
             return new RayCollision(com.raylib.jextract.raylib_h.GetRayCollisionMesh(Arena.ofAuto(), 
            ray.memorySegment, mesh.memorySegment, transform.memorySegment
        ));
            
            
    }
    
    /**
     * Get collision info between ray and mesh
     */
    public static RayCollision getRayCollisionMesh(Arena arena,  
            Ray ray,  
            Mesh mesh,  
            Matrix transform 
        ){
            
             return new RayCollision(com.raylib.jextract.raylib_h.GetRayCollisionMesh(arena, 
            ray.memorySegment, mesh.memorySegment, transform.memorySegment
        ));
            
            
    }
    
    
    /**
     * Get collision info between ray and triangle
     */
    public static RayCollision getRayCollisionTriangle(
            Ray ray,  
            Vector3 p1,  
            Vector3 p2,  
            Vector3 p3 
        ){
            
             return new RayCollision(com.raylib.jextract.raylib_h.GetRayCollisionTriangle(Arena.ofAuto(), 
            ray.memorySegment, p1.memorySegment, p2.memorySegment, p3.memorySegment
        ));
            
            
    }
    
    /**
     * Get collision info between ray and triangle
     */
    public static RayCollision getRayCollisionTriangle(Arena arena,  
            Ray ray,  
            Vector3 p1,  
            Vector3 p2,  
            Vector3 p3 
        ){
            
             return new RayCollision(com.raylib.jextract.raylib_h.GetRayCollisionTriangle(arena, 
            ray.memorySegment, p1.memorySegment, p2.memorySegment, p3.memorySegment
        ));
            
            
    }
    
    
    /**
     * Get collision info between ray and quad
     */
    public static RayCollision getRayCollisionQuad(
            Ray ray,  
            Vector3 p1,  
            Vector3 p2,  
            Vector3 p3,  
            Vector3 p4 
        ){
            
             return new RayCollision(com.raylib.jextract.raylib_h.GetRayCollisionQuad(Arena.ofAuto(), 
            ray.memorySegment, p1.memorySegment, p2.memorySegment, p3.memorySegment, p4.memorySegment
        ));
            
            
    }
    
    /**
     * Get collision info between ray and quad
     */
    public static RayCollision getRayCollisionQuad(Arena arena,  
            Ray ray,  
            Vector3 p1,  
            Vector3 p2,  
            Vector3 p3,  
            Vector3 p4 
        ){
            
             return new RayCollision(com.raylib.jextract.raylib_h.GetRayCollisionQuad(arena, 
            ray.memorySegment, p1.memorySegment, p2.memorySegment, p3.memorySegment, p4.memorySegment
        ));
            
            
    }
    
    
    /**
     * Initialize audio device and context
     */
    public static void initAudioDevice(
        ){
            
            com.raylib.jextract.raylib_h.InitAudioDevice(
            
        );
            
            
    }
    
    
    /**
     * Close the audio device and context
     */
    public static void closeAudioDevice(
        ){
            
            com.raylib.jextract.raylib_h.CloseAudioDevice(
            
        );
            
            
    }
    
    
    /**
     * Check if audio device has been initialized successfully
     */
    public static boolean isAudioDeviceReady(
        ){
            
            return com.raylib.jextract.raylib_h.IsAudioDeviceReady(
            
        );
            
    }
    
    
    /**
     * Set master volume (listener)
     */
    public static void setMasterVolume(
            float volume 
        ){
            
            com.raylib.jextract.raylib_h.SetMasterVolume(
            volume
        );
            
            
    }
    
    
    /**
     * Get master volume (listener)
     */
    public static float getMasterVolume(
        ){
            
            return com.raylib.jextract.raylib_h.GetMasterVolume(
            
        );
            
    }
    
    
    /**
     * Load wave data from file
     */
    public static Wave loadWave(
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Wave(com.raylib.jextract.raylib_h.LoadWave(Arena.ofAuto(), 
            localArena.allocateFrom(fileName)
        ));
            
            }
    }
    
    /**
     * Load wave data from file
     */
    public static Wave loadWave(Arena arena,  
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Wave(com.raylib.jextract.raylib_h.LoadWave(arena, 
            localArena.allocateFrom(fileName)
        ));
            
            }
    }
    
    
    /**
     * Load wave from memory buffer, fileType refers to extension: i.e. '.wav'
     */
    public static Wave loadWaveFromMemory(
            String fileType,  
            java.nio.ByteBuffer fileData,  
            int dataSize 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Wave(com.raylib.jextract.raylib_h.LoadWaveFromMemory(Arena.ofAuto(), 
            localArena.allocateFrom(fileType), MemorySegment.ofBuffer(fileData), dataSize
        ));
            
            }
    }
    
    /**
     * Load wave from memory buffer, fileType refers to extension: i.e. '.wav'
     */
    public static Wave loadWaveFromMemory(Arena arena,  
            String fileType,  
            java.nio.ByteBuffer fileData,  
            int dataSize 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Wave(com.raylib.jextract.raylib_h.LoadWaveFromMemory(arena, 
            localArena.allocateFrom(fileType), MemorySegment.ofBuffer(fileData), dataSize
        ));
            
            }
    }
    
    
    /**
     * Checks if wave data is valid (data loaded and parameters)
     */
    public static boolean isWaveValid(
            Wave wave 
        ){
            
            return com.raylib.jextract.raylib_h.IsWaveValid(
            wave.memorySegment
        );
            
    }
    
    
    /**
     * Load sound from file
     */
    public static Sound loadSound(
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Sound(com.raylib.jextract.raylib_h.LoadSound(Arena.ofAuto(), 
            localArena.allocateFrom(fileName)
        ));
            
            }
    }
    
    /**
     * Load sound from file
     */
    public static Sound loadSound(Arena arena,  
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Sound(com.raylib.jextract.raylib_h.LoadSound(arena, 
            localArena.allocateFrom(fileName)
        ));
            
            }
    }
    
    
    /**
     * Load sound from wave data
     */
    public static Sound loadSoundFromWave(
            Wave wave 
        ){
            
             return new Sound(com.raylib.jextract.raylib_h.LoadSoundFromWave(Arena.ofAuto(), 
            wave.memorySegment
        ));
            
            
    }
    
    /**
     * Load sound from wave data
     */
    public static Sound loadSoundFromWave(Arena arena,  
            Wave wave 
        ){
            
             return new Sound(com.raylib.jextract.raylib_h.LoadSoundFromWave(arena, 
            wave.memorySegment
        ));
            
            
    }
    
    
    /**
     * Create a new sound that shares the same sample data as the source sound, does not own the sound data
     */
    public static Sound loadSoundAlias(
            Sound source 
        ){
            
             return new Sound(com.raylib.jextract.raylib_h.LoadSoundAlias(Arena.ofAuto(), 
            source.memorySegment
        ));
            
            
    }
    
    /**
     * Create a new sound that shares the same sample data as the source sound, does not own the sound data
     */
    public static Sound loadSoundAlias(Arena arena,  
            Sound source 
        ){
            
             return new Sound(com.raylib.jextract.raylib_h.LoadSoundAlias(arena, 
            source.memorySegment
        ));
            
            
    }
    
    
    /**
     * Checks if a sound is valid (data loaded and buffers initialized)
     */
    public static boolean isSoundValid(
            Sound sound 
        ){
            
            return com.raylib.jextract.raylib_h.IsSoundValid(
            sound.memorySegment
        );
            
    }
    
    
    /**
     * Update sound buffer with new data
     */
    public static void updateSound(
            Sound sound,  
            MemorySegment data,  
            int sampleCount 
        ){
            
            com.raylib.jextract.raylib_h.UpdateSound(
            sound.memorySegment, data, sampleCount
        );
            
            
    }
    
    
    /**
     * Unload wave data
     */
    public static void unloadWave(
            Wave wave 
        ){
            
            com.raylib.jextract.raylib_h.UnloadWave(
            wave.memorySegment
        );
            
            
    }
    
    
    /**
     * Unload sound
     */
    public static void unloadSound(
            Sound sound 
        ){
            
            com.raylib.jextract.raylib_h.UnloadSound(
            sound.memorySegment
        );
            
            
    }
    
    
    /**
     * Unload a sound alias (does not deallocate sample data)
     */
    public static void unloadSoundAlias(
            Sound alias 
        ){
            
            com.raylib.jextract.raylib_h.UnloadSoundAlias(
            alias.memorySegment
        );
            
            
    }
    
    
    /**
     * Export wave data to file, returns true on success
     */
    public static boolean exportWave(
            Wave wave,  
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.ExportWave(
            wave.memorySegment, localArena.allocateFrom(fileName)
        );
            }
    }
    
    
    /**
     * Export wave sample data to code (.h), returns true on success
     */
    public static boolean exportWaveAsCode(
            Wave wave,  
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.ExportWaveAsCode(
            wave.memorySegment, localArena.allocateFrom(fileName)
        );
            }
    }
    
    
    /**
     * Play a sound
     */
    public static void playSound(
            Sound sound 
        ){
            
            com.raylib.jextract.raylib_h.PlaySound(
            sound.memorySegment
        );
            
            
    }
    
    
    /**
     * Stop playing a sound
     */
    public static void stopSound(
            Sound sound 
        ){
            
            com.raylib.jextract.raylib_h.StopSound(
            sound.memorySegment
        );
            
            
    }
    
    
    /**
     * Pause a sound
     */
    public static void pauseSound(
            Sound sound 
        ){
            
            com.raylib.jextract.raylib_h.PauseSound(
            sound.memorySegment
        );
            
            
    }
    
    
    /**
     * Resume a paused sound
     */
    public static void resumeSound(
            Sound sound 
        ){
            
            com.raylib.jextract.raylib_h.ResumeSound(
            sound.memorySegment
        );
            
            
    }
    
    
    /**
     * Check if a sound is currently playing
     */
    public static boolean isSoundPlaying(
            Sound sound 
        ){
            
            return com.raylib.jextract.raylib_h.IsSoundPlaying(
            sound.memorySegment
        );
            
    }
    
    
    /**
     * Set volume for a sound (1.0 is max level)
     */
    public static void setSoundVolume(
            Sound sound,  
            float volume 
        ){
            
            com.raylib.jextract.raylib_h.SetSoundVolume(
            sound.memorySegment, volume
        );
            
            
    }
    
    
    /**
     * Set pitch for a sound (1.0 is base level)
     */
    public static void setSoundPitch(
            Sound sound,  
            float pitch 
        ){
            
            com.raylib.jextract.raylib_h.SetSoundPitch(
            sound.memorySegment, pitch
        );
            
            
    }
    
    
    /**
     * Set pan for a sound (0.5 is center)
     */
    public static void setSoundPan(
            Sound sound,  
            float pan 
        ){
            
            com.raylib.jextract.raylib_h.SetSoundPan(
            sound.memorySegment, pan
        );
            
            
    }
    
    
    /**
     * Copy a wave to a new wave
     */
    public static Wave waveCopy(
            Wave wave 
        ){
            
             return new Wave(com.raylib.jextract.raylib_h.WaveCopy(Arena.ofAuto(), 
            wave.memorySegment
        ));
            
            
    }
    
    /**
     * Copy a wave to a new wave
     */
    public static Wave waveCopy(Arena arena,  
            Wave wave 
        ){
            
             return new Wave(com.raylib.jextract.raylib_h.WaveCopy(arena, 
            wave.memorySegment
        ));
            
            
    }
    
    
    /**
     * Crop a wave to defined frames range
     */
    public static void waveCrop(
            Wave wave,  
            int initFrame,  
            int finalFrame 
        ){
            
            com.raylib.jextract.raylib_h.WaveCrop(
            wave.memorySegment, initFrame, finalFrame
        );
            
            
    }
    
    
    /**
     * Convert wave data to desired format
     */
    public static void waveFormat(
            Wave wave,  
            int sampleRate,  
            int sampleSize,  
            int channels 
        ){
            
            com.raylib.jextract.raylib_h.WaveFormat(
            wave.memorySegment, sampleRate, sampleSize, channels
        );
            
            
    }
    
    
    /**
     * Load samples data from wave as a 32bit float data array
     */
    public static java.nio.FloatBuffer loadWaveSamples(
            Wave wave 
        ){
            
            return com.raylib.jextract.raylib_h.LoadWaveSamples(
            wave.memorySegment
        ).reinterpret(Integer.MAX_VALUE/2).asByteBuffer().order(ByteOrder.nativeOrder()).asFloatBuffer();
            
    }
    
    
    /**
     * Unload samples data loaded with LoadWaveSamples()
     */
    public static void unloadWaveSamples(
            java.nio.FloatBuffer samples 
        ){
            
            com.raylib.jextract.raylib_h.UnloadWaveSamples(
            MemorySegment.ofBuffer(samples)
        );
            
            
    }
    
    
    /**
     * Load music stream from file
     */
    public static Music loadMusicStream(
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Music(com.raylib.jextract.raylib_h.LoadMusicStream(Arena.ofAuto(), 
            localArena.allocateFrom(fileName)
        ));
            
            }
    }
    
    /**
     * Load music stream from file
     */
    public static Music loadMusicStream(Arena arena,  
            String fileName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Music(com.raylib.jextract.raylib_h.LoadMusicStream(arena, 
            localArena.allocateFrom(fileName)
        ));
            
            }
    }
    
    
    /**
     * Load music stream from data
     */
    public static Music loadMusicStreamFromMemory(
            String fileType,  
            java.nio.ByteBuffer data,  
            int dataSize 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Music(com.raylib.jextract.raylib_h.LoadMusicStreamFromMemory(Arena.ofAuto(), 
            localArena.allocateFrom(fileType), MemorySegment.ofBuffer(data), dataSize
        ));
            
            }
    }
    
    /**
     * Load music stream from data
     */
    public static Music loadMusicStreamFromMemory(Arena arena,  
            String fileType,  
            java.nio.ByteBuffer data,  
            int dataSize 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
             return new Music(com.raylib.jextract.raylib_h.LoadMusicStreamFromMemory(arena, 
            localArena.allocateFrom(fileType), MemorySegment.ofBuffer(data), dataSize
        ));
            
            }
    }
    
    
    /**
     * Checks if a music stream is valid (context and buffers initialized)
     */
    public static boolean isMusicValid(
            Music music 
        ){
            
            return com.raylib.jextract.raylib_h.IsMusicValid(
            music.memorySegment
        );
            
    }
    
    
    /**
     * Unload music stream
     */
    public static void unloadMusicStream(
            Music music 
        ){
            
            com.raylib.jextract.raylib_h.UnloadMusicStream(
            music.memorySegment
        );
            
            
    }
    
    
    /**
     * Start music playing
     */
    public static void playMusicStream(
            Music music 
        ){
            
            com.raylib.jextract.raylib_h.PlayMusicStream(
            music.memorySegment
        );
            
            
    }
    
    
    /**
     * Check if music is playing
     */
    public static boolean isMusicStreamPlaying(
            Music music 
        ){
            
            return com.raylib.jextract.raylib_h.IsMusicStreamPlaying(
            music.memorySegment
        );
            
    }
    
    
    /**
     * Updates buffers for music streaming
     */
    public static void updateMusicStream(
            Music music 
        ){
            
            com.raylib.jextract.raylib_h.UpdateMusicStream(
            music.memorySegment
        );
            
            
    }
    
    
    /**
     * Stop music playing
     */
    public static void stopMusicStream(
            Music music 
        ){
            
            com.raylib.jextract.raylib_h.StopMusicStream(
            music.memorySegment
        );
            
            
    }
    
    
    /**
     * Pause music playing
     */
    public static void pauseMusicStream(
            Music music 
        ){
            
            com.raylib.jextract.raylib_h.PauseMusicStream(
            music.memorySegment
        );
            
            
    }
    
    
    /**
     * Resume playing paused music
     */
    public static void resumeMusicStream(
            Music music 
        ){
            
            com.raylib.jextract.raylib_h.ResumeMusicStream(
            music.memorySegment
        );
            
            
    }
    
    
    /**
     * Seek music to a position (in seconds)
     */
    public static void seekMusicStream(
            Music music,  
            float position 
        ){
            
            com.raylib.jextract.raylib_h.SeekMusicStream(
            music.memorySegment, position
        );
            
            
    }
    
    
    /**
     * Set volume for music (1.0 is max level)
     */
    public static void setMusicVolume(
            Music music,  
            float volume 
        ){
            
            com.raylib.jextract.raylib_h.SetMusicVolume(
            music.memorySegment, volume
        );
            
            
    }
    
    
    /**
     * Set pitch for a music (1.0 is base level)
     */
    public static void setMusicPitch(
            Music music,  
            float pitch 
        ){
            
            com.raylib.jextract.raylib_h.SetMusicPitch(
            music.memorySegment, pitch
        );
            
            
    }
    
    
    /**
     * Set pan for a music (0.5 is center)
     */
    public static void setMusicPan(
            Music music,  
            float pan 
        ){
            
            com.raylib.jextract.raylib_h.SetMusicPan(
            music.memorySegment, pan
        );
            
            
    }
    
    
    /**
     * Get music time length (in seconds)
     */
    public static float getMusicTimeLength(
            Music music 
        ){
            
            return com.raylib.jextract.raylib_h.GetMusicTimeLength(
            music.memorySegment
        );
            
    }
    
    
    /**
     * Get current music time played (in seconds)
     */
    public static float getMusicTimePlayed(
            Music music 
        ){
            
            return com.raylib.jextract.raylib_h.GetMusicTimePlayed(
            music.memorySegment
        );
            
    }
    
    
    /**
     * Load audio stream (to stream raw audio pcm data)
     */
    public static AudioStream loadAudioStream(
            int sampleRate,  
            int sampleSize,  
            int channels 
        ){
            
             return new AudioStream(com.raylib.jextract.raylib_h.LoadAudioStream(Arena.ofAuto(), 
            sampleRate, sampleSize, channels
        ));
            
            
    }
    
    /**
     * Load audio stream (to stream raw audio pcm data)
     */
    public static AudioStream loadAudioStream(Arena arena,  
            int sampleRate,  
            int sampleSize,  
            int channels 
        ){
            
             return new AudioStream(com.raylib.jextract.raylib_h.LoadAudioStream(arena, 
            sampleRate, sampleSize, channels
        ));
            
            
    }
    
    
    /**
     * Checks if an audio stream is valid (buffers initialized)
     */
    public static boolean isAudioStreamValid(
            AudioStream stream 
        ){
            
            return com.raylib.jextract.raylib_h.IsAudioStreamValid(
            stream.memorySegment
        );
            
    }
    
    
    /**
     * Unload audio stream and free memory
     */
    public static void unloadAudioStream(
            AudioStream stream 
        ){
            
            com.raylib.jextract.raylib_h.UnloadAudioStream(
            stream.memorySegment
        );
            
            
    }
    
    
    /**
     * Update audio stream buffers with data
     */
    public static void updateAudioStream(
            AudioStream stream,  
            MemorySegment data,  
            int frameCount 
        ){
            
            com.raylib.jextract.raylib_h.UpdateAudioStream(
            stream.memorySegment, data, frameCount
        );
            
            
    }
    
    
    /**
     * Check if any audio stream buffers requires refill
     */
    public static boolean isAudioStreamProcessed(
            AudioStream stream 
        ){
            
            return com.raylib.jextract.raylib_h.IsAudioStreamProcessed(
            stream.memorySegment
        );
            
    }
    
    
    /**
     * Play audio stream
     */
    public static void playAudioStream(
            AudioStream stream 
        ){
            
            com.raylib.jextract.raylib_h.PlayAudioStream(
            stream.memorySegment
        );
            
            
    }
    
    
    /**
     * Pause audio stream
     */
    public static void pauseAudioStream(
            AudioStream stream 
        ){
            
            com.raylib.jextract.raylib_h.PauseAudioStream(
            stream.memorySegment
        );
            
            
    }
    
    
    /**
     * Resume audio stream
     */
    public static void resumeAudioStream(
            AudioStream stream 
        ){
            
            com.raylib.jextract.raylib_h.ResumeAudioStream(
            stream.memorySegment
        );
            
            
    }
    
    
    /**
     * Check if audio stream is playing
     */
    public static boolean isAudioStreamPlaying(
            AudioStream stream 
        ){
            
            return com.raylib.jextract.raylib_h.IsAudioStreamPlaying(
            stream.memorySegment
        );
            
    }
    
    
    /**
     * Stop audio stream
     */
    public static void stopAudioStream(
            AudioStream stream 
        ){
            
            com.raylib.jextract.raylib_h.StopAudioStream(
            stream.memorySegment
        );
            
            
    }
    
    
    /**
     * Set volume for audio stream (1.0 is max level)
     */
    public static void setAudioStreamVolume(
            AudioStream stream,  
            float volume 
        ){
            
            com.raylib.jextract.raylib_h.SetAudioStreamVolume(
            stream.memorySegment, volume
        );
            
            
    }
    
    
    /**
     * Set pitch for audio stream (1.0 is base level)
     */
    public static void setAudioStreamPitch(
            AudioStream stream,  
            float pitch 
        ){
            
            com.raylib.jextract.raylib_h.SetAudioStreamPitch(
            stream.memorySegment, pitch
        );
            
            
    }
    
    
    /**
     * Set pan for audio stream (0.5 is centered)
     */
    public static void setAudioStreamPan(
            AudioStream stream,  
            float pan 
        ){
            
            com.raylib.jextract.raylib_h.SetAudioStreamPan(
            stream.memorySegment, pan
        );
            
            
    }
    
    
    /**
     * Default size for new audio streams
     */
    public static void setAudioStreamBufferSizeDefault(
            int size 
        ){
            
            com.raylib.jextract.raylib_h.SetAudioStreamBufferSizeDefault(
            size
        );
            
            
    }
    
    
    /**
     * Audio thread callback to request new data
     */
    public static void setAudioStreamCallback(
            AudioStream stream,  
            MemorySegment callback 
        ){
            
            com.raylib.jextract.raylib_h.SetAudioStreamCallback(
            stream.memorySegment, callback
        );
            
            
    }
    
    
    /**
     * Attach audio stream processor to stream, receives the samples as 'float'
     */
    public static void attachAudioStreamProcessor(
            AudioStream stream,  
            MemorySegment processor 
        ){
            
            com.raylib.jextract.raylib_h.AttachAudioStreamProcessor(
            stream.memorySegment, processor
        );
            
            
    }
    
    
    /**
     * Detach audio stream processor from stream
     */
    public static void detachAudioStreamProcessor(
            AudioStream stream,  
            MemorySegment processor 
        ){
            
            com.raylib.jextract.raylib_h.DetachAudioStreamProcessor(
            stream.memorySegment, processor
        );
            
            
    }
    
    
    /**
     * Attach audio stream processor to the entire audio pipeline, receives the samples as 'float'
     */
    public static void attachAudioMixedProcessor(
            MemorySegment processor 
        ){
            
            com.raylib.jextract.raylib_h.AttachAudioMixedProcessor(
            processor
        );
            
            
    }
    
    
    /**
     * Detach audio stream processor from the entire audio pipeline
     */
    public static void detachAudioMixedProcessor(
            MemorySegment processor 
        ){
            
            com.raylib.jextract.raylib_h.DetachAudioMixedProcessor(
            processor
        );
            
            
    }
    
    
    /**
     * 
     */
    public static float clamp(
            float value,  
            float min,  
            float max 
        ){
            
            return com.raylib.jextract.raylib_h.Clamp(
            value, min, max
        );
            
    }
    
    
    /**
     * 
     */
    public static float lerp(
            float start,  
            float end,  
            float amount 
        ){
            
            return com.raylib.jextract.raylib_h.Lerp(
            start, end, amount
        );
            
    }
    
    
    /**
     * 
     */
    public static float normalize(
            float value,  
            float start,  
            float end 
        ){
            
            return com.raylib.jextract.raylib_h.Normalize(
            value, start, end
        );
            
    }
    
    
    /**
     * 
     */
    public static float remap(
            float value,  
            float inputStart,  
            float inputEnd,  
            float outputStart,  
            float outputEnd 
        ){
            
            return com.raylib.jextract.raylib_h.Remap(
            value, inputStart, inputEnd, outputStart, outputEnd
        );
            
    }
    
    
    /**
     * 
     */
    public static float wrap(
            float value,  
            float min,  
            float max 
        ){
            
            return com.raylib.jextract.raylib_h.Wrap(
            value, min, max
        );
            
    }
    
    
    /**
     * 
     */
    public static int floatEquals(
            float x,  
            float y 
        ){
            
            return com.raylib.jextract.raylib_h.FloatEquals(
            x, y
        );
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2Zero(
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Zero(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2Zero(Arena arena 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Zero(arena
            
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2One(
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2One(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2One(Arena arena 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2One(arena
            
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2Add(
            Vector2 v1,  
            Vector2 v2 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Add(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2Add(Arena arena,  
            Vector2 v1,  
            Vector2 v2 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Add(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2AddValue(
            Vector2 v,  
            float add 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2AddValue(Arena.ofAuto(), 
            v.memorySegment, add
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2AddValue(Arena arena,  
            Vector2 v,  
            float add 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2AddValue(arena, 
            v.memorySegment, add
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2Subtract(
            Vector2 v1,  
            Vector2 v2 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Subtract(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2Subtract(Arena arena,  
            Vector2 v1,  
            Vector2 v2 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Subtract(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2SubtractValue(
            Vector2 v,  
            float sub 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2SubtractValue(Arena.ofAuto(), 
            v.memorySegment, sub
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2SubtractValue(Arena arena,  
            Vector2 v,  
            float sub 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2SubtractValue(arena, 
            v.memorySegment, sub
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static float vector2Length(
            Vector2 v 
        ){
            
            return com.raylib.jextract.raylib_h.Vector2Length(
            v.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static float vector2LengthSqr(
            Vector2 v 
        ){
            
            return com.raylib.jextract.raylib_h.Vector2LengthSqr(
            v.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static float vector2DotProduct(
            Vector2 v1,  
            Vector2 v2 
        ){
            
            return com.raylib.jextract.raylib_h.Vector2DotProduct(
            v1.memorySegment, v2.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static float vector2Distance(
            Vector2 v1,  
            Vector2 v2 
        ){
            
            return com.raylib.jextract.raylib_h.Vector2Distance(
            v1.memorySegment, v2.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static float vector2DistanceSqr(
            Vector2 v1,  
            Vector2 v2 
        ){
            
            return com.raylib.jextract.raylib_h.Vector2DistanceSqr(
            v1.memorySegment, v2.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static float vector2Angle(
            Vector2 v1,  
            Vector2 v2 
        ){
            
            return com.raylib.jextract.raylib_h.Vector2Angle(
            v1.memorySegment, v2.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static float vector2LineAngle(
            Vector2 start,  
            Vector2 end 
        ){
            
            return com.raylib.jextract.raylib_h.Vector2LineAngle(
            start.memorySegment, end.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2Scale(
            Vector2 v,  
            float scale 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Scale(Arena.ofAuto(), 
            v.memorySegment, scale
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2Scale(Arena arena,  
            Vector2 v,  
            float scale 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Scale(arena, 
            v.memorySegment, scale
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2Multiply(
            Vector2 v1,  
            Vector2 v2 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Multiply(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2Multiply(Arena arena,  
            Vector2 v1,  
            Vector2 v2 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Multiply(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2Negate(
            Vector2 v 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Negate(Arena.ofAuto(), 
            v.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2Negate(Arena arena,  
            Vector2 v 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Negate(arena, 
            v.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2Divide(
            Vector2 v1,  
            Vector2 v2 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Divide(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2Divide(Arena arena,  
            Vector2 v1,  
            Vector2 v2 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Divide(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2Normalize(
            Vector2 v 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Normalize(Arena.ofAuto(), 
            v.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2Normalize(Arena arena,  
            Vector2 v 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Normalize(arena, 
            v.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2Transform(
            Vector2 v,  
            Matrix mat 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Transform(Arena.ofAuto(), 
            v.memorySegment, mat.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2Transform(Arena arena,  
            Vector2 v,  
            Matrix mat 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Transform(arena, 
            v.memorySegment, mat.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2Lerp(
            Vector2 v1,  
            Vector2 v2,  
            float amount 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Lerp(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment, amount
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2Lerp(Arena arena,  
            Vector2 v1,  
            Vector2 v2,  
            float amount 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Lerp(arena, 
            v1.memorySegment, v2.memorySegment, amount
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2Reflect(
            Vector2 v,  
            Vector2 normal 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Reflect(Arena.ofAuto(), 
            v.memorySegment, normal.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2Reflect(Arena arena,  
            Vector2 v,  
            Vector2 normal 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Reflect(arena, 
            v.memorySegment, normal.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2Min(
            Vector2 v1,  
            Vector2 v2 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Min(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2Min(Arena arena,  
            Vector2 v1,  
            Vector2 v2 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Min(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2Max(
            Vector2 v1,  
            Vector2 v2 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Max(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2Max(Arena arena,  
            Vector2 v1,  
            Vector2 v2 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Max(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2Rotate(
            Vector2 v,  
            float angle 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Rotate(Arena.ofAuto(), 
            v.memorySegment, angle
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2Rotate(Arena arena,  
            Vector2 v,  
            float angle 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Rotate(arena, 
            v.memorySegment, angle
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2MoveTowards(
            Vector2 v,  
            Vector2 target,  
            float maxDistance 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2MoveTowards(Arena.ofAuto(), 
            v.memorySegment, target.memorySegment, maxDistance
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2MoveTowards(Arena arena,  
            Vector2 v,  
            Vector2 target,  
            float maxDistance 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2MoveTowards(arena, 
            v.memorySegment, target.memorySegment, maxDistance
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2Invert(
            Vector2 v 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Invert(Arena.ofAuto(), 
            v.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2Invert(Arena arena,  
            Vector2 v 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Invert(arena, 
            v.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2Clamp(
            Vector2 v,  
            Vector2 min,  
            Vector2 max 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Clamp(Arena.ofAuto(), 
            v.memorySegment, min.memorySegment, max.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2Clamp(Arena arena,  
            Vector2 v,  
            Vector2 min,  
            Vector2 max 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Clamp(arena, 
            v.memorySegment, min.memorySegment, max.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2ClampValue(
            Vector2 v,  
            float min,  
            float max 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2ClampValue(Arena.ofAuto(), 
            v.memorySegment, min, max
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2ClampValue(Arena arena,  
            Vector2 v,  
            float min,  
            float max 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2ClampValue(arena, 
            v.memorySegment, min, max
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static int vector2Equals(
            Vector2 p,  
            Vector2 q 
        ){
            
            return com.raylib.jextract.raylib_h.Vector2Equals(
            p.memorySegment, q.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static Vector2 vector2Refract(
            Vector2 v,  
            Vector2 n,  
            float r 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Refract(Arena.ofAuto(), 
            v.memorySegment, n.memorySegment, r
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector2 vector2Refract(Arena arena,  
            Vector2 v,  
            Vector2 n,  
            float r 
        ){
            
             return new Vector2(com.raylib.jextract.raylib_h.Vector2Refract(arena, 
            v.memorySegment, n.memorySegment, r
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Zero(
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Zero(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Zero(Arena arena 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Zero(arena
            
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3One(
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3One(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3One(Arena arena 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3One(arena
            
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Add(
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Add(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Add(Arena arena,  
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Add(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3AddValue(
            Vector3 v,  
            float add 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3AddValue(Arena.ofAuto(), 
            v.memorySegment, add
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3AddValue(Arena arena,  
            Vector3 v,  
            float add 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3AddValue(arena, 
            v.memorySegment, add
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Subtract(
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Subtract(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Subtract(Arena arena,  
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Subtract(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3SubtractValue(
            Vector3 v,  
            float sub 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3SubtractValue(Arena.ofAuto(), 
            v.memorySegment, sub
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3SubtractValue(Arena arena,  
            Vector3 v,  
            float sub 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3SubtractValue(arena, 
            v.memorySegment, sub
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Scale(
            Vector3 v,  
            float scalar 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Scale(Arena.ofAuto(), 
            v.memorySegment, scalar
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Scale(Arena arena,  
            Vector3 v,  
            float scalar 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Scale(arena, 
            v.memorySegment, scalar
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Multiply(
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Multiply(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Multiply(Arena arena,  
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Multiply(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3CrossProduct(
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3CrossProduct(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3CrossProduct(Arena arena,  
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3CrossProduct(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Perpendicular(
            Vector3 v 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Perpendicular(Arena.ofAuto(), 
            v.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Perpendicular(Arena arena,  
            Vector3 v 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Perpendicular(arena, 
            v.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static float vector3Length(
            MemorySegment v 
        ){
            
            return com.raylib.jextract.raylib_h.Vector3Length(
            v
        );
            
    }
    
    
    /**
     * 
     */
    public static float vector3LengthSqr(
            MemorySegment v 
        ){
            
            return com.raylib.jextract.raylib_h.Vector3LengthSqr(
            v
        );
            
    }
    
    
    /**
     * 
     */
    public static float vector3DotProduct(
            Vector3 v1,  
            Vector3 v2 
        ){
            
            return com.raylib.jextract.raylib_h.Vector3DotProduct(
            v1.memorySegment, v2.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static float vector3Distance(
            Vector3 v1,  
            Vector3 v2 
        ){
            
            return com.raylib.jextract.raylib_h.Vector3Distance(
            v1.memorySegment, v2.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static float vector3DistanceSqr(
            Vector3 v1,  
            Vector3 v2 
        ){
            
            return com.raylib.jextract.raylib_h.Vector3DistanceSqr(
            v1.memorySegment, v2.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static float vector3Angle(
            Vector3 v1,  
            Vector3 v2 
        ){
            
            return com.raylib.jextract.raylib_h.Vector3Angle(
            v1.memorySegment, v2.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Negate(
            Vector3 v 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Negate(Arena.ofAuto(), 
            v.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Negate(Arena arena,  
            Vector3 v 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Negate(arena, 
            v.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Divide(
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Divide(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Divide(Arena arena,  
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Divide(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Normalize(
            Vector3 v 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Normalize(Arena.ofAuto(), 
            v.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Normalize(Arena arena,  
            Vector3 v 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Normalize(arena, 
            v.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Project(
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Project(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Project(Arena arena,  
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Project(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Reject(
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Reject(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Reject(Arena arena,  
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Reject(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static void vector3OrthoNormalize(
            Vector3 v1,  
            Vector3 v2 
        ){
            
            com.raylib.jextract.raylib_h.Vector3OrthoNormalize(
            v1.memorySegment, v2.memorySegment
        );
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Transform(
            Vector3 v,  
            Matrix mat 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Transform(Arena.ofAuto(), 
            v.memorySegment, mat.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Transform(Arena arena,  
            Vector3 v,  
            Matrix mat 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Transform(arena, 
            v.memorySegment, mat.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3RotateByQuaternion(
            Vector3 v,  
            Vector4 q 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3RotateByQuaternion(Arena.ofAuto(), 
            v.memorySegment, q.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3RotateByQuaternion(Arena arena,  
            Vector3 v,  
            Vector4 q 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3RotateByQuaternion(arena, 
            v.memorySegment, q.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3RotateByAxisAngle(
            Vector3 v,  
            Vector3 axis,  
            float angle 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3RotateByAxisAngle(Arena.ofAuto(), 
            v.memorySegment, axis.memorySegment, angle
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3RotateByAxisAngle(Arena arena,  
            Vector3 v,  
            Vector3 axis,  
            float angle 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3RotateByAxisAngle(arena, 
            v.memorySegment, axis.memorySegment, angle
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3MoveTowards(
            Vector3 v,  
            Vector3 target,  
            float maxDistance 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3MoveTowards(Arena.ofAuto(), 
            v.memorySegment, target.memorySegment, maxDistance
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3MoveTowards(Arena arena,  
            Vector3 v,  
            Vector3 target,  
            float maxDistance 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3MoveTowards(arena, 
            v.memorySegment, target.memorySegment, maxDistance
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Lerp(
            Vector3 v1,  
            Vector3 v2,  
            float amount 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Lerp(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment, amount
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Lerp(Arena arena,  
            Vector3 v1,  
            Vector3 v2,  
            float amount 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Lerp(arena, 
            v1.memorySegment, v2.memorySegment, amount
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3CubicHermite(
            Vector3 v1,  
            Vector3 tangent1,  
            Vector3 v2,  
            Vector3 tangent2,  
            float amount 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3CubicHermite(Arena.ofAuto(), 
            v1.memorySegment, tangent1.memorySegment, v2.memorySegment, tangent2.memorySegment, amount
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3CubicHermite(Arena arena,  
            Vector3 v1,  
            Vector3 tangent1,  
            Vector3 v2,  
            Vector3 tangent2,  
            float amount 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3CubicHermite(arena, 
            v1.memorySegment, tangent1.memorySegment, v2.memorySegment, tangent2.memorySegment, amount
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Reflect(
            Vector3 v,  
            Vector3 normal 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Reflect(Arena.ofAuto(), 
            v.memorySegment, normal.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Reflect(Arena arena,  
            Vector3 v,  
            Vector3 normal 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Reflect(arena, 
            v.memorySegment, normal.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Min(
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Min(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Min(Arena arena,  
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Min(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Max(
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Max(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Max(Arena arena,  
            Vector3 v1,  
            Vector3 v2 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Max(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Barycenter(
            Vector3 p,  
            Vector3 a,  
            Vector3 b,  
            Vector3 c 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Barycenter(Arena.ofAuto(), 
            p.memorySegment, a.memorySegment, b.memorySegment, c.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Barycenter(Arena arena,  
            Vector3 p,  
            Vector3 a,  
            Vector3 b,  
            Vector3 c 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Barycenter(arena, 
            p.memorySegment, a.memorySegment, b.memorySegment, c.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Unproject(
            Vector3 source,  
            Matrix projection,  
            Matrix view 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Unproject(Arena.ofAuto(), 
            source.memorySegment, projection.memorySegment, view.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Unproject(Arena arena,  
            Vector3 source,  
            Matrix projection,  
            Matrix view 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Unproject(arena, 
            source.memorySegment, projection.memorySegment, view.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static MemorySegment vector3ToFloatV(
            Vector3 v 
        ){
            
            return com.raylib.jextract.raylib_h.Vector3ToFloatV(Arena.ofAuto(), 
            v.memorySegment
        );
            
    }
    
    /**
     * 
     */
    public static MemorySegment vector3ToFloatV(Arena arena,  
            Vector3 v 
        ){
            
            return com.raylib.jextract.raylib_h.Vector3ToFloatV(Arena.ofAuto(), 
            v.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Invert(
            Vector3 v 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Invert(Arena.ofAuto(), 
            v.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Invert(Arena arena,  
            Vector3 v 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Invert(arena, 
            v.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Clamp(
            Vector3 v,  
            Vector3 min,  
            Vector3 max 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Clamp(Arena.ofAuto(), 
            v.memorySegment, min.memorySegment, max.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Clamp(Arena arena,  
            Vector3 v,  
            Vector3 min,  
            Vector3 max 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Clamp(arena, 
            v.memorySegment, min.memorySegment, max.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3ClampValue(
            Vector3 v,  
            float min,  
            float max 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3ClampValue(Arena.ofAuto(), 
            v.memorySegment, min, max
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3ClampValue(Arena arena,  
            Vector3 v,  
            float min,  
            float max 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3ClampValue(arena, 
            v.memorySegment, min, max
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static int vector3Equals(
            Vector3 p,  
            Vector3 q 
        ){
            
            return com.raylib.jextract.raylib_h.Vector3Equals(
            p.memorySegment, q.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static Vector3 vector3Refract(
            Vector3 v,  
            Vector3 n,  
            float r 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Refract(Arena.ofAuto(), 
            v.memorySegment, n.memorySegment, r
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 vector3Refract(Arena arena,  
            Vector3 v,  
            Vector3 n,  
            float r 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.Vector3Refract(arena, 
            v.memorySegment, n.memorySegment, r
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 vector4Zero(
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Zero(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 vector4Zero(Arena arena 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Zero(arena
            
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 vector4One(
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4One(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 vector4One(Arena arena 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4One(arena
            
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 vector4Add(
            Vector4 v1,  
            Vector4 v2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Add(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 vector4Add(Arena arena,  
            Vector4 v1,  
            Vector4 v2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Add(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 vector4AddValue(
            Vector4 v,  
            float add 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4AddValue(Arena.ofAuto(), 
            v.memorySegment, add
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 vector4AddValue(Arena arena,  
            Vector4 v,  
            float add 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4AddValue(arena, 
            v.memorySegment, add
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 vector4Subtract(
            Vector4 v1,  
            Vector4 v2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Subtract(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 vector4Subtract(Arena arena,  
            Vector4 v1,  
            Vector4 v2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Subtract(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 vector4SubtractValue(
            Vector4 v,  
            float add 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4SubtractValue(Arena.ofAuto(), 
            v.memorySegment, add
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 vector4SubtractValue(Arena arena,  
            Vector4 v,  
            float add 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4SubtractValue(arena, 
            v.memorySegment, add
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static float vector4Length(
            Vector4 v 
        ){
            
            return com.raylib.jextract.raylib_h.Vector4Length(
            v.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static float vector4LengthSqr(
            Vector4 v 
        ){
            
            return com.raylib.jextract.raylib_h.Vector4LengthSqr(
            v.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static float vector4DotProduct(
            Vector4 v1,  
            Vector4 v2 
        ){
            
            return com.raylib.jextract.raylib_h.Vector4DotProduct(
            v1.memorySegment, v2.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static float vector4Distance(
            Vector4 v1,  
            Vector4 v2 
        ){
            
            return com.raylib.jextract.raylib_h.Vector4Distance(
            v1.memorySegment, v2.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static float vector4DistanceSqr(
            Vector4 v1,  
            Vector4 v2 
        ){
            
            return com.raylib.jextract.raylib_h.Vector4DistanceSqr(
            v1.memorySegment, v2.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static Vector4 vector4Scale(
            Vector4 v,  
            float scale 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Scale(Arena.ofAuto(), 
            v.memorySegment, scale
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 vector4Scale(Arena arena,  
            Vector4 v,  
            float scale 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Scale(arena, 
            v.memorySegment, scale
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 vector4Multiply(
            Vector4 v1,  
            Vector4 v2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Multiply(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 vector4Multiply(Arena arena,  
            Vector4 v1,  
            Vector4 v2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Multiply(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 vector4Negate(
            Vector4 v 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Negate(Arena.ofAuto(), 
            v.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 vector4Negate(Arena arena,  
            Vector4 v 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Negate(arena, 
            v.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 vector4Divide(
            Vector4 v1,  
            Vector4 v2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Divide(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 vector4Divide(Arena arena,  
            Vector4 v1,  
            Vector4 v2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Divide(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 vector4Normalize(
            Vector4 v 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Normalize(Arena.ofAuto(), 
            v.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 vector4Normalize(Arena arena,  
            Vector4 v 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Normalize(arena, 
            v.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 vector4Min(
            Vector4 v1,  
            Vector4 v2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Min(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 vector4Min(Arena arena,  
            Vector4 v1,  
            Vector4 v2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Min(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 vector4Max(
            Vector4 v1,  
            Vector4 v2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Max(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 vector4Max(Arena arena,  
            Vector4 v1,  
            Vector4 v2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Max(arena, 
            v1.memorySegment, v2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 vector4Lerp(
            Vector4 v1,  
            Vector4 v2,  
            float amount 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Lerp(Arena.ofAuto(), 
            v1.memorySegment, v2.memorySegment, amount
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 vector4Lerp(Arena arena,  
            Vector4 v1,  
            Vector4 v2,  
            float amount 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Lerp(arena, 
            v1.memorySegment, v2.memorySegment, amount
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 vector4MoveTowards(
            Vector4 v,  
            Vector4 target,  
            float maxDistance 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4MoveTowards(Arena.ofAuto(), 
            v.memorySegment, target.memorySegment, maxDistance
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 vector4MoveTowards(Arena arena,  
            Vector4 v,  
            Vector4 target,  
            float maxDistance 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4MoveTowards(arena, 
            v.memorySegment, target.memorySegment, maxDistance
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 vector4Invert(
            Vector4 v 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Invert(Arena.ofAuto(), 
            v.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 vector4Invert(Arena arena,  
            Vector4 v 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.Vector4Invert(arena, 
            v.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static int vector4Equals(
            Vector4 p,  
            Vector4 q 
        ){
            
            return com.raylib.jextract.raylib_h.Vector4Equals(
            p.memorySegment, q.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static float matrixDeterminant(
            Matrix mat 
        ){
            
            return com.raylib.jextract.raylib_h.MatrixDeterminant(
            mat.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static float matrixTrace(
            Matrix mat 
        ){
            
            return com.raylib.jextract.raylib_h.MatrixTrace(
            mat.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixTranspose(
            Matrix mat 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixTranspose(Arena.ofAuto(), 
            mat.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixTranspose(Arena arena,  
            Matrix mat 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixTranspose(arena, 
            mat.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixInvert(
            Matrix mat 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixInvert(Arena.ofAuto(), 
            mat.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixInvert(Arena arena,  
            Matrix mat 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixInvert(arena, 
            mat.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixIdentity(
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixIdentity(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixIdentity(Arena arena 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixIdentity(arena
            
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixAdd(
            Matrix left,  
            Matrix right 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixAdd(Arena.ofAuto(), 
            left.memorySegment, right.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixAdd(Arena arena,  
            Matrix left,  
            Matrix right 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixAdd(arena, 
            left.memorySegment, right.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixSubtract(
            Matrix left,  
            Matrix right 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixSubtract(Arena.ofAuto(), 
            left.memorySegment, right.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixSubtract(Arena arena,  
            Matrix left,  
            Matrix right 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixSubtract(arena, 
            left.memorySegment, right.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixMultiply(
            Matrix left,  
            Matrix right 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixMultiply(Arena.ofAuto(), 
            left.memorySegment, right.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixMultiply(Arena arena,  
            Matrix left,  
            Matrix right 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixMultiply(arena, 
            left.memorySegment, right.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixTranslate(
            float x,  
            float y,  
            float z 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixTranslate(Arena.ofAuto(), 
            x, y, z
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixTranslate(Arena arena,  
            float x,  
            float y,  
            float z 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixTranslate(arena, 
            x, y, z
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixRotate(
            Vector3 axis,  
            float angle 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixRotate(Arena.ofAuto(), 
            axis.memorySegment, angle
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixRotate(Arena arena,  
            Vector3 axis,  
            float angle 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixRotate(arena, 
            axis.memorySegment, angle
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixRotateX(
            float angle 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixRotateX(Arena.ofAuto(), 
            angle
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixRotateX(Arena arena,  
            float angle 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixRotateX(arena, 
            angle
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixRotateY(
            float angle 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixRotateY(Arena.ofAuto(), 
            angle
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixRotateY(Arena arena,  
            float angle 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixRotateY(arena, 
            angle
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixRotateZ(
            float angle 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixRotateZ(Arena.ofAuto(), 
            angle
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixRotateZ(Arena arena,  
            float angle 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixRotateZ(arena, 
            angle
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixRotateXYZ(
            Vector3 angle 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixRotateXYZ(Arena.ofAuto(), 
            angle.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixRotateXYZ(Arena arena,  
            Vector3 angle 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixRotateXYZ(arena, 
            angle.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixRotateZYX(
            Vector3 angle 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixRotateZYX(Arena.ofAuto(), 
            angle.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixRotateZYX(Arena arena,  
            Vector3 angle 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixRotateZYX(arena, 
            angle.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixScale(
            float x,  
            float y,  
            float z 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixScale(Arena.ofAuto(), 
            x, y, z
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixScale(Arena arena,  
            float x,  
            float y,  
            float z 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixScale(arena, 
            x, y, z
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixFrustum(
            double left,  
            double right,  
            double bottom,  
            double top,  
            double nearPlane,  
            double farPlane 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixFrustum(Arena.ofAuto(), 
            left, right, bottom, top, nearPlane, farPlane
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixFrustum(Arena arena,  
            double left,  
            double right,  
            double bottom,  
            double top,  
            double nearPlane,  
            double farPlane 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixFrustum(arena, 
            left, right, bottom, top, nearPlane, farPlane
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixPerspective(
            double fovY,  
            double aspect,  
            double nearPlane,  
            double farPlane 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixPerspective(Arena.ofAuto(), 
            fovY, aspect, nearPlane, farPlane
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixPerspective(Arena arena,  
            double fovY,  
            double aspect,  
            double nearPlane,  
            double farPlane 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixPerspective(arena, 
            fovY, aspect, nearPlane, farPlane
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixOrtho(
            double left,  
            double right,  
            double bottom,  
            double top,  
            double nearPlane,  
            double farPlane 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixOrtho(Arena.ofAuto(), 
            left, right, bottom, top, nearPlane, farPlane
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixOrtho(Arena arena,  
            double left,  
            double right,  
            double bottom,  
            double top,  
            double nearPlane,  
            double farPlane 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixOrtho(arena, 
            left, right, bottom, top, nearPlane, farPlane
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix matrixLookAt(
            Vector3 eye,  
            Vector3 target,  
            Vector3 up 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixLookAt(Arena.ofAuto(), 
            eye.memorySegment, target.memorySegment, up.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix matrixLookAt(Arena arena,  
            Vector3 eye,  
            Vector3 target,  
            Vector3 up 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.MatrixLookAt(arena, 
            eye.memorySegment, target.memorySegment, up.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static MemorySegment matrixToFloatV(
            Matrix mat 
        ){
            
            return com.raylib.jextract.raylib_h.MatrixToFloatV(Arena.ofAuto(), 
            mat.memorySegment
        );
            
    }
    
    /**
     * 
     */
    public static MemorySegment matrixToFloatV(Arena arena,  
            Matrix mat 
        ){
            
            return com.raylib.jextract.raylib_h.MatrixToFloatV(Arena.ofAuto(), 
            mat.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionAdd(
            Vector4 q1,  
            Vector4 q2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionAdd(Arena.ofAuto(), 
            q1.memorySegment, q2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionAdd(Arena arena,  
            Vector4 q1,  
            Vector4 q2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionAdd(arena, 
            q1.memorySegment, q2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionAddValue(
            Vector4 q,  
            float add 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionAddValue(Arena.ofAuto(), 
            q.memorySegment, add
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionAddValue(Arena arena,  
            Vector4 q,  
            float add 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionAddValue(arena, 
            q.memorySegment, add
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionSubtract(
            Vector4 q1,  
            Vector4 q2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionSubtract(Arena.ofAuto(), 
            q1.memorySegment, q2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionSubtract(Arena arena,  
            Vector4 q1,  
            Vector4 q2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionSubtract(arena, 
            q1.memorySegment, q2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionSubtractValue(
            Vector4 q,  
            float sub 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionSubtractValue(Arena.ofAuto(), 
            q.memorySegment, sub
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionSubtractValue(Arena arena,  
            Vector4 q,  
            float sub 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionSubtractValue(arena, 
            q.memorySegment, sub
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionIdentity(
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionIdentity(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionIdentity(Arena arena 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionIdentity(arena
            
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static float quaternionLength(
            Vector4 q 
        ){
            
            return com.raylib.jextract.raylib_h.QuaternionLength(
            q.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionNormalize(
            Vector4 q 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionNormalize(Arena.ofAuto(), 
            q.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionNormalize(Arena arena,  
            Vector4 q 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionNormalize(arena, 
            q.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionInvert(
            Vector4 q 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionInvert(Arena.ofAuto(), 
            q.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionInvert(Arena arena,  
            Vector4 q 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionInvert(arena, 
            q.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionMultiply(
            Vector4 q1,  
            Vector4 q2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionMultiply(Arena.ofAuto(), 
            q1.memorySegment, q2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionMultiply(Arena arena,  
            Vector4 q1,  
            Vector4 q2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionMultiply(arena, 
            q1.memorySegment, q2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionScale(
            Vector4 q,  
            float mul 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionScale(Arena.ofAuto(), 
            q.memorySegment, mul
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionScale(Arena arena,  
            Vector4 q,  
            float mul 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionScale(arena, 
            q.memorySegment, mul
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionDivide(
            Vector4 q1,  
            Vector4 q2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionDivide(Arena.ofAuto(), 
            q1.memorySegment, q2.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionDivide(Arena arena,  
            Vector4 q1,  
            Vector4 q2 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionDivide(arena, 
            q1.memorySegment, q2.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionLerp(
            Vector4 q1,  
            Vector4 q2,  
            float amount 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionLerp(Arena.ofAuto(), 
            q1.memorySegment, q2.memorySegment, amount
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionLerp(Arena arena,  
            Vector4 q1,  
            Vector4 q2,  
            float amount 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionLerp(arena, 
            q1.memorySegment, q2.memorySegment, amount
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionNlerp(
            Vector4 q1,  
            Vector4 q2,  
            float amount 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionNlerp(Arena.ofAuto(), 
            q1.memorySegment, q2.memorySegment, amount
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionNlerp(Arena arena,  
            Vector4 q1,  
            Vector4 q2,  
            float amount 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionNlerp(arena, 
            q1.memorySegment, q2.memorySegment, amount
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionSlerp(
            Vector4 q1,  
            Vector4 q2,  
            float amount 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionSlerp(Arena.ofAuto(), 
            q1.memorySegment, q2.memorySegment, amount
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionSlerp(Arena arena,  
            Vector4 q1,  
            Vector4 q2,  
            float amount 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionSlerp(arena, 
            q1.memorySegment, q2.memorySegment, amount
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionCubicHermiteSpline(
            Vector4 q1,  
            Vector4 outTangent1,  
            Vector4 q2,  
            Vector4 inTangent2,  
            float t 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionCubicHermiteSpline(Arena.ofAuto(), 
            q1.memorySegment, outTangent1.memorySegment, q2.memorySegment, inTangent2.memorySegment, t
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionCubicHermiteSpline(Arena arena,  
            Vector4 q1,  
            Vector4 outTangent1,  
            Vector4 q2,  
            Vector4 inTangent2,  
            float t 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionCubicHermiteSpline(arena, 
            q1.memorySegment, outTangent1.memorySegment, q2.memorySegment, inTangent2.memorySegment, t
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionFromVector3ToVector3(
            Vector3 from,  
            Vector3 to 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionFromVector3ToVector3(Arena.ofAuto(), 
            from.memorySegment, to.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionFromVector3ToVector3(Arena arena,  
            Vector3 from,  
            Vector3 to 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionFromVector3ToVector3(arena, 
            from.memorySegment, to.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionFromMatrix(
            Matrix mat 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionFromMatrix(Arena.ofAuto(), 
            mat.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionFromMatrix(Arena arena,  
            Matrix mat 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionFromMatrix(arena, 
            mat.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Matrix quaternionToMatrix(
            Vector4 q 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.QuaternionToMatrix(Arena.ofAuto(), 
            q.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Matrix quaternionToMatrix(Arena arena,  
            Vector4 q 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.QuaternionToMatrix(arena, 
            q.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionFromAxisAngle(
            Vector3 axis,  
            float angle 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionFromAxisAngle(Arena.ofAuto(), 
            axis.memorySegment, angle
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionFromAxisAngle(Arena arena,  
            Vector3 axis,  
            float angle 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionFromAxisAngle(arena, 
            axis.memorySegment, angle
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static void quaternionToAxisAngle(
            Vector4 q,  
            Vector3 outAxis,  
            java.nio.FloatBuffer outAngle 
        ){
            
            com.raylib.jextract.raylib_h.QuaternionToAxisAngle(
            q.memorySegment, outAxis.memorySegment, MemorySegment.ofBuffer(outAngle)
        );
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionFromEuler(
            float pitch,  
            float yaw,  
            float roll 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionFromEuler(Arena.ofAuto(), 
            pitch, yaw, roll
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionFromEuler(Arena arena,  
            float pitch,  
            float yaw,  
            float roll 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionFromEuler(arena, 
            pitch, yaw, roll
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector3 quaternionToEuler(
            Vector4 q 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.QuaternionToEuler(Arena.ofAuto(), 
            q.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector3 quaternionToEuler(Arena arena,  
            Vector4 q 
        ){
            
             return new Vector3(com.raylib.jextract.raylib_h.QuaternionToEuler(arena, 
            q.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static Vector4 quaternionTransform(
            Vector4 q,  
            Matrix mat 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionTransform(Arena.ofAuto(), 
            q.memorySegment, mat.memorySegment
        ));
            
            
    }
    
    /**
     * 
     */
    public static Vector4 quaternionTransform(Arena arena,  
            Vector4 q,  
            Matrix mat 
        ){
            
             return new Vector4(com.raylib.jextract.raylib_h.QuaternionTransform(arena, 
            q.memorySegment, mat.memorySegment
        ));
            
            
    }
    
    
    /**
     * 
     */
    public static int quaternionEquals(
            Vector4 p,  
            Vector4 q 
        ){
            
            return com.raylib.jextract.raylib_h.QuaternionEquals(
            p.memorySegment, q.memorySegment
        );
            
    }
    
    
    /**
     * 
     */
    public static void matrixDecompose(
            Matrix mat,  
            Vector3 translation,  
            Vector4 rotation,  
            Vector3 scale 
        ){
            
            com.raylib.jextract.raylib_h.MatrixDecompose(
            mat.memorySegment, translation.memorySegment, rotation.memorySegment, scale.memorySegment
        );
            
            
    }
    
    
    /**
     * Choose the current matrix to be transformed
     */
    public static void rlMatrixMode(
            int mode 
        ){
            
            com.raylib.jextract.raylib_h.rlMatrixMode(
            mode
        );
            
            
    }
    
    
    /**
     * Push the current matrix to stack
     */
    public static void rlPushMatrix(
        ){
            
            com.raylib.jextract.raylib_h.rlPushMatrix(
            
        );
            
            
    }
    
    
    /**
     * Pop latest inserted matrix from stack
     */
    public static void rlPopMatrix(
        ){
            
            com.raylib.jextract.raylib_h.rlPopMatrix(
            
        );
            
            
    }
    
    
    /**
     * Reset current matrix to identity matrix
     */
    public static void rlLoadIdentity(
        ){
            
            com.raylib.jextract.raylib_h.rlLoadIdentity(
            
        );
            
            
    }
    
    
    /**
     * Multiply the current matrix by a translation matrix
     */
    public static void rlTranslatef(
            float x,  
            float y,  
            float z 
        ){
            
            com.raylib.jextract.raylib_h.rlTranslatef(
            x, y, z
        );
            
            
    }
    
    
    /**
     * Multiply the current matrix by a rotation matrix
     */
    public static void rlRotatef(
            float angle,  
            float x,  
            float y,  
            float z 
        ){
            
            com.raylib.jextract.raylib_h.rlRotatef(
            angle, x, y, z
        );
            
            
    }
    
    
    /**
     * Multiply the current matrix by a scaling matrix
     */
    public static void rlScalef(
            float x,  
            float y,  
            float z 
        ){
            
            com.raylib.jextract.raylib_h.rlScalef(
            x, y, z
        );
            
            
    }
    
    
    /**
     * Multiply the current matrix by another matrix
     */
    public static void rlMultMatrixf(
            MemorySegment matf 
        ){
            
            com.raylib.jextract.raylib_h.rlMultMatrixf(
            matf
        );
            
            
    }
    
    
    /**
     * 
     */
    public static void rlFrustum(
            double left,  
            double right,  
            double bottom,  
            double top,  
            double znear,  
            double zfar 
        ){
            
            com.raylib.jextract.raylib_h.rlFrustum(
            left, right, bottom, top, znear, zfar
        );
            
            
    }
    
    
    /**
     * 
     */
    public static void rlOrtho(
            double left,  
            double right,  
            double bottom,  
            double top,  
            double znear,  
            double zfar 
        ){
            
            com.raylib.jextract.raylib_h.rlOrtho(
            left, right, bottom, top, znear, zfar
        );
            
            
    }
    
    
    /**
     * Set the viewport area
     */
    public static void rlViewport(
            int x,  
            int y,  
            int width,  
            int height 
        ){
            
            com.raylib.jextract.raylib_h.rlViewport(
            x, y, width, height
        );
            
            
    }
    
    
    /**
     * Set clip planes distances
     */
    public static void rlSetClipPlanes(
            double nearPlane,  
            double farPlane 
        ){
            
            com.raylib.jextract.raylib_h.rlSetClipPlanes(
            nearPlane, farPlane
        );
            
            
    }
    
    
    /**
     * Get cull plane distance near
     */
    public static double rlGetCullDistanceNear(
        ){
            
            return com.raylib.jextract.raylib_h.rlGetCullDistanceNear(
            
        );
            
    }
    
    
    /**
     * Get cull plane distance far
     */
    public static double rlGetCullDistanceFar(
        ){
            
            return com.raylib.jextract.raylib_h.rlGetCullDistanceFar(
            
        );
            
    }
    
    
    /**
     * Initialize drawing mode (how to organize vertex)
     */
    public static void rlBegin(
            int mode 
        ){
            
            com.raylib.jextract.raylib_h.rlBegin(
            mode
        );
            
            
    }
    
    
    /**
     * Finish vertex providing
     */
    public static void rlEnd(
        ){
            
            com.raylib.jextract.raylib_h.rlEnd(
            
        );
            
            
    }
    
    
    /**
     * Define one vertex (position) - 2 int
     */
    public static void rlVertex2i(
            int x,  
            int y 
        ){
            
            com.raylib.jextract.raylib_h.rlVertex2i(
            x, y
        );
            
            
    }
    
    
    /**
     * Define one vertex (position) - 2 float
     */
    public static void rlVertex2f(
            float x,  
            float y 
        ){
            
            com.raylib.jextract.raylib_h.rlVertex2f(
            x, y
        );
            
            
    }
    
    
    /**
     * Define one vertex (position) - 3 float
     */
    public static void rlVertex3f(
            float x,  
            float y,  
            float z 
        ){
            
            com.raylib.jextract.raylib_h.rlVertex3f(
            x, y, z
        );
            
            
    }
    
    
    /**
     * Define one vertex (texture coordinate) - 2 float
     */
    public static void rlTexCoord2f(
            float x,  
            float y 
        ){
            
            com.raylib.jextract.raylib_h.rlTexCoord2f(
            x, y
        );
            
            
    }
    
    
    /**
     * Define one vertex (normal) - 3 float
     */
    public static void rlNormal3f(
            float x,  
            float y,  
            float z 
        ){
            
            com.raylib.jextract.raylib_h.rlNormal3f(
            x, y, z
        );
            
            
    }
    
    
    /**
     * Define one vertex (color) - 4 byte
     */
    public static void rlColor4ub(
            byte r,  
            byte g,  
            byte b,  
            byte a 
        ){
            
            com.raylib.jextract.raylib_h.rlColor4ub(
            r, g, b, a
        );
            
            
    }
    
    
    /**
     * Define one vertex (color) - 3 float
     */
    public static void rlColor3f(
            float x,  
            float y,  
            float z 
        ){
            
            com.raylib.jextract.raylib_h.rlColor3f(
            x, y, z
        );
            
            
    }
    
    
    /**
     * Define one vertex (color) - 4 float
     */
    public static void rlColor4f(
            float x,  
            float y,  
            float z,  
            float w 
        ){
            
            com.raylib.jextract.raylib_h.rlColor4f(
            x, y, z, w
        );
            
            
    }
    
    
    /**
     * Enable vertex array (VAO, if supported)
     */
    public static boolean rlEnableVertexArray(
            int vaoId 
        ){
            
            return com.raylib.jextract.raylib_h.rlEnableVertexArray(
            vaoId
        );
            
    }
    
    
    /**
     * Disable vertex array (VAO, if supported)
     */
    public static void rlDisableVertexArray(
        ){
            
            com.raylib.jextract.raylib_h.rlDisableVertexArray(
            
        );
            
            
    }
    
    
    /**
     * Enable vertex buffer (VBO)
     */
    public static void rlEnableVertexBuffer(
            int id 
        ){
            
            com.raylib.jextract.raylib_h.rlEnableVertexBuffer(
            id
        );
            
            
    }
    
    
    /**
     * Disable vertex buffer (VBO)
     */
    public static void rlDisableVertexBuffer(
        ){
            
            com.raylib.jextract.raylib_h.rlDisableVertexBuffer(
            
        );
            
            
    }
    
    
    /**
     * Enable vertex buffer element (VBO element)
     */
    public static void rlEnableVertexBufferElement(
            int id 
        ){
            
            com.raylib.jextract.raylib_h.rlEnableVertexBufferElement(
            id
        );
            
            
    }
    
    
    /**
     * Disable vertex buffer element (VBO element)
     */
    public static void rlDisableVertexBufferElement(
        ){
            
            com.raylib.jextract.raylib_h.rlDisableVertexBufferElement(
            
        );
            
            
    }
    
    
    /**
     * Enable vertex attribute index
     */
    public static void rlEnableVertexAttribute(
            int index 
        ){
            
            com.raylib.jextract.raylib_h.rlEnableVertexAttribute(
            index
        );
            
            
    }
    
    
    /**
     * Disable vertex attribute index
     */
    public static void rlDisableVertexAttribute(
            int index 
        ){
            
            com.raylib.jextract.raylib_h.rlDisableVertexAttribute(
            index
        );
            
            
    }
    
    
    /**
     * Select and active a texture slot
     */
    public static void rlActiveTextureSlot(
            int slot 
        ){
            
            com.raylib.jextract.raylib_h.rlActiveTextureSlot(
            slot
        );
            
            
    }
    
    
    /**
     * Enable texture
     */
    public static void rlEnableTexture(
            int id 
        ){
            
            com.raylib.jextract.raylib_h.rlEnableTexture(
            id
        );
            
            
    }
    
    
    /**
     * Disable texture
     */
    public static void rlDisableTexture(
        ){
            
            com.raylib.jextract.raylib_h.rlDisableTexture(
            
        );
            
            
    }
    
    
    /**
     * Enable texture cubemap
     */
    public static void rlEnableTextureCubemap(
            int id 
        ){
            
            com.raylib.jextract.raylib_h.rlEnableTextureCubemap(
            id
        );
            
            
    }
    
    
    /**
     * Disable texture cubemap
     */
    public static void rlDisableTextureCubemap(
        ){
            
            com.raylib.jextract.raylib_h.rlDisableTextureCubemap(
            
        );
            
            
    }
    
    
    /**
     * Set texture parameters (filter, wrap)
     */
    public static void rlTextureParameters(
            int id,  
            int param,  
            int value 
        ){
            
            com.raylib.jextract.raylib_h.rlTextureParameters(
            id, param, value
        );
            
            
    }
    
    
    /**
     * Set cubemap parameters (filter, wrap)
     */
    public static void rlCubemapParameters(
            int id,  
            int param,  
            int value 
        ){
            
            com.raylib.jextract.raylib_h.rlCubemapParameters(
            id, param, value
        );
            
            
    }
    
    
    /**
     * Enable shader program
     */
    public static void rlEnableShader(
            int id 
        ){
            
            com.raylib.jextract.raylib_h.rlEnableShader(
            id
        );
            
            
    }
    
    
    /**
     * Disable shader program
     */
    public static void rlDisableShader(
        ){
            
            com.raylib.jextract.raylib_h.rlDisableShader(
            
        );
            
            
    }
    
    
    /**
     * Enable render texture (fbo)
     */
    public static void rlEnableFramebuffer(
            int id 
        ){
            
            com.raylib.jextract.raylib_h.rlEnableFramebuffer(
            id
        );
            
            
    }
    
    
    /**
     * Disable render texture (fbo), return to default framebuffer
     */
    public static void rlDisableFramebuffer(
        ){
            
            com.raylib.jextract.raylib_h.rlDisableFramebuffer(
            
        );
            
            
    }
    
    
    /**
     * Get the currently active render texture (fbo), 0 for default framebuffer
     */
    public static int rlGetActiveFramebuffer(
        ){
            
            return com.raylib.jextract.raylib_h.rlGetActiveFramebuffer(
            
        );
            
    }
    
    
    /**
     * Activate multiple draw color buffers
     */
    public static void rlActiveDrawBuffers(
            int count 
        ){
            
            com.raylib.jextract.raylib_h.rlActiveDrawBuffers(
            count
        );
            
            
    }
    
    
    /**
     * Blit active framebuffer to main framebuffer
     */
    public static void rlBlitFramebuffer(
            int srcX,  
            int srcY,  
            int srcWidth,  
            int srcHeight,  
            int dstX,  
            int dstY,  
            int dstWidth,  
            int dstHeight,  
            int bufferMask 
        ){
            
            com.raylib.jextract.raylib_h.rlBlitFramebuffer(
            srcX, srcY, srcWidth, srcHeight, dstX, dstY, dstWidth, dstHeight, bufferMask
        );
            
            
    }
    
    
    /**
     * Bind framebuffer (FBO)
     */
    public static void rlBindFramebuffer(
            int target,  
            int framebuffer 
        ){
            
            com.raylib.jextract.raylib_h.rlBindFramebuffer(
            target, framebuffer
        );
            
            
    }
    
    
    /**
     * Enable color blending
     */
    public static void rlEnableColorBlend(
        ){
            
            com.raylib.jextract.raylib_h.rlEnableColorBlend(
            
        );
            
            
    }
    
    
    /**
     * Disable color blending
     */
    public static void rlDisableColorBlend(
        ){
            
            com.raylib.jextract.raylib_h.rlDisableColorBlend(
            
        );
            
            
    }
    
    
    /**
     * Enable depth test
     */
    public static void rlEnableDepthTest(
        ){
            
            com.raylib.jextract.raylib_h.rlEnableDepthTest(
            
        );
            
            
    }
    
    
    /**
     * Disable depth test
     */
    public static void rlDisableDepthTest(
        ){
            
            com.raylib.jextract.raylib_h.rlDisableDepthTest(
            
        );
            
            
    }
    
    
    /**
     * Enable depth write
     */
    public static void rlEnableDepthMask(
        ){
            
            com.raylib.jextract.raylib_h.rlEnableDepthMask(
            
        );
            
            
    }
    
    
    /**
     * Disable depth write
     */
    public static void rlDisableDepthMask(
        ){
            
            com.raylib.jextract.raylib_h.rlDisableDepthMask(
            
        );
            
            
    }
    
    
    /**
     * Enable backface culling
     */
    public static void rlEnableBackfaceCulling(
        ){
            
            com.raylib.jextract.raylib_h.rlEnableBackfaceCulling(
            
        );
            
            
    }
    
    
    /**
     * Disable backface culling
     */
    public static void rlDisableBackfaceCulling(
        ){
            
            com.raylib.jextract.raylib_h.rlDisableBackfaceCulling(
            
        );
            
            
    }
    
    
    /**
     * Color mask control
     */
    public static void rlColorMask(
            boolean r,  
            boolean g,  
            boolean b,  
            boolean a 
        ){
            
            com.raylib.jextract.raylib_h.rlColorMask(
            r, g, b, a
        );
            
            
    }
    
    
    /**
     * Set face culling mode
     */
    public static void rlSetCullFace(
            int mode 
        ){
            
            com.raylib.jextract.raylib_h.rlSetCullFace(
            mode
        );
            
            
    }
    
    
    /**
     * Enable scissor test
     */
    public static void rlEnableScissorTest(
        ){
            
            com.raylib.jextract.raylib_h.rlEnableScissorTest(
            
        );
            
            
    }
    
    
    /**
     * Disable scissor test
     */
    public static void rlDisableScissorTest(
        ){
            
            com.raylib.jextract.raylib_h.rlDisableScissorTest(
            
        );
            
            
    }
    
    
    /**
     * Scissor test
     */
    public static void rlScissor(
            int x,  
            int y,  
            int width,  
            int height 
        ){
            
            com.raylib.jextract.raylib_h.rlScissor(
            x, y, width, height
        );
            
            
    }
    
    
    /**
     * Enable wire mode
     */
    public static void rlEnableWireMode(
        ){
            
            com.raylib.jextract.raylib_h.rlEnableWireMode(
            
        );
            
            
    }
    
    
    /**
     * Enable point mode
     */
    public static void rlEnablePointMode(
        ){
            
            com.raylib.jextract.raylib_h.rlEnablePointMode(
            
        );
            
            
    }
    
    
    /**
     * Disable wire (and point) mode
     */
    public static void rlDisableWireMode(
        ){
            
            com.raylib.jextract.raylib_h.rlDisableWireMode(
            
        );
            
            
    }
    
    
    /**
     * Set the line drawing width
     */
    public static void rlSetLineWidth(
            float width 
        ){
            
            com.raylib.jextract.raylib_h.rlSetLineWidth(
            width
        );
            
            
    }
    
    
    /**
     * Get the line drawing width
     */
    public static float rlGetLineWidth(
        ){
            
            return com.raylib.jextract.raylib_h.rlGetLineWidth(
            
        );
            
    }
    
    
    /**
     * Enable line aliasing
     */
    public static void rlEnableSmoothLines(
        ){
            
            com.raylib.jextract.raylib_h.rlEnableSmoothLines(
            
        );
            
            
    }
    
    
    /**
     * Disable line aliasing
     */
    public static void rlDisableSmoothLines(
        ){
            
            com.raylib.jextract.raylib_h.rlDisableSmoothLines(
            
        );
            
            
    }
    
    
    /**
     * Enable stereo rendering
     */
    public static void rlEnableStereoRender(
        ){
            
            com.raylib.jextract.raylib_h.rlEnableStereoRender(
            
        );
            
            
    }
    
    
    /**
     * Disable stereo rendering
     */
    public static void rlDisableStereoRender(
        ){
            
            com.raylib.jextract.raylib_h.rlDisableStereoRender(
            
        );
            
            
    }
    
    
    /**
     * Check if stereo render is enabled
     */
    public static boolean rlIsStereoRenderEnabled(
        ){
            
            return com.raylib.jextract.raylib_h.rlIsStereoRenderEnabled(
            
        );
            
    }
    
    
    /**
     * Clear color buffer with color
     */
    public static void rlClearColor(
            byte r,  
            byte g,  
            byte b,  
            byte a 
        ){
            
            com.raylib.jextract.raylib_h.rlClearColor(
            r, g, b, a
        );
            
            
    }
    
    
    /**
     * Clear used screen buffers (color and depth)
     */
    public static void rlClearScreenBuffers(
        ){
            
            com.raylib.jextract.raylib_h.rlClearScreenBuffers(
            
        );
            
            
    }
    
    
    /**
     * Check and log OpenGL error codes
     */
    public static void rlCheckErrors(
        ){
            
            com.raylib.jextract.raylib_h.rlCheckErrors(
            
        );
            
            
    }
    
    
    /**
     * Set blending mode
     */
    public static void rlSetBlendMode(
            int mode 
        ){
            
            com.raylib.jextract.raylib_h.rlSetBlendMode(
            mode
        );
            
            
    }
    
    
    /**
     * Set blending mode factor and equation (using OpenGL factors)
     */
    public static void rlSetBlendFactors(
            int glSrcFactor,  
            int glDstFactor,  
            int glEquation 
        ){
            
            com.raylib.jextract.raylib_h.rlSetBlendFactors(
            glSrcFactor, glDstFactor, glEquation
        );
            
            
    }
    
    
    /**
     * Set blending mode factors and equations separately (using OpenGL factors)
     */
    public static void rlSetBlendFactorsSeparate(
            int glSrcRGB,  
            int glDstRGB,  
            int glSrcAlpha,  
            int glDstAlpha,  
            int glEqRGB,  
            int glEqAlpha 
        ){
            
            com.raylib.jextract.raylib_h.rlSetBlendFactorsSeparate(
            glSrcRGB, glDstRGB, glSrcAlpha, glDstAlpha, glEqRGB, glEqAlpha
        );
            
            
    }
    
    
    /**
     * Initialize rlgl (buffers, shaders, textures, states)
     */
    public static void rlglInit(
            int width,  
            int height 
        ){
            
            com.raylib.jextract.raylib_h.rlglInit(
            width, height
        );
            
            
    }
    
    
    /**
     * De-initialize rlgl (buffers, shaders, textures)
     */
    public static void rlglClose(
        ){
            
            com.raylib.jextract.raylib_h.rlglClose(
            
        );
            
            
    }
    
    
    /**
     * Load OpenGL extensions (loader function required)
     */
    public static void rlLoadExtensions(
            MemorySegment loader 
        ){
            
            com.raylib.jextract.raylib_h.rlLoadExtensions(
            loader
        );
            
            
    }
    
    
    /**
     * Get current OpenGL version
     */
    public static int rlGetVersion(
        ){
            
            return com.raylib.jextract.raylib_h.rlGetVersion(
            
        );
            
    }
    
    
    /**
     * Set current framebuffer width
     */
    public static void rlSetFramebufferWidth(
            int width 
        ){
            
            com.raylib.jextract.raylib_h.rlSetFramebufferWidth(
            width
        );
            
            
    }
    
    
    /**
     * Get default framebuffer width
     */
    public static int rlGetFramebufferWidth(
        ){
            
            return com.raylib.jextract.raylib_h.rlGetFramebufferWidth(
            
        );
            
    }
    
    
    /**
     * Set current framebuffer height
     */
    public static void rlSetFramebufferHeight(
            int height 
        ){
            
            com.raylib.jextract.raylib_h.rlSetFramebufferHeight(
            height
        );
            
            
    }
    
    
    /**
     * Get default framebuffer height
     */
    public static int rlGetFramebufferHeight(
        ){
            
            return com.raylib.jextract.raylib_h.rlGetFramebufferHeight(
            
        );
            
    }
    
    
    /**
     * Get default texture id
     */
    public static int rlGetTextureIdDefault(
        ){
            
            return com.raylib.jextract.raylib_h.rlGetTextureIdDefault(
            
        );
            
    }
    
    
    /**
     * Get default shader id
     */
    public static int rlGetShaderIdDefault(
        ){
            
            return com.raylib.jextract.raylib_h.rlGetShaderIdDefault(
            
        );
            
    }
    
    
    /**
     * Get default shader locations
     */
    public static java.nio.IntBuffer rlGetShaderLocsDefault(
        ){
            
            return com.raylib.jextract.raylib_h.rlGetShaderLocsDefault(
            
        ).reinterpret(Integer.MAX_VALUE/2).asByteBuffer().order(ByteOrder.nativeOrder()).asIntBuffer();
            
    }
    
    
    /**
     * Load a render batch system
     */
    public static rlRenderBatch rlLoadRenderBatch(
            int numBuffers,  
            int bufferElements 
        ){
            
             return new rlRenderBatch(com.raylib.jextract.raylib_h.rlLoadRenderBatch(Arena.ofAuto(), 
            numBuffers, bufferElements
        ));
            
            
    }
    
    /**
     * Load a render batch system
     */
    public static rlRenderBatch rlLoadRenderBatch(Arena arena,  
            int numBuffers,  
            int bufferElements 
        ){
            
             return new rlRenderBatch(com.raylib.jextract.raylib_h.rlLoadRenderBatch(arena, 
            numBuffers, bufferElements
        ));
            
            
    }
    
    
    /**
     * Unload render batch system
     */
    public static void rlUnloadRenderBatch(
            rlRenderBatch batch 
        ){
            
            com.raylib.jextract.raylib_h.rlUnloadRenderBatch(
            batch.memorySegment
        );
            
            
    }
    
    
    /**
     * Draw render batch data (Update->Draw->Reset)
     */
    public static void rlDrawRenderBatch(
            rlRenderBatch batch 
        ){
            
            com.raylib.jextract.raylib_h.rlDrawRenderBatch(
            batch.memorySegment
        );
            
            
    }
    
    
    /**
     * Set the active render batch for rlgl (NULL for default internal)
     */
    public static void rlSetRenderBatchActive(
            rlRenderBatch batch 
        ){
            
            com.raylib.jextract.raylib_h.rlSetRenderBatchActive(
            batch.memorySegment
        );
            
            
    }
    
    
    /**
     * Update and draw internal render batch
     */
    public static void rlDrawRenderBatchActive(
        ){
            
            com.raylib.jextract.raylib_h.rlDrawRenderBatchActive(
            
        );
            
            
    }
    
    
    /**
     * Check internal buffer overflow for a given number of vertex
     */
    public static boolean rlCheckRenderBatchLimit(
            int vCount 
        ){
            
            return com.raylib.jextract.raylib_h.rlCheckRenderBatchLimit(
            vCount
        );
            
    }
    
    
    /**
     * Set current texture for render batch and check buffers limits
     */
    public static void rlSetTexture(
            int id 
        ){
            
            com.raylib.jextract.raylib_h.rlSetTexture(
            id
        );
            
            
    }
    
    
    /**
     * Load vertex array (vao) if supported
     */
    public static int rlLoadVertexArray(
        ){
            
            return com.raylib.jextract.raylib_h.rlLoadVertexArray(
            
        );
            
    }
    
    
    /**
     * Load a vertex buffer object
     */
    public static int rlLoadVertexBuffer(
            MemorySegment buffer,  
            int size,  
            boolean dynamic 
        ){
            
            return com.raylib.jextract.raylib_h.rlLoadVertexBuffer(
            buffer, size, dynamic
        );
            
    }
    
    
    /**
     * Load vertex buffer elements object
     */
    public static int rlLoadVertexBufferElement(
            MemorySegment buffer,  
            int size,  
            boolean dynamic 
        ){
            
            return com.raylib.jextract.raylib_h.rlLoadVertexBufferElement(
            buffer, size, dynamic
        );
            
    }
    
    
    /**
     * Update vertex buffer object data on GPU buffer
     */
    public static void rlUpdateVertexBuffer(
            int bufferId,  
            MemorySegment data,  
            int dataSize,  
            int offset 
        ){
            
            com.raylib.jextract.raylib_h.rlUpdateVertexBuffer(
            bufferId, data, dataSize, offset
        );
            
            
    }
    
    
    /**
     * Update vertex buffer elements data on GPU buffer
     */
    public static void rlUpdateVertexBufferElements(
            int id,  
            MemorySegment data,  
            int dataSize,  
            int offset 
        ){
            
            com.raylib.jextract.raylib_h.rlUpdateVertexBufferElements(
            id, data, dataSize, offset
        );
            
            
    }
    
    
    /**
     * Unload vertex array (vao)
     */
    public static void rlUnloadVertexArray(
            int vaoId 
        ){
            
            com.raylib.jextract.raylib_h.rlUnloadVertexArray(
            vaoId
        );
            
            
    }
    
    
    /**
     * Unload vertex buffer object
     */
    public static void rlUnloadVertexBuffer(
            int vboId 
        ){
            
            com.raylib.jextract.raylib_h.rlUnloadVertexBuffer(
            vboId
        );
            
            
    }
    
    
    /**
     * Set vertex attribute data configuration
     */
    public static void rlSetVertexAttribute(
            int index,  
            int compSize,  
            int type,  
            boolean normalized,  
            int stride,  
            int offset 
        ){
            
            com.raylib.jextract.raylib_h.rlSetVertexAttribute(
            index, compSize, type, normalized, stride, offset
        );
            
            
    }
    
    
    /**
     * Set vertex attribute data divisor
     */
    public static void rlSetVertexAttributeDivisor(
            int index,  
            int divisor 
        ){
            
            com.raylib.jextract.raylib_h.rlSetVertexAttributeDivisor(
            index, divisor
        );
            
            
    }
    
    
    /**
     * Set vertex attribute default value, when attribute to provided
     */
    public static void rlSetVertexAttributeDefault(
            int locIndex,  
            MemorySegment value,  
            int attribType,  
            int count 
        ){
            
            com.raylib.jextract.raylib_h.rlSetVertexAttributeDefault(
            locIndex, value, attribType, count
        );
            
            
    }
    
    
    /**
     * Draw vertex array (currently active vao)
     */
    public static void rlDrawVertexArray(
            int offset,  
            int count 
        ){
            
            com.raylib.jextract.raylib_h.rlDrawVertexArray(
            offset, count
        );
            
            
    }
    
    
    /**
     * Draw vertex array elements
     */
    public static void rlDrawVertexArrayElements(
            int offset,  
            int count,  
            MemorySegment buffer 
        ){
            
            com.raylib.jextract.raylib_h.rlDrawVertexArrayElements(
            offset, count, buffer
        );
            
            
    }
    
    
    /**
     * Draw vertex array (currently active vao) with instancing
     */
    public static void rlDrawVertexArrayInstanced(
            int offset,  
            int count,  
            int instances 
        ){
            
            com.raylib.jextract.raylib_h.rlDrawVertexArrayInstanced(
            offset, count, instances
        );
            
            
    }
    
    
    /**
     * Draw vertex array elements with instancing
     */
    public static void rlDrawVertexArrayElementsInstanced(
            int offset,  
            int count,  
            MemorySegment buffer,  
            int instances 
        ){
            
            com.raylib.jextract.raylib_h.rlDrawVertexArrayElementsInstanced(
            offset, count, buffer, instances
        );
            
            
    }
    
    
    /**
     * Load texture data
     */
    public static int rlLoadTexture(
            MemorySegment data,  
            int width,  
            int height,  
            int format,  
            int mipmapCount 
        ){
            
            return com.raylib.jextract.raylib_h.rlLoadTexture(
            data, width, height, format, mipmapCount
        );
            
    }
    
    
    /**
     * Load depth texture/renderbuffer (to be attached to fbo)
     */
    public static int rlLoadTextureDepth(
            int width,  
            int height,  
            boolean useRenderBuffer 
        ){
            
            return com.raylib.jextract.raylib_h.rlLoadTextureDepth(
            width, height, useRenderBuffer
        );
            
    }
    
    
    /**
     * Load texture cubemap data
     */
    public static int rlLoadTextureCubemap(
            MemorySegment data,  
            int size,  
            int format,  
            int mipmapCount 
        ){
            
            return com.raylib.jextract.raylib_h.rlLoadTextureCubemap(
            data, size, format, mipmapCount
        );
            
    }
    
    
    /**
     * Update texture with new data on GPU
     */
    public static void rlUpdateTexture(
            int id,  
            int offsetX,  
            int offsetY,  
            int width,  
            int height,  
            int format,  
            MemorySegment data 
        ){
            
            com.raylib.jextract.raylib_h.rlUpdateTexture(
            id, offsetX, offsetY, width, height, format, data
        );
            
            
    }
    
    
    /**
     * Get OpenGL internal formats
     */
    public static void rlGetGlTextureFormats(
            int format,  
            MemorySegment glInternalFormat,  
            MemorySegment glFormat,  
            MemorySegment glType 
        ){
            
            com.raylib.jextract.raylib_h.rlGetGlTextureFormats(
            format, glInternalFormat, glFormat, glType
        );
            
            
    }
    
    
    /**
     * Get name string for pixel format
     */
    public static String rlGetPixelFormatName(
            int format 
        ){
            
            return com.raylib.jextract.raylib_h.rlGetPixelFormatName(
            format
        ).getString(0);
            
    }
    
    
    /**
     * Unload texture from GPU memory
     */
    public static void rlUnloadTexture(
            int id 
        ){
            
            com.raylib.jextract.raylib_h.rlUnloadTexture(
            id
        );
            
            
    }
    
    
    /**
     * Generate mipmap data for selected texture
     */
    public static void rlGenTextureMipmaps(
            int id,  
            int width,  
            int height,  
            int format,  
            java.nio.IntBuffer mipmaps 
        ){
            
            com.raylib.jextract.raylib_h.rlGenTextureMipmaps(
            id, width, height, format, mipmaps == null ? MemorySegment.NULL : MemorySegment.ofBuffer(mipmaps)
        );
            
            
    }
    
    
    /**
     * Read texture pixel data
     */
    public static MemorySegment rlReadTexturePixels(
            int id,  
            int width,  
            int height,  
            int format 
        ){
            
            return com.raylib.jextract.raylib_h.rlReadTexturePixels(
            id, width, height, format
        );
            
    }
    
    
    /**
     * Read screen pixel data (color buffer)
     */
    public static java.nio.ByteBuffer rlReadScreenPixels(
            int width,  
            int height 
        ){
            
            return com.raylib.jextract.raylib_h.rlReadScreenPixels(
            width, height
        ).reinterpret(Integer.MAX_VALUE/2).asByteBuffer().order(ByteOrder.nativeOrder());
            
    }
    
    
    /**
     * Load an empty framebuffer
     */
    public static int rlLoadFramebuffer(
        ){
            
            return com.raylib.jextract.raylib_h.rlLoadFramebuffer(
            
        );
            
    }
    
    
    /**
     * Attach texture/renderbuffer to a framebuffer
     */
    public static void rlFramebufferAttach(
            int fboId,  
            int texId,  
            int attachType,  
            int texType,  
            int mipLevel 
        ){
            
            com.raylib.jextract.raylib_h.rlFramebufferAttach(
            fboId, texId, attachType, texType, mipLevel
        );
            
            
    }
    
    
    /**
     * Verify framebuffer is complete
     */
    public static boolean rlFramebufferComplete(
            int id 
        ){
            
            return com.raylib.jextract.raylib_h.rlFramebufferComplete(
            id
        );
            
    }
    
    
    /**
     * Delete framebuffer from GPU
     */
    public static void rlUnloadFramebuffer(
            int id 
        ){
            
            com.raylib.jextract.raylib_h.rlUnloadFramebuffer(
            id
        );
            
            
    }
    
    
    /**
     * Load shader from code strings
     */
    public static int rlLoadShaderCode(
            String vsCode,  
            String fsCode 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.rlLoadShaderCode(
            localArena.allocateFrom(vsCode), localArena.allocateFrom(fsCode)
        );
            }
    }
    
    
    /**
     * Compile custom shader and return shader id (type: RL_VERTEX_SHADER, RL_FRAGMENT_SHADER, RL_COMPUTE_SHADER)
     */
    public static int rlCompileShader(
            String shaderCode,  
            int type 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.rlCompileShader(
            localArena.allocateFrom(shaderCode), type
        );
            }
    }
    
    
    /**
     * Load custom shader program
     */
    public static int rlLoadShaderProgram(
            int vShaderId,  
            int fShaderId 
        ){
            
            return com.raylib.jextract.raylib_h.rlLoadShaderProgram(
            vShaderId, fShaderId
        );
            
    }
    
    
    /**
     * Unload shader program
     */
    public static void rlUnloadShaderProgram(
            int id 
        ){
            
            com.raylib.jextract.raylib_h.rlUnloadShaderProgram(
            id
        );
            
            
    }
    
    
    /**
     * Get shader location uniform
     */
    public static int rlGetLocationUniform(
            int shaderId,  
            String uniformName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.rlGetLocationUniform(
            shaderId, localArena.allocateFrom(uniformName)
        );
            }
    }
    
    
    /**
     * Get shader location attribute
     */
    public static int rlGetLocationAttrib(
            int shaderId,  
            String attribName 
        ){
            try(Arena localArena = Arena.ofConfined()) { 
            return com.raylib.jextract.raylib_h.rlGetLocationAttrib(
            shaderId, localArena.allocateFrom(attribName)
        );
            }
    }
    
    
    /**
     * Set shader value uniform
     */
    public static void rlSetUniform(
            int locIndex,  
            MemorySegment value,  
            int uniformType,  
            int count 
        ){
            
            com.raylib.jextract.raylib_h.rlSetUniform(
            locIndex, value, uniformType, count
        );
            
            
    }
    
    
    /**
     * Set shader value matrix
     */
    public static void rlSetUniformMatrix(
            int locIndex,  
            Matrix mat 
        ){
            
            com.raylib.jextract.raylib_h.rlSetUniformMatrix(
            locIndex, mat.memorySegment
        );
            
            
    }
    
    
    /**
     * Set shader value matrices
     */
    public static void rlSetUniformMatrices(
            int locIndex,  
            MemorySegment mat,  
            int count 
        ){
            
            com.raylib.jextract.raylib_h.rlSetUniformMatrices(
            locIndex, mat, count
        );
            
            
    }
    
    
    /**
     * Set shader value sampler
     */
    public static void rlSetUniformSampler(
            int locIndex,  
            int textureId 
        ){
            
            com.raylib.jextract.raylib_h.rlSetUniformSampler(
            locIndex, textureId
        );
            
            
    }
    
    
    /**
     * Set shader currently active (id and locations)
     */
    public static void rlSetShader(
            int id,  
            java.nio.IntBuffer locs 
        ){
            
            com.raylib.jextract.raylib_h.rlSetShader(
            id, locs == null ? MemorySegment.NULL : MemorySegment.ofBuffer(locs)
        );
            
            
    }
    
    
    /**
     * Load compute shader program
     */
    public static int rlLoadComputeShaderProgram(
            int shaderId 
        ){
            
            return com.raylib.jextract.raylib_h.rlLoadComputeShaderProgram(
            shaderId
        );
            
    }
    
    
    /**
     * Dispatch compute shader (equivalent to *draw* for graphics pipeline)
     */
    public static void rlComputeShaderDispatch(
            int groupX,  
            int groupY,  
            int groupZ 
        ){
            
            com.raylib.jextract.raylib_h.rlComputeShaderDispatch(
            groupX, groupY, groupZ
        );
            
            
    }
    
    
    /**
     * Load shader storage buffer object (SSBO)
     */
    public static int rlLoadShaderBuffer(
            int size,  
            MemorySegment data,  
            int usageHint 
        ){
            
            return com.raylib.jextract.raylib_h.rlLoadShaderBuffer(
            size, data, usageHint
        );
            
    }
    
    
    /**
     * Unload shader storage buffer object (SSBO)
     */
    public static void rlUnloadShaderBuffer(
            int ssboId 
        ){
            
            com.raylib.jextract.raylib_h.rlUnloadShaderBuffer(
            ssboId
        );
            
            
    }
    
    
    /**
     * Update SSBO buffer data
     */
    public static void rlUpdateShaderBuffer(
            int id,  
            MemorySegment data,  
            int dataSize,  
            int offset 
        ){
            
            com.raylib.jextract.raylib_h.rlUpdateShaderBuffer(
            id, data, dataSize, offset
        );
            
            
    }
    
    
    /**
     * Bind SSBO buffer
     */
    public static void rlBindShaderBuffer(
            int id,  
            int index 
        ){
            
            com.raylib.jextract.raylib_h.rlBindShaderBuffer(
            id, index
        );
            
            
    }
    
    
    /**
     * Read SSBO buffer data (GPU->CPU)
     */
    public static void rlReadShaderBuffer(
            int id,  
            MemorySegment dest,  
            int count,  
            int offset 
        ){
            
            com.raylib.jextract.raylib_h.rlReadShaderBuffer(
            id, dest, count, offset
        );
            
            
    }
    
    
    /**
     * Copy SSBO data between buffers
     */
    public static void rlCopyShaderBuffer(
            int destId,  
            int srcId,  
            int destOffset,  
            int srcOffset,  
            int count 
        ){
            
            com.raylib.jextract.raylib_h.rlCopyShaderBuffer(
            destId, srcId, destOffset, srcOffset, count
        );
            
            
    }
    
    
    /**
     * Get SSBO buffer size
     */
    public static int rlGetShaderBufferSize(
            int id 
        ){
            
            return com.raylib.jextract.raylib_h.rlGetShaderBufferSize(
            id
        );
            
    }
    
    
    /**
     * Bind image texture
     */
    public static void rlBindImageTexture(
            int id,  
            int index,  
            int format,  
            boolean readonly 
        ){
            
            com.raylib.jextract.raylib_h.rlBindImageTexture(
            id, index, format, readonly
        );
            
            
    }
    
    
    /**
     * Get internal modelview matrix
     */
    public static Matrix rlGetMatrixModelview(
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.rlGetMatrixModelview(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * Get internal modelview matrix
     */
    public static Matrix rlGetMatrixModelview(Arena arena 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.rlGetMatrixModelview(arena
            
        ));
            
            
    }
    
    
    /**
     * Get internal projection matrix
     */
    public static Matrix rlGetMatrixProjection(
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.rlGetMatrixProjection(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * Get internal projection matrix
     */
    public static Matrix rlGetMatrixProjection(Arena arena 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.rlGetMatrixProjection(arena
            
        ));
            
            
    }
    
    
    /**
     * Get internal accumulated transform matrix
     */
    public static Matrix rlGetMatrixTransform(
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.rlGetMatrixTransform(Arena.ofAuto()
            
        ));
            
            
    }
    
    /**
     * Get internal accumulated transform matrix
     */
    public static Matrix rlGetMatrixTransform(Arena arena 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.rlGetMatrixTransform(arena
            
        ));
            
            
    }
    
    
    /**
     * Get internal projection matrix for stereo render (selected eye)
     */
    public static Matrix rlGetMatrixProjectionStereo(
            int eye 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.rlGetMatrixProjectionStereo(Arena.ofAuto(), 
            eye
        ));
            
            
    }
    
    /**
     * Get internal projection matrix for stereo render (selected eye)
     */
    public static Matrix rlGetMatrixProjectionStereo(Arena arena,  
            int eye 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.rlGetMatrixProjectionStereo(arena, 
            eye
        ));
            
            
    }
    
    
    /**
     * Get internal view offset matrix for stereo render (selected eye)
     */
    public static Matrix rlGetMatrixViewOffsetStereo(
            int eye 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.rlGetMatrixViewOffsetStereo(Arena.ofAuto(), 
            eye
        ));
            
            
    }
    
    /**
     * Get internal view offset matrix for stereo render (selected eye)
     */
    public static Matrix rlGetMatrixViewOffsetStereo(Arena arena,  
            int eye 
        ){
            
             return new Matrix(com.raylib.jextract.raylib_h.rlGetMatrixViewOffsetStereo(arena, 
            eye
        ));
            
            
    }
    
    
    /**
     * Set a custom projection matrix (replaces internal projection matrix)
     */
    public static void rlSetMatrixProjection(
            Matrix proj 
        ){
            
            com.raylib.jextract.raylib_h.rlSetMatrixProjection(
            proj.memorySegment
        );
            
            
    }
    
    
    /**
     * Set a custom modelview matrix (replaces internal modelview matrix)
     */
    public static void rlSetMatrixModelview(
            Matrix view 
        ){
            
            com.raylib.jextract.raylib_h.rlSetMatrixModelview(
            view.memorySegment
        );
            
            
    }
    
    
    /**
     * Set eyes projection matrices for stereo rendering
     */
    public static void rlSetMatrixProjectionStereo(
            Matrix right,  
            Matrix left 
        ){
            
            com.raylib.jextract.raylib_h.rlSetMatrixProjectionStereo(
            right.memorySegment, left.memorySegment
        );
            
            
    }
    
    
    /**
     * Set eyes view offsets matrices for stereo rendering
     */
    public static void rlSetMatrixViewOffsetStereo(
            Matrix right,  
            Matrix left 
        ){
            
            com.raylib.jextract.raylib_h.rlSetMatrixViewOffsetStereo(
            right.memorySegment, left.memorySegment
        );
            
            
    }
    
    
    /**
     * Load and draw a cube
     */
    public static void rlLoadDrawCube(
        ){
            
            com.raylib.jextract.raylib_h.rlLoadDrawCube(
            
        );
            
            
    }
    
    
    /**
     * Load and draw a quad
     */
    public static void rlLoadDrawQuad(
        ){
            
            com.raylib.jextract.raylib_h.rlLoadDrawQuad(
            
        );
            
            
    }
    
    

    
    /** System/Window config flags */
public static class ConfigFlags{
        
        /** Set to try enabling V-Sync on GPU */
        public static final int FLAG_VSYNC_HINT = 64;
        /** Set to run program in fullscreen */
        public static final int FLAG_FULLSCREEN_MODE = 2;
        /** Set to allow resizable window */
        public static final int FLAG_WINDOW_RESIZABLE = 4;
        /** Set to disable window decoration (frame and buttons) */
        public static final int FLAG_WINDOW_UNDECORATED = 8;
        /** Set to hide window */
        public static final int FLAG_WINDOW_HIDDEN = 128;
        /** Set to minimize window (iconify) */
        public static final int FLAG_WINDOW_MINIMIZED = 512;
        /** Set to maximize window (expanded to monitor) */
        public static final int FLAG_WINDOW_MAXIMIZED = 1024;
        /** Set to window non focused */
        public static final int FLAG_WINDOW_UNFOCUSED = 2048;
        /** Set to window always on top */
        public static final int FLAG_WINDOW_TOPMOST = 4096;
        /** Set to allow windows running while minimized */
        public static final int FLAG_WINDOW_ALWAYS_RUN = 256;
        /** Set to allow transparent framebuffer */
        public static final int FLAG_WINDOW_TRANSPARENT = 16;
        /** Set to support HighDPI */
        public static final int FLAG_WINDOW_HIGHDPI = 8192;
        /** Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED */
        public static final int FLAG_WINDOW_MOUSE_PASSTHROUGH = 16384;
        /** Set to run program in borderless windowed mode */
        public static final int FLAG_BORDERLESS_WINDOWED_MODE = 32768;
        /** Set to try enabling MSAA 4X */
        public static final int FLAG_MSAA_4X_HINT = 32;
        /** Set to try enabling interlaced video format (for V3D) */
        public static final int FLAG_INTERLACED_HINT = 65536;
    }
    
    /** Trace log level */
public static class TraceLogLevel{
        
        /** Display all logs */
        public static final int LOG_ALL = 0;
        /** Trace logging, intended for internal use only */
        public static final int LOG_TRACE = 1;
        /** Debug logging, used for internal debugging, it should be disabled on release builds */
        public static final int LOG_DEBUG = 2;
        /** Info logging, used for program execution info */
        public static final int LOG_INFO = 3;
        /** Warning logging, used on recoverable failures */
        public static final int LOG_WARNING = 4;
        /** Error logging, used on unrecoverable failures */
        public static final int LOG_ERROR = 5;
        /** Fatal logging, used to abort program: exit(EXIT_FAILURE) */
        public static final int LOG_FATAL = 6;
        /** Disable logging */
        public static final int LOG_NONE = 7;
    }
    
    /** Keyboard keys (US keyboard layout) */
public static class KeyboardKey{
        
        /** Key: NULL, used for no key pressed */
        public static final int KEY_NULL = 0;
        /** Key: ' */
        public static final int KEY_APOSTROPHE = 39;
        /** Key: , */
        public static final int KEY_COMMA = 44;
        /** Key: - */
        public static final int KEY_MINUS = 45;
        /** Key: . */
        public static final int KEY_PERIOD = 46;
        /** Key: / */
        public static final int KEY_SLASH = 47;
        /** Key: 0 */
        public static final int KEY_ZERO = 48;
        /** Key: 1 */
        public static final int KEY_ONE = 49;
        /** Key: 2 */
        public static final int KEY_TWO = 50;
        /** Key: 3 */
        public static final int KEY_THREE = 51;
        /** Key: 4 */
        public static final int KEY_FOUR = 52;
        /** Key: 5 */
        public static final int KEY_FIVE = 53;
        /** Key: 6 */
        public static final int KEY_SIX = 54;
        /** Key: 7 */
        public static final int KEY_SEVEN = 55;
        /** Key: 8 */
        public static final int KEY_EIGHT = 56;
        /** Key: 9 */
        public static final int KEY_NINE = 57;
        /** Key: ; */
        public static final int KEY_SEMICOLON = 59;
        /** Key: = */
        public static final int KEY_EQUAL = 61;
        /** Key: A | a */
        public static final int KEY_A = 65;
        /** Key: B | b */
        public static final int KEY_B = 66;
        /** Key: C | c */
        public static final int KEY_C = 67;
        /** Key: D | d */
        public static final int KEY_D = 68;
        /** Key: E | e */
        public static final int KEY_E = 69;
        /** Key: F | f */
        public static final int KEY_F = 70;
        /** Key: G | g */
        public static final int KEY_G = 71;
        /** Key: H | h */
        public static final int KEY_H = 72;
        /** Key: I | i */
        public static final int KEY_I = 73;
        /** Key: J | j */
        public static final int KEY_J = 74;
        /** Key: K | k */
        public static final int KEY_K = 75;
        /** Key: L | l */
        public static final int KEY_L = 76;
        /** Key: M | m */
        public static final int KEY_M = 77;
        /** Key: N | n */
        public static final int KEY_N = 78;
        /** Key: O | o */
        public static final int KEY_O = 79;
        /** Key: P | p */
        public static final int KEY_P = 80;
        /** Key: Q | q */
        public static final int KEY_Q = 81;
        /** Key: R | r */
        public static final int KEY_R = 82;
        /** Key: S | s */
        public static final int KEY_S = 83;
        /** Key: T | t */
        public static final int KEY_T = 84;
        /** Key: U | u */
        public static final int KEY_U = 85;
        /** Key: V | v */
        public static final int KEY_V = 86;
        /** Key: W | w */
        public static final int KEY_W = 87;
        /** Key: X | x */
        public static final int KEY_X = 88;
        /** Key: Y | y */
        public static final int KEY_Y = 89;
        /** Key: Z | z */
        public static final int KEY_Z = 90;
        /** Key: [ */
        public static final int KEY_LEFT_BRACKET = 91;
        /** Key: '\' */
        public static final int KEY_BACKSLASH = 92;
        /** Key: ] */
        public static final int KEY_RIGHT_BRACKET = 93;
        /** Key: ` */
        public static final int KEY_GRAVE = 96;
        /** Key: Space */
        public static final int KEY_SPACE = 32;
        /** Key: Esc */
        public static final int KEY_ESCAPE = 256;
        /** Key: Enter */
        public static final int KEY_ENTER = 257;
        /** Key: Tab */
        public static final int KEY_TAB = 258;
        /** Key: Backspace */
        public static final int KEY_BACKSPACE = 259;
        /** Key: Ins */
        public static final int KEY_INSERT = 260;
        /** Key: Del */
        public static final int KEY_DELETE = 261;
        /** Key: Cursor right */
        public static final int KEY_RIGHT = 262;
        /** Key: Cursor left */
        public static final int KEY_LEFT = 263;
        /** Key: Cursor down */
        public static final int KEY_DOWN = 264;
        /** Key: Cursor up */
        public static final int KEY_UP = 265;
        /** Key: Page up */
        public static final int KEY_PAGE_UP = 266;
        /** Key: Page down */
        public static final int KEY_PAGE_DOWN = 267;
        /** Key: Home */
        public static final int KEY_HOME = 268;
        /** Key: End */
        public static final int KEY_END = 269;
        /** Key: Caps lock */
        public static final int KEY_CAPS_LOCK = 280;
        /** Key: Scroll down */
        public static final int KEY_SCROLL_LOCK = 281;
        /** Key: Num lock */
        public static final int KEY_NUM_LOCK = 282;
        /** Key: Print screen */
        public static final int KEY_PRINT_SCREEN = 283;
        /** Key: Pause */
        public static final int KEY_PAUSE = 284;
        /** Key: F1 */
        public static final int KEY_F1 = 290;
        /** Key: F2 */
        public static final int KEY_F2 = 291;
        /** Key: F3 */
        public static final int KEY_F3 = 292;
        /** Key: F4 */
        public static final int KEY_F4 = 293;
        /** Key: F5 */
        public static final int KEY_F5 = 294;
        /** Key: F6 */
        public static final int KEY_F6 = 295;
        /** Key: F7 */
        public static final int KEY_F7 = 296;
        /** Key: F8 */
        public static final int KEY_F8 = 297;
        /** Key: F9 */
        public static final int KEY_F9 = 298;
        /** Key: F10 */
        public static final int KEY_F10 = 299;
        /** Key: F11 */
        public static final int KEY_F11 = 300;
        /** Key: F12 */
        public static final int KEY_F12 = 301;
        /** Key: Shift left */
        public static final int KEY_LEFT_SHIFT = 340;
        /** Key: Control left */
        public static final int KEY_LEFT_CONTROL = 341;
        /** Key: Alt left */
        public static final int KEY_LEFT_ALT = 342;
        /** Key: Super left */
        public static final int KEY_LEFT_SUPER = 343;
        /** Key: Shift right */
        public static final int KEY_RIGHT_SHIFT = 344;
        /** Key: Control right */
        public static final int KEY_RIGHT_CONTROL = 345;
        /** Key: Alt right */
        public static final int KEY_RIGHT_ALT = 346;
        /** Key: Super right */
        public static final int KEY_RIGHT_SUPER = 347;
        /** Key: KB menu */
        public static final int KEY_KB_MENU = 348;
        /** Key: Keypad 0 */
        public static final int KEY_KP_0 = 320;
        /** Key: Keypad 1 */
        public static final int KEY_KP_1 = 321;
        /** Key: Keypad 2 */
        public static final int KEY_KP_2 = 322;
        /** Key: Keypad 3 */
        public static final int KEY_KP_3 = 323;
        /** Key: Keypad 4 */
        public static final int KEY_KP_4 = 324;
        /** Key: Keypad 5 */
        public static final int KEY_KP_5 = 325;
        /** Key: Keypad 6 */
        public static final int KEY_KP_6 = 326;
        /** Key: Keypad 7 */
        public static final int KEY_KP_7 = 327;
        /** Key: Keypad 8 */
        public static final int KEY_KP_8 = 328;
        /** Key: Keypad 9 */
        public static final int KEY_KP_9 = 329;
        /** Key: Keypad . */
        public static final int KEY_KP_DECIMAL = 330;
        /** Key: Keypad / */
        public static final int KEY_KP_DIVIDE = 331;
        /** Key: Keypad * */
        public static final int KEY_KP_MULTIPLY = 332;
        /** Key: Keypad - */
        public static final int KEY_KP_SUBTRACT = 333;
        /** Key: Keypad + */
        public static final int KEY_KP_ADD = 334;
        /** Key: Keypad Enter */
        public static final int KEY_KP_ENTER = 335;
        /** Key: Keypad = */
        public static final int KEY_KP_EQUAL = 336;
        /** Key: Android back button */
        public static final int KEY_BACK = 4;
        /** Key: Android menu button */
        public static final int KEY_MENU = 5;
        /** Key: Android volume up button */
        public static final int KEY_VOLUME_UP = 24;
        /** Key: Android volume down button */
        public static final int KEY_VOLUME_DOWN = 25;
    }
    
    /** Mouse buttons */
public static class MouseButton{
        
        /** Mouse button left */
        public static final int MOUSE_BUTTON_LEFT = 0;
        /** Mouse button right */
        public static final int MOUSE_BUTTON_RIGHT = 1;
        /** Mouse button middle (pressed wheel) */
        public static final int MOUSE_BUTTON_MIDDLE = 2;
        /** Mouse button side (advanced mouse device) */
        public static final int MOUSE_BUTTON_SIDE = 3;
        /** Mouse button extra (advanced mouse device) */
        public static final int MOUSE_BUTTON_EXTRA = 4;
        /** Mouse button forward (advanced mouse device) */
        public static final int MOUSE_BUTTON_FORWARD = 5;
        /** Mouse button back (advanced mouse device) */
        public static final int MOUSE_BUTTON_BACK = 6;
    }
    
    /** Mouse cursor */
public static class MouseCursor{
        
        /** Default pointer shape */
        public static final int MOUSE_CURSOR_DEFAULT = 0;
        /** Arrow shape */
        public static final int MOUSE_CURSOR_ARROW = 1;
        /** Text writing cursor shape */
        public static final int MOUSE_CURSOR_IBEAM = 2;
        /** Cross shape */
        public static final int MOUSE_CURSOR_CROSSHAIR = 3;
        /** Pointing hand cursor */
        public static final int MOUSE_CURSOR_POINTING_HAND = 4;
        /** Horizontal resize/move arrow shape */
        public static final int MOUSE_CURSOR_RESIZE_EW = 5;
        /** Vertical resize/move arrow shape */
        public static final int MOUSE_CURSOR_RESIZE_NS = 6;
        /** Top-left to bottom-right diagonal resize/move arrow shape */
        public static final int MOUSE_CURSOR_RESIZE_NWSE = 7;
        /** The top-right to bottom-left diagonal resize/move arrow shape */
        public static final int MOUSE_CURSOR_RESIZE_NESW = 8;
        /** The omnidirectional resize/move cursor shape */
        public static final int MOUSE_CURSOR_RESIZE_ALL = 9;
        /** The operation-not-allowed shape */
        public static final int MOUSE_CURSOR_NOT_ALLOWED = 10;
    }
    
    /** Gamepad buttons */
public static class GamepadButton{
        
        /** Unknown button, just for error checking */
        public static final int GAMEPAD_BUTTON_UNKNOWN = 0;
        /** Gamepad left DPAD up button */
        public static final int GAMEPAD_BUTTON_LEFT_FACE_UP = 1;
        /** Gamepad left DPAD right button */
        public static final int GAMEPAD_BUTTON_LEFT_FACE_RIGHT = 2;
        /** Gamepad left DPAD down button */
        public static final int GAMEPAD_BUTTON_LEFT_FACE_DOWN = 3;
        /** Gamepad left DPAD left button */
        public static final int GAMEPAD_BUTTON_LEFT_FACE_LEFT = 4;
        /** Gamepad right button up (i.e. PS3: Triangle, Xbox: Y) */
        public static final int GAMEPAD_BUTTON_RIGHT_FACE_UP = 5;
        /** Gamepad right button right (i.e. PS3: Circle, Xbox: B) */
        public static final int GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = 6;
        /** Gamepad right button down (i.e. PS3: Cross, Xbox: A) */
        public static final int GAMEPAD_BUTTON_RIGHT_FACE_DOWN = 7;
        /** Gamepad right button left (i.e. PS3: Square, Xbox: X) */
        public static final int GAMEPAD_BUTTON_RIGHT_FACE_LEFT = 8;
        /** Gamepad top/back trigger left (first), it could be a trailing button */
        public static final int GAMEPAD_BUTTON_LEFT_TRIGGER_1 = 9;
        /** Gamepad top/back trigger left (second), it could be a trailing button */
        public static final int GAMEPAD_BUTTON_LEFT_TRIGGER_2 = 10;
        /** Gamepad top/back trigger right (first), it could be a trailing button */
        public static final int GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = 11;
        /** Gamepad top/back trigger right (second), it could be a trailing button */
        public static final int GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = 12;
        /** Gamepad center buttons, left one (i.e. PS3: Select) */
        public static final int GAMEPAD_BUTTON_MIDDLE_LEFT = 13;
        /** Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX) */
        public static final int GAMEPAD_BUTTON_MIDDLE = 14;
        /** Gamepad center buttons, right one (i.e. PS3: Start) */
        public static final int GAMEPAD_BUTTON_MIDDLE_RIGHT = 15;
        /** Gamepad joystick pressed button left */
        public static final int GAMEPAD_BUTTON_LEFT_THUMB = 16;
        /** Gamepad joystick pressed button right */
        public static final int GAMEPAD_BUTTON_RIGHT_THUMB = 17;
    }
    
    /** Gamepad axis */
public static class GamepadAxis{
        
        /** Gamepad left stick X axis */
        public static final int GAMEPAD_AXIS_LEFT_X = 0;
        /** Gamepad left stick Y axis */
        public static final int GAMEPAD_AXIS_LEFT_Y = 1;
        /** Gamepad right stick X axis */
        public static final int GAMEPAD_AXIS_RIGHT_X = 2;
        /** Gamepad right stick Y axis */
        public static final int GAMEPAD_AXIS_RIGHT_Y = 3;
        /** Gamepad back trigger left, pressure level: [1..-1] */
        public static final int GAMEPAD_AXIS_LEFT_TRIGGER = 4;
        /** Gamepad back trigger right, pressure level: [1..-1] */
        public static final int GAMEPAD_AXIS_RIGHT_TRIGGER = 5;
    }
    
    /** Material map index */
public static class MaterialMapIndex{
        
        /** Albedo material (same as: MATERIAL_MAP_DIFFUSE) */
        public static final int MATERIAL_MAP_ALBEDO = 0;
        /** Metalness material (same as: MATERIAL_MAP_SPECULAR) */
        public static final int MATERIAL_MAP_METALNESS = 1;
        /** Normal material */
        public static final int MATERIAL_MAP_NORMAL = 2;
        /** Roughness material */
        public static final int MATERIAL_MAP_ROUGHNESS = 3;
        /** Ambient occlusion material */
        public static final int MATERIAL_MAP_OCCLUSION = 4;
        /** Emission material */
        public static final int MATERIAL_MAP_EMISSION = 5;
        /** Heightmap material */
        public static final int MATERIAL_MAP_HEIGHT = 6;
        /** Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP) */
        public static final int MATERIAL_MAP_CUBEMAP = 7;
        /** Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP) */
        public static final int MATERIAL_MAP_IRRADIANCE = 8;
        /** Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP) */
        public static final int MATERIAL_MAP_PREFILTER = 9;
        /** Brdf material */
        public static final int MATERIAL_MAP_BRDF = 10;
    }
    
    /** Shader location index */
public static class ShaderLocationIndex{
        
        /** Shader location: vertex attribute: position */
        public static final int SHADER_LOC_VERTEX_POSITION = 0;
        /** Shader location: vertex attribute: texcoord01 */
        public static final int SHADER_LOC_VERTEX_TEXCOORD01 = 1;
        /** Shader location: vertex attribute: texcoord02 */
        public static final int SHADER_LOC_VERTEX_TEXCOORD02 = 2;
        /** Shader location: vertex attribute: normal */
        public static final int SHADER_LOC_VERTEX_NORMAL = 3;
        /** Shader location: vertex attribute: tangent */
        public static final int SHADER_LOC_VERTEX_TANGENT = 4;
        /** Shader location: vertex attribute: color */
        public static final int SHADER_LOC_VERTEX_COLOR = 5;
        /** Shader location: matrix uniform: model-view-projection */
        public static final int SHADER_LOC_MATRIX_MVP = 6;
        /** Shader location: matrix uniform: view (camera transform) */
        public static final int SHADER_LOC_MATRIX_VIEW = 7;
        /** Shader location: matrix uniform: projection */
        public static final int SHADER_LOC_MATRIX_PROJECTION = 8;
        /** Shader location: matrix uniform: model (transform) */
        public static final int SHADER_LOC_MATRIX_MODEL = 9;
        /** Shader location: matrix uniform: normal */
        public static final int SHADER_LOC_MATRIX_NORMAL = 10;
        /** Shader location: vector uniform: view */
        public static final int SHADER_LOC_VECTOR_VIEW = 11;
        /** Shader location: vector uniform: diffuse color */
        public static final int SHADER_LOC_COLOR_DIFFUSE = 12;
        /** Shader location: vector uniform: specular color */
        public static final int SHADER_LOC_COLOR_SPECULAR = 13;
        /** Shader location: vector uniform: ambient color */
        public static final int SHADER_LOC_COLOR_AMBIENT = 14;
        /** Shader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE) */
        public static final int SHADER_LOC_MAP_ALBEDO = 15;
        /** Shader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR) */
        public static final int SHADER_LOC_MAP_METALNESS = 16;
        /** Shader location: sampler2d texture: normal */
        public static final int SHADER_LOC_MAP_NORMAL = 17;
        /** Shader location: sampler2d texture: roughness */
        public static final int SHADER_LOC_MAP_ROUGHNESS = 18;
        /** Shader location: sampler2d texture: occlusion */
        public static final int SHADER_LOC_MAP_OCCLUSION = 19;
        /** Shader location: sampler2d texture: emission */
        public static final int SHADER_LOC_MAP_EMISSION = 20;
        /** Shader location: sampler2d texture: height */
        public static final int SHADER_LOC_MAP_HEIGHT = 21;
        /** Shader location: samplerCube texture: cubemap */
        public static final int SHADER_LOC_MAP_CUBEMAP = 22;
        /** Shader location: samplerCube texture: irradiance */
        public static final int SHADER_LOC_MAP_IRRADIANCE = 23;
        /** Shader location: samplerCube texture: prefilter */
        public static final int SHADER_LOC_MAP_PREFILTER = 24;
        /** Shader location: sampler2d texture: brdf */
        public static final int SHADER_LOC_MAP_BRDF = 25;
        /** Shader location: vertex attribute: boneIds */
        public static final int SHADER_LOC_VERTEX_BONEIDS = 26;
        /** Shader location: vertex attribute: boneWeights */
        public static final int SHADER_LOC_VERTEX_BONEWEIGHTS = 27;
        /** Shader location: array of matrices uniform: boneMatrices */
        public static final int SHADER_LOC_BONE_MATRICES = 28;
    }
    
    /** Shader uniform data type */
public static class ShaderUniformDataType{
        
        /** Shader uniform type: float */
        public static final int SHADER_UNIFORM_FLOAT = 0;
        /** Shader uniform type: vec2 (2 float) */
        public static final int SHADER_UNIFORM_VEC2 = 1;
        /** Shader uniform type: vec3 (3 float) */
        public static final int SHADER_UNIFORM_VEC3 = 2;
        /** Shader uniform type: vec4 (4 float) */
        public static final int SHADER_UNIFORM_VEC4 = 3;
        /** Shader uniform type: int */
        public static final int SHADER_UNIFORM_INT = 4;
        /** Shader uniform type: ivec2 (2 int) */
        public static final int SHADER_UNIFORM_IVEC2 = 5;
        /** Shader uniform type: ivec3 (3 int) */
        public static final int SHADER_UNIFORM_IVEC3 = 6;
        /** Shader uniform type: ivec4 (4 int) */
        public static final int SHADER_UNIFORM_IVEC4 = 7;
        /** Shader uniform type: sampler2d */
        public static final int SHADER_UNIFORM_SAMPLER2D = 8;
    }
    
    /** Shader attribute data types */
public static class ShaderAttributeDataType{
        
        /** Shader attribute type: float */
        public static final int SHADER_ATTRIB_FLOAT = 0;
        /** Shader attribute type: vec2 (2 float) */
        public static final int SHADER_ATTRIB_VEC2 = 1;
        /** Shader attribute type: vec3 (3 float) */
        public static final int SHADER_ATTRIB_VEC3 = 2;
        /** Shader attribute type: vec4 (4 float) */
        public static final int SHADER_ATTRIB_VEC4 = 3;
    }
    
    /** Pixel formats */
public static class PixelFormat{
        
        /** 8 bit per pixel (no alpha) */
        public static final int PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1;
        /** 8*2 bpp (2 channels) */
        public static final int PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = 2;
        /** 16 bpp */
        public static final int PIXELFORMAT_UNCOMPRESSED_R5G6B5 = 3;
        /** 24 bpp */
        public static final int PIXELFORMAT_UNCOMPRESSED_R8G8B8 = 4;
        /** 16 bpp (1 bit alpha) */
        public static final int PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = 5;
        /** 16 bpp (4 bit alpha) */
        public static final int PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = 6;
        /** 32 bpp */
        public static final int PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = 7;
        /** 32 bpp (1 channel - float) */
        public static final int PIXELFORMAT_UNCOMPRESSED_R32 = 8;
        /** 32*3 bpp (3 channels - float) */
        public static final int PIXELFORMAT_UNCOMPRESSED_R32G32B32 = 9;
        /** 32*4 bpp (4 channels - float) */
        public static final int PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = 10;
        /** 16 bpp (1 channel - half float) */
        public static final int PIXELFORMAT_UNCOMPRESSED_R16 = 11;
        /** 16*3 bpp (3 channels - half float) */
        public static final int PIXELFORMAT_UNCOMPRESSED_R16G16B16 = 12;
        /** 16*4 bpp (4 channels - half float) */
        public static final int PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = 13;
        /** 4 bpp (no alpha) */
        public static final int PIXELFORMAT_COMPRESSED_DXT1_RGB = 14;
        /** 4 bpp (1 bit alpha) */
        public static final int PIXELFORMAT_COMPRESSED_DXT1_RGBA = 15;
        /** 8 bpp */
        public static final int PIXELFORMAT_COMPRESSED_DXT3_RGBA = 16;
        /** 8 bpp */
        public static final int PIXELFORMAT_COMPRESSED_DXT5_RGBA = 17;
        /** 4 bpp */
        public static final int PIXELFORMAT_COMPRESSED_ETC1_RGB = 18;
        /** 4 bpp */
        public static final int PIXELFORMAT_COMPRESSED_ETC2_RGB = 19;
        /** 8 bpp */
        public static final int PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = 20;
        /** 4 bpp */
        public static final int PIXELFORMAT_COMPRESSED_PVRT_RGB = 21;
        /** 4 bpp */
        public static final int PIXELFORMAT_COMPRESSED_PVRT_RGBA = 22;
        /** 8 bpp */
        public static final int PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = 23;
        /** 2 bpp */
        public static final int PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = 24;
    }
    
    /** Texture parameters: filter mode */
public static class TextureFilter{
        
        /** No filter, just pixel approximation */
        public static final int TEXTURE_FILTER_POINT = 0;
        /** Linear filtering */
        public static final int TEXTURE_FILTER_BILINEAR = 1;
        /** Trilinear filtering (linear with mipmaps) */
        public static final int TEXTURE_FILTER_TRILINEAR = 2;
        /** Anisotropic filtering 4x */
        public static final int TEXTURE_FILTER_ANISOTROPIC_4X = 3;
        /** Anisotropic filtering 8x */
        public static final int TEXTURE_FILTER_ANISOTROPIC_8X = 4;
        /** Anisotropic filtering 16x */
        public static final int TEXTURE_FILTER_ANISOTROPIC_16X = 5;
    }
    
    /** Texture parameters: wrap mode */
public static class TextureWrap{
        
        /** Repeats texture in tiled mode */
        public static final int TEXTURE_WRAP_REPEAT = 0;
        /** Clamps texture to edge pixel in tiled mode */
        public static final int TEXTURE_WRAP_CLAMP = 1;
        /** Mirrors and repeats the texture in tiled mode */
        public static final int TEXTURE_WRAP_MIRROR_REPEAT = 2;
        /** Mirrors and clamps to border the texture in tiled mode */
        public static final int TEXTURE_WRAP_MIRROR_CLAMP = 3;
    }
    
    /** Cubemap layouts */
public static class CubemapLayout{
        
        /** Automatically detect layout type */
        public static final int CUBEMAP_LAYOUT_AUTO_DETECT = 0;
        /** Layout is defined by a vertical line with faces */
        public static final int CUBEMAP_LAYOUT_LINE_VERTICAL = 1;
        /** Layout is defined by a horizontal line with faces */
        public static final int CUBEMAP_LAYOUT_LINE_HORIZONTAL = 2;
        /** Layout is defined by a 3x4 cross with cubemap faces */
        public static final int CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR = 3;
        /** Layout is defined by a 4x3 cross with cubemap faces */
        public static final int CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE = 4;
    }
    
    /** Font type, defines generation method */
public static class FontType{
        
        /** Default font generation, anti-aliased */
        public static final int FONT_DEFAULT = 0;
        /** Bitmap font generation, no anti-aliasing */
        public static final int FONT_BITMAP = 1;
        /** SDF font generation, requires external shader */
        public static final int FONT_SDF = 2;
    }
    
    /** Color blending modes (pre-defined) */
public static class BlendMode{
        
        /** Blend textures considering alpha (default) */
        public static final int BLEND_ALPHA = 0;
        /** Blend textures adding colors */
        public static final int BLEND_ADDITIVE = 1;
        /** Blend textures multiplying colors */
        public static final int BLEND_MULTIPLIED = 2;
        /** Blend textures adding colors (alternative) */
        public static final int BLEND_ADD_COLORS = 3;
        /** Blend textures subtracting colors (alternative) */
        public static final int BLEND_SUBTRACT_COLORS = 4;
        /** Blend premultiplied textures considering alpha */
        public static final int BLEND_ALPHA_PREMULTIPLY = 5;
        /** Blend textures using custom src/dst factors (use rlSetBlendFactors()) */
        public static final int BLEND_CUSTOM = 6;
        /** Blend textures using custom rgb/alpha separate src/dst factors (use rlSetBlendFactorsSeparate()) */
        public static final int BLEND_CUSTOM_SEPARATE = 7;
    }
    
    /** Gesture */
public static class Gesture{
        
        /** No gesture */
        public static final int GESTURE_NONE = 0;
        /** Tap gesture */
        public static final int GESTURE_TAP = 1;
        /** Double tap gesture */
        public static final int GESTURE_DOUBLETAP = 2;
        /** Hold gesture */
        public static final int GESTURE_HOLD = 4;
        /** Drag gesture */
        public static final int GESTURE_DRAG = 8;
        /** Swipe right gesture */
        public static final int GESTURE_SWIPE_RIGHT = 16;
        /** Swipe left gesture */
        public static final int GESTURE_SWIPE_LEFT = 32;
        /** Swipe up gesture */
        public static final int GESTURE_SWIPE_UP = 64;
        /** Swipe down gesture */
        public static final int GESTURE_SWIPE_DOWN = 128;
        /** Pinch in gesture */
        public static final int GESTURE_PINCH_IN = 256;
        /** Pinch out gesture */
        public static final int GESTURE_PINCH_OUT = 512;
    }
    
    /** Camera system modes */
public static class CameraMode{
        
        /** Camera custom, controlled by user (UpdateCamera() does nothing) */
        public static final int CAMERA_CUSTOM = 0;
        /** Camera free mode */
        public static final int CAMERA_FREE = 1;
        /** Camera orbital, around target, zoom supported */
        public static final int CAMERA_ORBITAL = 2;
        /** Camera first person */
        public static final int CAMERA_FIRST_PERSON = 3;
        /** Camera third person */
        public static final int CAMERA_THIRD_PERSON = 4;
    }
    
    /** Camera projection */
public static class CameraProjection{
        
        /** Perspective projection */
        public static final int CAMERA_PERSPECTIVE = 0;
        /** Orthographic projection */
        public static final int CAMERA_ORTHOGRAPHIC = 1;
    }
    
    /** N-patch layout */
public static class NPatchLayout{
        
        /** Npatch layout: 3x3 tiles */
        public static final int NPATCH_NINE_PATCH = 0;
        /** Npatch layout: 1x3 tiles */
        public static final int NPATCH_THREE_PATCH_VERTICAL = 1;
        /** Npatch layout: 3x1 tiles */
        public static final int NPATCH_THREE_PATCH_HORIZONTAL = 2;
    }
    
    /** OpenGL version */
public static class rlGlVersion{
        
        /** OpenGL 1.1 */
        public static final int RL_OPENGL_11 = 1;
        /** OpenGL 2.1 (GLSL 120) */
        public static final int RL_OPENGL_21 = 2;
        /** OpenGL 3.3 (GLSL 330) */
        public static final int RL_OPENGL_33 = 3;
        /** OpenGL 4.3 (using GLSL 330) */
        public static final int RL_OPENGL_43 = 4;
        /** OpenGL ES 2.0 (GLSL 100) */
        public static final int RL_OPENGL_ES_20 = 5;
        /** OpenGL ES 3.0 (GLSL 300 es) */
        public static final int RL_OPENGL_ES_30 = 6;
    }
    
    /** Trace log level */
public static class rlTraceLogLevel{
        
        /** Display all logs */
        public static final int RL_LOG_ALL = 0;
        /** Trace logging, intended for internal use only */
        public static final int RL_LOG_TRACE = 1;
        /** Debug logging, used for internal debugging, it should be disabled on release builds */
        public static final int RL_LOG_DEBUG = 2;
        /** Info logging, used for program execution info */
        public static final int RL_LOG_INFO = 3;
        /** Warning logging, used on recoverable failures */
        public static final int RL_LOG_WARNING = 4;
        /** Error logging, used on unrecoverable failures */
        public static final int RL_LOG_ERROR = 5;
        /** Fatal logging, used to abort program: exit(EXIT_FAILURE) */
        public static final int RL_LOG_FATAL = 6;
        /** Disable logging */
        public static final int RL_LOG_NONE = 7;
    }
    
    /** Texture pixel formats */
public static class rlPixelFormat{
        
        /** 8 bit per pixel (no alpha) */
        public static final int RL_PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1;
        /** 8*2 bpp (2 channels) */
        public static final int RL_PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = 2;
        /** 16 bpp */
        public static final int RL_PIXELFORMAT_UNCOMPRESSED_R5G6B5 = 3;
        /** 24 bpp */
        public static final int RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8 = 4;
        /** 16 bpp (1 bit alpha) */
        public static final int RL_PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = 5;
        /** 16 bpp (4 bit alpha) */
        public static final int RL_PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = 6;
        /** 32 bpp */
        public static final int RL_PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = 7;
        /** 32 bpp (1 channel - float) */
        public static final int RL_PIXELFORMAT_UNCOMPRESSED_R32 = 8;
        /** 32*3 bpp (3 channels - float) */
        public static final int RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32 = 9;
        /** 32*4 bpp (4 channels - float) */
        public static final int RL_PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = 10;
        /** 16 bpp (1 channel - half float) */
        public static final int RL_PIXELFORMAT_UNCOMPRESSED_R16 = 11;
        /** 16*3 bpp (3 channels - half float) */
        public static final int RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16 = 12;
        /** 16*4 bpp (4 channels - half float) */
        public static final int RL_PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = 13;
        /** 4 bpp (no alpha) */
        public static final int RL_PIXELFORMAT_COMPRESSED_DXT1_RGB = 14;
        /** 4 bpp (1 bit alpha) */
        public static final int RL_PIXELFORMAT_COMPRESSED_DXT1_RGBA = 15;
        /** 8 bpp */
        public static final int RL_PIXELFORMAT_COMPRESSED_DXT3_RGBA = 16;
        /** 8 bpp */
        public static final int RL_PIXELFORMAT_COMPRESSED_DXT5_RGBA = 17;
        /** 4 bpp */
        public static final int RL_PIXELFORMAT_COMPRESSED_ETC1_RGB = 18;
        /** 4 bpp */
        public static final int RL_PIXELFORMAT_COMPRESSED_ETC2_RGB = 19;
        /** 8 bpp */
        public static final int RL_PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = 20;
        /** 4 bpp */
        public static final int RL_PIXELFORMAT_COMPRESSED_PVRT_RGB = 21;
        /** 4 bpp */
        public static final int RL_PIXELFORMAT_COMPRESSED_PVRT_RGBA = 22;
        /** 8 bpp */
        public static final int RL_PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = 23;
        /** 2 bpp */
        public static final int RL_PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = 24;
    }
    
    /** Texture parameters: filter mode */
public static class rlTextureFilter{
        
        /** No filter, just pixel approximation */
        public static final int RL_TEXTURE_FILTER_POINT = 0;
        /** Linear filtering */
        public static final int RL_TEXTURE_FILTER_BILINEAR = 1;
        /** Trilinear filtering (linear with mipmaps) */
        public static final int RL_TEXTURE_FILTER_TRILINEAR = 2;
        /** Anisotropic filtering 4x */
        public static final int RL_TEXTURE_FILTER_ANISOTROPIC_4X = 3;
        /** Anisotropic filtering 8x */
        public static final int RL_TEXTURE_FILTER_ANISOTROPIC_8X = 4;
        /** Anisotropic filtering 16x */
        public static final int RL_TEXTURE_FILTER_ANISOTROPIC_16X = 5;
    }
    
    /** Color blending modes (pre-defined) */
public static class rlBlendMode{
        
        /** Blend textures considering alpha (default) */
        public static final int RL_BLEND_ALPHA = 0;
        /** Blend textures adding colors */
        public static final int RL_BLEND_ADDITIVE = 1;
        /** Blend textures multiplying colors */
        public static final int RL_BLEND_MULTIPLIED = 2;
        /** Blend textures adding colors (alternative) */
        public static final int RL_BLEND_ADD_COLORS = 3;
        /** Blend textures subtracting colors (alternative) */
        public static final int RL_BLEND_SUBTRACT_COLORS = 4;
        /** Blend premultiplied textures considering alpha */
        public static final int RL_BLEND_ALPHA_PREMULTIPLY = 5;
        /** Blend textures using custom src/dst factors (use rlSetBlendFactors()) */
        public static final int RL_BLEND_CUSTOM = 6;
        /** Blend textures using custom src/dst factors (use rlSetBlendFactorsSeparate()) */
        public static final int RL_BLEND_CUSTOM_SEPARATE = 7;
    }
    
    /** Shader location point type */
public static class rlShaderLocationIndex{
        
        /** Shader location: vertex attribute: position */
        public static final int RL_SHADER_LOC_VERTEX_POSITION = 0;
        /** Shader location: vertex attribute: texcoord01 */
        public static final int RL_SHADER_LOC_VERTEX_TEXCOORD01 = 1;
        /** Shader location: vertex attribute: texcoord02 */
        public static final int RL_SHADER_LOC_VERTEX_TEXCOORD02 = 2;
        /** Shader location: vertex attribute: normal */
        public static final int RL_SHADER_LOC_VERTEX_NORMAL = 3;
        /** Shader location: vertex attribute: tangent */
        public static final int RL_SHADER_LOC_VERTEX_TANGENT = 4;
        /** Shader location: vertex attribute: color */
        public static final int RL_SHADER_LOC_VERTEX_COLOR = 5;
        /** Shader location: matrix uniform: model-view-projection */
        public static final int RL_SHADER_LOC_MATRIX_MVP = 6;
        /** Shader location: matrix uniform: view (camera transform) */
        public static final int RL_SHADER_LOC_MATRIX_VIEW = 7;
        /** Shader location: matrix uniform: projection */
        public static final int RL_SHADER_LOC_MATRIX_PROJECTION = 8;
        /** Shader location: matrix uniform: model (transform) */
        public static final int RL_SHADER_LOC_MATRIX_MODEL = 9;
        /** Shader location: matrix uniform: normal */
        public static final int RL_SHADER_LOC_MATRIX_NORMAL = 10;
        /** Shader location: vector uniform: view */
        public static final int RL_SHADER_LOC_VECTOR_VIEW = 11;
        /** Shader location: vector uniform: diffuse color */
        public static final int RL_SHADER_LOC_COLOR_DIFFUSE = 12;
        /** Shader location: vector uniform: specular color */
        public static final int RL_SHADER_LOC_COLOR_SPECULAR = 13;
        /** Shader location: vector uniform: ambient color */
        public static final int RL_SHADER_LOC_COLOR_AMBIENT = 14;
        /** Shader location: sampler2d texture: albedo (same as: RL_SHADER_LOC_MAP_DIFFUSE) */
        public static final int RL_SHADER_LOC_MAP_ALBEDO = 15;
        /** Shader location: sampler2d texture: metalness (same as: RL_SHADER_LOC_MAP_SPECULAR) */
        public static final int RL_SHADER_LOC_MAP_METALNESS = 16;
        /** Shader location: sampler2d texture: normal */
        public static final int RL_SHADER_LOC_MAP_NORMAL = 17;
        /** Shader location: sampler2d texture: roughness */
        public static final int RL_SHADER_LOC_MAP_ROUGHNESS = 18;
        /** Shader location: sampler2d texture: occlusion */
        public static final int RL_SHADER_LOC_MAP_OCCLUSION = 19;
        /** Shader location: sampler2d texture: emission */
        public static final int RL_SHADER_LOC_MAP_EMISSION = 20;
        /** Shader location: sampler2d texture: height */
        public static final int RL_SHADER_LOC_MAP_HEIGHT = 21;
        /** Shader location: samplerCube texture: cubemap */
        public static final int RL_SHADER_LOC_MAP_CUBEMAP = 22;
        /** Shader location: samplerCube texture: irradiance */
        public static final int RL_SHADER_LOC_MAP_IRRADIANCE = 23;
        /** Shader location: samplerCube texture: prefilter */
        public static final int RL_SHADER_LOC_MAP_PREFILTER = 24;
        /** Shader location: sampler2d texture: brdf */
        public static final int RL_SHADER_LOC_MAP_BRDF = 25;
    }
    
    /** Shader uniform data type */
public static class rlShaderUniformDataType{
        
        /** Shader uniform type: float */
        public static final int RL_SHADER_UNIFORM_FLOAT = 0;
        /** Shader uniform type: vec2 (2 float) */
        public static final int RL_SHADER_UNIFORM_VEC2 = 1;
        /** Shader uniform type: vec3 (3 float) */
        public static final int RL_SHADER_UNIFORM_VEC3 = 2;
        /** Shader uniform type: vec4 (4 float) */
        public static final int RL_SHADER_UNIFORM_VEC4 = 3;
        /** Shader uniform type: int */
        public static final int RL_SHADER_UNIFORM_INT = 4;
        /** Shader uniform type: ivec2 (2 int) */
        public static final int RL_SHADER_UNIFORM_IVEC2 = 5;
        /** Shader uniform type: ivec3 (3 int) */
        public static final int RL_SHADER_UNIFORM_IVEC3 = 6;
        /** Shader uniform type: ivec4 (4 int) */
        public static final int RL_SHADER_UNIFORM_IVEC4 = 7;
        /** Shader uniform type: unsigned int */
        public static final int RL_SHADER_UNIFORM_UINT = 8;
        /** Shader uniform type: uivec2 (2 unsigned int) */
        public static final int RL_SHADER_UNIFORM_UIVEC2 = 9;
        /** Shader uniform type: uivec3 (3 unsigned int) */
        public static final int RL_SHADER_UNIFORM_UIVEC3 = 10;
        /** Shader uniform type: uivec4 (4 unsigned int) */
        public static final int RL_SHADER_UNIFORM_UIVEC4 = 11;
        /** Shader uniform type: sampler2d */
        public static final int RL_SHADER_UNIFORM_SAMPLER2D = 12;
    }
    
    /** Shader attribute data types */
public static class rlShaderAttributeDataType{
        
        /** Shader attribute type: float */
        public static final int RL_SHADER_ATTRIB_FLOAT = 0;
        /** Shader attribute type: vec2 (2 float) */
        public static final int RL_SHADER_ATTRIB_VEC2 = 1;
        /** Shader attribute type: vec3 (3 float) */
        public static final int RL_SHADER_ATTRIB_VEC3 = 2;
        /** Shader attribute type: vec4 (4 float) */
        public static final int RL_SHADER_ATTRIB_VEC4 = 3;
    }
    
    /** Framebuffer attachment type */
public static class rlFramebufferAttachType{
        
        /** Framebuffer attachment type: color 0 */
        public static final int RL_ATTACHMENT_COLOR_CHANNEL0 = 0;
        /** Framebuffer attachment type: color 1 */
        public static final int RL_ATTACHMENT_COLOR_CHANNEL1 = 1;
        /** Framebuffer attachment type: color 2 */
        public static final int RL_ATTACHMENT_COLOR_CHANNEL2 = 2;
        /** Framebuffer attachment type: color 3 */
        public static final int RL_ATTACHMENT_COLOR_CHANNEL3 = 3;
        /** Framebuffer attachment type: color 4 */
        public static final int RL_ATTACHMENT_COLOR_CHANNEL4 = 4;
        /** Framebuffer attachment type: color 5 */
        public static final int RL_ATTACHMENT_COLOR_CHANNEL5 = 5;
        /** Framebuffer attachment type: color 6 */
        public static final int RL_ATTACHMENT_COLOR_CHANNEL6 = 6;
        /** Framebuffer attachment type: color 7 */
        public static final int RL_ATTACHMENT_COLOR_CHANNEL7 = 7;
        /** Framebuffer attachment type: depth */
        public static final int RL_ATTACHMENT_DEPTH = 100;
        /** Framebuffer attachment type: stencil */
        public static final int RL_ATTACHMENT_STENCIL = 200;
    }
    
    /** Framebuffer texture attachment type */
public static class rlFramebufferAttachTextureType{
        
        /** Framebuffer texture attachment type: cubemap, +X side */
        public static final int RL_ATTACHMENT_CUBEMAP_POSITIVE_X = 0;
        /** Framebuffer texture attachment type: cubemap, -X side */
        public static final int RL_ATTACHMENT_CUBEMAP_NEGATIVE_X = 1;
        /** Framebuffer texture attachment type: cubemap, +Y side */
        public static final int RL_ATTACHMENT_CUBEMAP_POSITIVE_Y = 2;
        /** Framebuffer texture attachment type: cubemap, -Y side */
        public static final int RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y = 3;
        /** Framebuffer texture attachment type: cubemap, +Z side */
        public static final int RL_ATTACHMENT_CUBEMAP_POSITIVE_Z = 4;
        /** Framebuffer texture attachment type: cubemap, -Z side */
        public static final int RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z = 5;
        /** Framebuffer texture attachment type: texture2d */
        public static final int RL_ATTACHMENT_TEXTURE2D = 100;
        /** Framebuffer texture attachment type: renderbuffer */
        public static final int RL_ATTACHMENT_RENDERBUFFER = 200;
    }
    
    /** Face culling mode */
public static class rlCullMode{
        
        /**  */
        public static final int RL_CULL_FACE_FRONT = 0;
        /**  */
        public static final int RL_CULL_FACE_BACK = 1;
    }
    

    public static Color LIGHTGRAY = c(200, 200, 200, 255);
    public static Color GRAY = c(130, 130, 130, 255);
    public static Color DARKGRAY = c(80, 80, 80, 255);
    public static Color YELLOW = c(253, 249, 0, 255);
    public static Color GOLD = c(255, 203, 0, 255);
    public static Color ORANGE = c(255, 161, 0, 255);
    public static Color PINK = c(255, 109, 194, 255);
    public static Color RED = c(230, 41, 55, 255);
    public static Color MAROON = c(190, 33, 55, 255);
    public static Color GREEN = c(0, 228, 48, 255);
    public static Color LIME = c(0, 158, 47, 255);
    public static Color DARKGREEN = c(0, 117, 44, 255);
    public static Color SKYBLUE = c(102, 191, 255, 255);
    public static Color BLUE = c(0, 121, 241, 255);
    public static Color DARKBLUE = c(0, 82, 172, 255);
    public static Color PURPLE = c(200, 122, 255, 255);
    public static Color VIOLET = c(135, 60, 190, 255);
    public static Color DARKPURPLE = c(112, 31, 126, 255);
    public static Color BEIGE = c(211, 176, 131, 255);
    public static Color BROWN = c(127, 106, 79, 255);
    public static Color DARKBROWN = c(76, 63, 47, 255);
    public static Color WHITE = c(255, 255, 255, 255);
    public static Color BLACK = c(0, 0, 0, 255);
    public static Color BLANK = c(0, 0, 0, 0);
    public static Color MAGENTA = c(255, 0, 255, 255);
    public static Color RAYWHITE = c(245, 245, 245, 255);

    private static Color c(int r, int g, int b, int a) {
        return new Color((byte) r, (byte) g, (byte) b, (byte) a);
    }
}